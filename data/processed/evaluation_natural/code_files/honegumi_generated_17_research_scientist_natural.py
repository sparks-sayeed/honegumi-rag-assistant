# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import math
import random
from typing import Dict, Tuple

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from ax.service.ax_client import AxClient, ObjectiveProperties


# -----------------------------
# Problem: Laser-material processing
# Goal: Minimize surface roughness (Ra, micrometers) by tuning laser power and scan velocity
# Budget: 30 experiments (batch size = 1)
# Noise model: True (we report a measurement with SEM)
# Model: Default GP (Ax will choose a Sobol + GP strategy)
# -----------------------------

# Parameter bounds (adjust to your equipment/material safely achievable ranges)
LASER_POWER_MIN_W = 50.0     # Watts
LASER_POWER_MAX_W = 300.0    # Watts
SCAN_VELOCITY_MIN_MM_S = 100.0   # mm/s
SCAN_VELOCITY_MAX_MM_S = 2000.0  # mm/s

# Objective (name must match Ax experiment configuration)
METRIC_SURFACE_ROUGHNESS = "surface_roughness_ra_um"  # micrometers (Ra)

# Reproducibility (only affects the simulation stub, not your real experiments)
RNG_SEED = 42
random.seed(RNG_SEED)
np.random.seed(RNG_SEED)


def evaluate_edge_quality(laser_power_watt: float, scan_velocity_mm_per_s: float) -> Dict[str, Tuple[float, float]]:
    """
    Evaluate the edge quality for a given laser power and scan velocity.

    NOTE: Replace this physics-inspired stub with your actual measurement pipeline.
    In production, this function should:
      - Command the laser tool to run at the specified settings
      - Measure surface roughness (Ra, micrometers) on the resulting edge
      - Return the measured value and an estimate of measurement SEM (standard error)

    Returns a dict mapping metric name to (mean, SEM).
    """

    # ---- BEGIN realistic simulation stub (replace with actual measurements) ----
    # Physical intuition:
    # - A useful control parameter is linear energy input E = P / v (J/mm ignoring efficiency constants).
    # - Roughness tends to be low around an optimal energy density; too low -> incomplete melting (rough),
    #   too high -> excessive melt/recast (also rough).
    # Pick an arbitrary "optimal" E*, then make roughness increase quadratically with log deviation from E*.
    # Add mild curvature in power and velocity separately to emulate second-order effects.

    # Define a notional optimal energy input (scaled) and curvature strengths
    # Units here are arbitrary for the surrogate; adjust if you know your process better.
    energy_input = laser_power_watt / max(scan_velocity_mm_per_s, 1e-6)  # W / (mm/s) ~ J/mm up to a factor
    E_star = 0.12  # "optimal" energy input (W·s/mm); tune this to shape the landscape
    log_dev = math.log(max(energy_input, 1e-9) / E_star)

    # Base roughness floor (best-case achievable in this synthetic landscape)
    base_ra_um = 0.8

    # Penalties for deviating from optimum energy input and for extreme absolute settings
    roughness_model = (
        base_ra_um
        + 6.0 * (log_dev ** 2)  # dominant bowl-shaped dependence around E*
        + 0.000002 * (scan_velocity_mm_per_s - 800.0) ** 2  # secondary effect of velocity
        + 0.00002 * (laser_power_watt - 160.0) ** 2         # secondary effect of power
    )

    # Add heteroscedastic noise: more noise at extreme settings (simulating unstable process)
    noise_scale = 0.05 + 0.000002 * (scan_velocity_mm_per_s - 1000.0) ** 2 + 0.00002 * (laser_power_watt - 175.0) ** 2
    measurement_noise = np.random.normal(loc=0.0, scale=noise_scale)
    measured_ra_um = max(0.1, roughness_model + measurement_noise)  # clamp to >0

    # Standard error of the mean for a single measurement; adjust to your metrology
    sem_ra_um = max(0.02, noise_scale * 0.8)
    # ---- END simulation stub ----

    return {
        METRIC_SURFACE_ROUGHNESS: (float(measured_ra_um), float(sem_ra_um))
    }


def main() -> None:
    # Initialize Ax client
    ax_client = AxClient()

    # Create experiment: 2 continuous parameters, single objective (minimize surface roughness)
    ax_client.create_experiment(
        parameters=[
            {
                "name": "laser_power_watt",
                "type": "range",
                "bounds": [LASER_POWER_MIN_W, LASER_POWER_MAX_W],
            },
            {
                "name": "scan_velocity_mm_per_s",
                "type": "range",
                "bounds": [SCAN_VELOCITY_MIN_MM_S, SCAN_VELOCITY_MAX_MM_S],
            },
        ],
        objectives={
            METRIC_SURFACE_ROUGHNESS: ObjectiveProperties(minimize=True),
        },
    )

    # Optimization loop
    NUM_TRIALS = 30  # Budget: 30 controlled experiments

    for _ in range(NUM_TRIALS):
        parameterization, trial_index = ax_client.get_next_trial()

        # Extract parameters
        laser_power_watt = float(parameterization["laser_power_watt"])
        scan_velocity_mm_per_s = float(parameterization["scan_velocity_mm_per_s"])

        # Run experiment/simulation and report noisy measurement with SEM
        try:
            results = evaluate_edge_quality(
                laser_power_watt=laser_power_watt,
                scan_velocity_mm_per_s=scan_velocity_mm_per_s,
            )
            ax_client.complete_trial(trial_index=trial_index, raw_data=results)
        except Exception as e:
            # Fail the trial gracefully if the evaluation fails (e.g., equipment error)
            ax_client.log_trial_failure(trial_index=trial_index)
            print(f"Trial {trial_index} failed with error: {e}")

    # Retrieve best found parameters and corresponding metric
    best_parameters, best_metrics = ax_client.get_best_parameters()
    best_ra = best_metrics[METRIC_SURFACE_ROUGHNESS]["mean"]
    best_ra_sem = best_metrics[METRIC_SURFACE_ROUGHNESS]["sem"]

    print("Best settings found:")
    print(f"  laser_power_watt: {best_parameters['laser_power_watt']:.3f} W")
    print(f"  scan_velocity_mm_per_s: {best_parameters['scan_velocity_mm_per_s']:.3f} mm/s")
    print(f"Estimated surface roughness (Ra): {best_ra:.3f} ± {best_ra_sem:.3f} μm")

    # Plot progress
    metric_name = METRIC_SURFACE_ROUGHNESS
    df = ax_client.get_trials_data_frame()

    # Some versions of Ax return a tidy frame; pivot if necessary
    if metric_name not in df.columns:
        # Attempt to pivot to get a column per metric
        if {"trial_index", "metric_name", "mean"}.issubset(df.columns):
            df_plot = df.pivot(index="trial_index", columns="metric_name", values="mean")
            series = df_plot[metric_name]
        else:
            # Fallback: try 'mean' as single metric
            series = df["mean"]
    else:
        series = df[metric_name]

    # Ensure series is sorted by trial index
    series = series.sort_index()

    fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
    ax.scatter(series.index, series.values, ec="k", fc="none", label="Observed")
    ax.plot(series.index, np.minimum.accumulate(series.values), color="#0033FF", lw=2, label="Best to Trial")
    ax.set_xlabel("Trial Number")
    ax.set_ylabel("Surface Roughness Ra (μm)")
    ax.set_title("Laser Edge Quality Optimization (Ax)")
    ax.legend()
    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    main()