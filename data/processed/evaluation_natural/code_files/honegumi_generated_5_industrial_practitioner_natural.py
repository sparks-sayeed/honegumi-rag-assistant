# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"
obj2_name = "branin_swapped"


def branin3_moo(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    # second objective has x1 and x2 swapped
    y2 = float(
        (x1 - 5.1 / (4 * np.pi**2) * x2**2 + 5.0 / np.pi * x2 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x2)
        + 10
    )

    # Contrived way to incorporate x3 into the second objective
    y2 = y2 * (1 - 0.1 * x1 * x2 * x3)

    return {obj1_name: y, obj2_name: y2}


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
        obj2_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
    ],
)


for i in range(21):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]
    x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

    results = branin3_moo(x1, x2, x3)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)
pareto_results = ax_client.get_pareto_optimal_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto[objectives[0]],
    pareto[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])

ax.legend()
plt.show()

# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from typing import Dict, Tuple
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain-specific metric names
BIOAVAILABILITY_METRIC = "bioavailability_percent"
STABILITY_METRIC = "shelf_stability_months"

# Composition total for 5 excipients (fractions sum to 1.0)
COMPOSITION_TOTAL = 1.0

# Decision variable bounds
PH_LOWER, PH_UPPER = 2.0, 9.0
TEMP_C_LOWER, TEMP_C_UPPER = 2.0, 40.0

# Experiment configuration
TOTAL_TRIALS = 50
RANDOM_SEED = 1234


def evaluate_formulation(
    excipient_1_frac: float,
    excipient_2_frac: float,
    excipient_3_frac: float,
    excipient_4_frac: float,
    excipient_5_frac: float,
    formulation_pH: float,
    storage_temperature_celsius: float,
    rng: np.random.Generator,
) -> Dict[str, Tuple[float, float]]:
    """
    Synthetic evaluator for a pharma formulation with:
      - 5 excipient fractions (sum to 1.0)
      - formulation pH
      - storage temperature in Celsius

    Returns two noisy objectives to maximize:
      - bioavailability_percent (0-100%)
      - shelf_stability_months (0-60 months)

    Notes:
      - Replace this synthetic model with real lab measurements:
          • Run the experiment for the suggested composition/pH/temp
          • Measure bioavailability (e.g., in vitro / in vivo)
          • Measure stability (e.g., potency retained vs time at storage temp)
          • Return means and SEMs for both metrics below
    """

    # Pack fractions, ensure they sum (numerically robust)
    fracs = np.array(
        [excipient_1_frac, excipient_2_frac, excipient_3_frac, excipient_4_frac, excipient_5_frac],
        dtype=float,
    )
    fracs = np.clip(fracs, 0.0, 1.0)
    # Defensive normalization in case of tiny numerical drift:
    fracs = fracs / max(fracs.sum(), 1e-9)

    # Synthetic relationships (domain-inspired, not real data):
    # - bioavailability: surfactant/disintegrant help, excess filler harms, neutral pH helps
    w_bio = np.array([0.25, 0.35, -0.25, 0.10, 0.25])  # weights over fractions
    synergy_bio = 0.6 * fracs[1] * fracs[4]  # surfactant x disintegrant synergy
    ph_opt = 6.5
    ph_penalty = -0.18 * (formulation_pH - ph_opt) ** 2  # parabolic drop from optimum

    bio_raw = 55.0 + 45.0 * (w_bio @ fracs + synergy_bio) + 20.0 * ph_penalty
    bioavailability = float(np.clip(bio_raw, 0.0, 100.0))

    # - stability: stabilizer/polymer binder help, high temperature harms, extreme pH harms
    w_stab = np.array([0.30, -0.10, 0.15, 0.40, 0.15])
    base_months_at_25 = 18.0 + 24.0 * (w_stab @ fracs)
    base_months_at_25 = float(np.clip(base_months_at_25, 3.0, 48.0))

    ph_mid = 7.0
    ph_stab_penalty = np.exp(-((formulation_pH - ph_mid) ** 2) / (2.0 * 1.8**2))  # 0..1
    ph_stab_factor = 0.6 + 0.4 * ph_stab_penalty  # 0.6..1.0

    # Arrhenius-like temperature penalty (higher T -> lower stability)
    temp_factor = float(np.exp(-0.04 * (storage_temperature_celsius - 25.0)))
    shelf_stability = float(np.clip(base_months_at_25 * ph_stab_factor * temp_factor, 0.0, 60.0))

    # Additive Gaussian noise; replace with real SEMs when available
    bio_noise_sd = 2.5
    stab_noise_sd = 1.0
    noisy_bio = bioavailability + rng.normal(0.0, bio_noise_sd)
    noisy_stab = shelf_stability + rng.normal(0.0, stab_noise_sd)

    # Return (mean, SEM) tuples as Ax expects when modeling noisy metrics
    return {
        BIOAVAILABILITY_METRIC: (float(np.clip(noisy_bio, 0.0, 100.0)), bio_noise_sd),
        STABILITY_METRIC: (float(np.clip(noisy_stab, 0.0, 60.0)), stab_noise_sd),
    }


def main():
    rng = np.random.default_rng(RANDOM_SEED)

    ax_client = AxClient()
    ax_client.create_experiment(
        name="pharma_formulation_moo",
        parameters=[
            # Reparameterized compositional space: optimize 4 fractions, derive the 5th
            {"name": "excipient_1_frac", "type": "range", "bounds": [0.0, 1.0]},
            {"name": "excipient_2_frac", "type": "range", "bounds": [0.0, 1.0]},
            {"name": "excipient_3_frac", "type": "range", "bounds": [0.0, 1.0]},
            {"name": "excipient_4_frac", "type": "range", "bounds": [0.0, 1.0]},
            {"name": "formulation_pH", "type": "range", "bounds": [PH_LOWER, PH_UPPER]},
            {
                "name": "storage_temperature_celsius",
                "type": "range",
                "bounds": [TEMP_C_LOWER, TEMP_C_UPPER],
            },
        ],
        objectives={
            BIOAVAILABILITY_METRIC: ObjectiveProperties(minimize=False),
            STABILITY_METRIC: ObjectiveProperties(minimize=False),
        },
        # Sum of the 4 optimized fractions must be <= 1.0; the 5th is derived to close the mass balance.
        parameter_constraints=[
            "excipient_1_frac + excipient_2_frac + excipient_3_frac + excipient_4_frac <= 1.0"
        ],
        overwrite_existing_experiment=True,
        is_test=False,
    )

    for i in range(TOTAL_TRIALS):
        params, trial_index = ax_client.get_next_trial()

        # Extract decision variables
        e1 = float(params["excipient_1_frac"])
        e2 = float(params["excipient_2_frac"])
        e3 = float(params["excipient_3_frac"])
        e4 = float(params["excipient_4_frac"])
        pH = float(params["formulation_pH"])
        temp_c = float(params["storage_temperature_celsius"])

        # Compute the 5th fraction from the composition constraint
        e5 = COMPOSITION_TOTAL - (e1 + e2 + e3 + e4)
        # Guard against minimal negative numerical drift
        if e5 < 0.0 and e5 > -1e-8:
            e5 = 0.0

        # If constraint was violated (shouldn't happen due to Ax constraint), clip to zero-sum feasibility
        if e5 < 0.0:
            # Penalize infeasible proposals aggressively
            raw_data = {
                BIOAVAILABILITY_METRIC: (0.0, 5.0),
                STABILITY_METRIC: (0.0, 2.0),
            }
        else:
            raw_data = evaluate_formulation(
                excipient_1_frac=e1,
                excipient_2_frac=e2,
                excipient_3_frac=e3,
                excipient_4_frac=e4,
                excipient_5_frac=e5,
                formulation_pH=pH,
                storage_temperature_celsius=temp_c,
                rng=rng,
            )

        ax_client.complete_trial(trial_index=trial_index, raw_data=raw_data)

    # Retrieve Pareto-optimal observed points
    pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

    # Build a display of Pareto-optimal outcomes
    pareto_points = []
    pareto_params = []
    for _, (pdict, vdict) in pareto.items():
        bio = vdict[BIOAVAILABILITY_METRIC][0]
        stab = vdict[STABILITY_METRIC][0]
        pareto_points.append((bio, stab))
        # Compute the derived excipient_5 for reporting
        e1 = pdict["excipient_1_frac"]
        e2 = pdict["excipient_2_frac"]
        e3 = pdict["excipient_3_frac"]
        e4 = pdict["excipient_4_frac"]
        e5 = max(0.0, COMPOSITION_TOTAL - (e1 + e2 + e3 + e4))
        pareto_params.append(
            {
                **pdict,
                "excipient_5_frac": e5,
                BIOAVAILABILITY_METRIC: bio,
                STABILITY_METRIC: stab,
            }
        )

    pareto_df = pd.DataFrame(pareto_params).sort_values(BIOAVAILABILITY_METRIC, ascending=True)
    if not pareto_df.empty:
        print("\nPareto-optimal observed formulations (top 10):")
        print(
            pareto_df[
                [
                    "excipient_1_frac",
                    "excipient_2_frac",
                    "excipient_3_frac",
                    "excipient_4_frac",
                    "excipient_5_frac",
                    "formulation_pH",
                    "storage_temperature_celsius",
                    BIOAVAILABILITY_METRIC,
                    STABILITY_METRIC,
                ]
            ].head(10).to_string(index=False)
        )

    # Plot observed outcomes and Pareto frontier
    objectives = ax_client.objective_names
    df = ax_client.get_trials_data_frame()
    # df is expected to have a wide format with metric columns named as objectives
    fig, ax = plt.subplots(figsize=(7, 5), dpi=140)

    # Observed data
    ax.scatter(
        df[objectives[0]],
        df[objectives[1]],
        fc="None",
        ec="k",
        label="Observed",
        alpha=0.7,
    )

    # Pareto front (connect points sorted by first objective)
    if pareto_points:
        pareto_sorted = sorted(pareto_points, key=lambda t: t[0])
        ax.plot(
            [p[0] for p in pareto_sorted],
            [p[1] for p in pareto_sorted],
            color="#0033FF",
            lw=2,
            label="Pareto Front",
        )

    ax.set_xlabel(objectives[0].replace("_", " "))
    ax.set_ylabel(objectives[1].replace("_", " "))
    ax.set_title("Formulation Optimization: Bioavailability vs. Stability")
    ax.legend()
    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    main()