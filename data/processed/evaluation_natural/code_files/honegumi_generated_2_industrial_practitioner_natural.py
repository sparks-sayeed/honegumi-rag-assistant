# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from typing import Dict, Tuple, Any
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Problem: Optimize anti-corrosion coating formulation and thickness to minimize corrosion damage.
# Parameters (decision variables):
#   - resin_fraction, inhibitor_fraction, insulator_fraction (continuous, [0, 1])
#   - stabilizer_fraction is derived from the composition constraint: 1 - (resin + inhibitor + insulator)
#   - coating_thickness_microns (continuous, practical range provided below)
# Constraints:
#   - resin_fraction + inhibitor_fraction + insulator_fraction + stabilizer_fraction == 1.0
#       -> reparameterized as: resin + inhibitor + insulator <= 1.0; stabilizer = 1 - (resin + inhibitor + insulator)
#   - resin_fraction >= inhibitor_fraction
#   - resin_fraction >= insulator_fraction
# Objective:
#   - Minimize corrosion_damage (arbitrary units; lower is better)
# Batch setup:
#   - Batch size = 6 (synchronous)
#   - Total trials budget = 120 (20 batches of 6)


OBJECTIVE_NAME = "corrosion_damage"
COMPOSITION_TOTAL = 1.0

# Practical thickness bounds (micrometers). Adjust to your lab's allowable range if needed.
THICKNESS_MIN = 10.0
THICKNESS_MAX = 80.0

# Reproducible RNG for simulated measurement noise
_rng = np.random.default_rng(seed=2025)


def evaluate_corrosion_damage(
    resin_fraction: float,
    inhibitor_fraction: float,
    insulator_fraction: float,
    stabilizer_fraction: float,
    coating_thickness_microns: float,
) -> float:
    """
    Simulated evaluation of corrosion damage for a coating formulation.
    Lower returned value indicates better performance (less damage).

    NOTE: Replace this with your actual experimental measurement pipeline.
    Example pathways:
      - Run a lab test (salt spray / electrochemical impedance) and return measured damage
      - Call a physics-based corrosion simulator
      - Query a database of past experiments, etc.

    Returns:
      corrosion_damage (float): damage units (arbitrary), lower is better.
    """

    # Safety checks and penalties if numerical imprecision yields tiny violations
    sum_components = resin_fraction + inhibitor_fraction + insulator_fraction + stabilizer_fraction
    if sum_components <= 0:
        return 1e6  # invalid composition
    if stabilizer_fraction < -1e-9 or stabilizer_fraction > 1 + 1e-9:
        return 1e6  # invalid composition

    # Base damage level without protection
    base_damage = 100.0

    # Protective contributions (bounded, monotonic, and with plausible saturations)
    # Resin: film formation and adhesion barrier
    resin_eff = 0.55 * np.power(max(resin_fraction, 0.0), 0.85)

    # Inhibitor: chemical passivation, saturating effect
    inhibitor_eff = 0.95 * (1.0 - np.exp(-4.2 * max(inhibitor_fraction, 0.0)))

    # Insulator: reduces ionic/electronic transport through film
    insulator_eff = 0.35 * np.power(max(insulator_fraction, 0.0), 0.6)

    # Stabilizer: minor effect; too much can hinder barrier continuity
    # Small benefit at low levels, slight penalty at high levels
    st = max(stabilizer_fraction, 0.0)
    stabilizer_contrib = 0.05 * np.minimum(st, 0.15) / 0.15  # up to +0.05
    stabilizer_penalty_factor = 1.0 + 0.15 * max(0.0, st - 0.4)  # increases damage if stabilizer > 0.4

    # Thickness: diminished returns with increasing thickness
    t = np.clip(coating_thickness_microns, THICKNESS_MIN, THICKNESS_MAX)
    thickness_eff = 0.8 * (1.0 - np.exp(-0.045 * (t - THICKNESS_MIN)))

    # Synergy: inhibitor works better with sufficient resin; mild synergy term
    synergy = 0.3 * resin_fraction * inhibitor_fraction

    # Aggregate protective effectiveness
    protection = resin_eff + inhibitor_eff + insulator_eff + thickness_eff + stabilizer_contrib + synergy
    # Bound overall protection to avoid negative damage
    protection = np.clip(protection, 0.0, 0.97)

    # Convert to damage
    damage = base_damage * (1.0 - protection)

    # Penalize low resin if it's not sufficiently dominating others (even if constraints are met)
    # Encourages resin to be meaningfully higher than inhibitor/insulator.
    dominance_margin = min(resin_fraction - inhibitor_fraction, resin_fraction - insulator_fraction)
    if dominance_margin < 0.05:
        damage *= 1.0 + 0.05 * (0.05 - dominance_margin) / 0.05  # up to +5%

    # Apply stabilizer penalty factor (if stabilizer too high)
    damage *= stabilizer_penalty_factor

    # Add realistic measurement noise (heteroscedastic, multiplicative + additive)
    noise_mult = _rng.normal(loc=1.0, scale=0.03)  # ~3% multiplicative noise
    noise_add = _rng.normal(loc=0.0, scale=0.5)    # small additive noise
    observed_damage = max(0.0, damage * noise_mult + noise_add)

    return float(observed_damage)


ax_client = AxClient()

# Create experiment with 3 explicit composition parameters (resin, inhibitor, insulator),
# 1 derived parameter (stabilizer), and 1 process parameter (thickness).
ax_client.create_experiment(
    name="anti_corrosion_coating_optimization",
    parameters=[
        {"name": "resin_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "inhibitor_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "insulator_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "coating_thickness_microns", "type": "range", "bounds": [THICKNESS_MIN, THICKNESS_MAX]},
    ],
    objectives={
        OBJECTIVE_NAME: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        # Composition constraint via reparameterization:
        # stabilizer_fraction = 1 - (resin + inhibitor + insulator) must be >= 0
        f"resin_fraction + inhibitor_fraction + insulator_fraction <= {COMPOSITION_TOTAL}",
        # Order constraints:
        "resin_fraction >= inhibitor_fraction",
        "resin_fraction >= insulator_fraction",
    ],
)

batch_size = 6
num_batches = 20  # Total trials = 6 * 20 = 120


for _ in range(num_batches):
    parameterizations, optimization_complete = ax_client.get_next_trials(batch_size=batch_size)

    for trial_index, params in list(parameterizations.items()):
        # Extract explicit parameters
        resin = float(params["resin_fraction"])
        inhibitor = float(params["inhibitor_fraction"])
        insulator = float(params["insulator_fraction"])
        thickness = float(params["coating_thickness_microns"])

        # Derive stabilizer from composition constraint
        stabilizer = COMPOSITION_TOTAL - (resin + inhibitor + insulator)

        # If small numerical negatives occur, clip to zero
        if stabilizer < 0 and stabilizer > -1e-9:
            stabilizer = 0.0

        # Evaluate objective
        corrosion_damage_value = evaluate_corrosion_damage(
            resin_fraction=resin,
            inhibitor_fraction=inhibitor,
            insulator_fraction=insulator,
            stabilizer_fraction=stabilizer,
            coating_thickness_microns=thickness,
        )

        # Report result back to Ax
        ax_client.complete_trial(
            trial_index=trial_index,
            raw_data={OBJECTIVE_NAME: corrosion_damage_value},
        )

best_parameters, best_objectives = ax_client.get_best_parameters()
print("Best parameters (with derived stabilizer_fraction):")
resin_best = best_parameters["resin_fraction"]
inhibitor_best = best_parameters["inhibitor_fraction"]
insulator_best = best_parameters["insulator_fraction"]
stabilizer_best = COMPOSITION_TOTAL - (resin_best + inhibitor_best + insulator_best)
thickness_best = best_parameters["coating_thickness_microns"]

print(
    {
        "resin_fraction": resin_best,
        "inhibitor_fraction": inhibitor_best,
        "insulator_fraction": insulator_best,
        "stabilizer_fraction": stabilizer_best,
        "coating_thickness_microns": thickness_best,
    }
)
print("Best observed corrosion_damage:", best_objectives[OBJECTIVE_NAME])

# Plot results across batches
objective_name = ax_client.objective_names[0]
df = ax_client.get_trials_data_frame()
df.index = df.index // batch_size  # group by batch

y = df[objective_name]
fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, y, ec="k", fc="none", label="Observed")
ax.plot(df.index, np.minimum.accumulate(y.values), color="#0033FF", lw=2, label="Best to Trial")
ax.set_xlabel("Batch Number")
ax.set_ylabel(objective_name)
ax.legend()
plt.tight_layout()
plt.show()