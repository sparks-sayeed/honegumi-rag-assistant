# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin3(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    return y


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
    ],
)


for i in range(21):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]
    x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

    results = branin3(x1, x2, x3)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


objective_name = "ionic_conductivity"


def measure_ionic_conductivity(
    salt1_fraction: float,
    salt2_fraction: float,
    salt3_fraction: float,
    salt4_fraction: float,
) -> float:
    """
    Simulated evaluation of ionic conductivity (mS/cm) for a 4-salt electrolyte mixture.
    Replace this with the actual lab measurement or simulation call.

    Inputs are fractions (non-negative) that sum to 1.0.
    Returns a single float value representing measured ionic conductivity in mS/cm.

    This stub models:
    - Base conductivity as a weighted sum of pure-salt contributions.
    - Beneficial pairwise synergies (notably between salt2 and salt3).
    - Mild antagonism between salt1 and salt4.
    - A soft preference toward an interior composition.
    - Additive Gaussian measurement noise (sigma ~ 0.2 mS/cm).
    """
    f = np.array([salt1_fraction, salt2_fraction, salt3_fraction, salt4_fraction])
    # Base (hypothetical) pure-salt conductivities in mS/cm
    base_conductivities = np.array([3.0, 12.0, 8.5, 5.0])

    # Base linear mixture
    kappa = float(np.dot(base_conductivities, f))

    # Synergy/antagonism terms
    kappa += 15.0 * f[1] * f[2]      # strong synergy between salt2 and salt3
    kappa += 4.0 * f[0] * f[1]       # mild synergy between salt1 and salt2
    kappa -= 2.0 * f[0] * f[3]       # mild antagonism between salt1 and salt4

    # Preference toward an interior composition (soft prior)
    preferred = np.array([0.15, 0.45, 0.30, 0.10])
    kappa -= 10.0 * float(np.sum((f - preferred) ** 2))

    # Add measurement noise
    noise = np.random.normal(loc=0.0, scale=0.2)
    kappa_noisy = max(kappa + noise, 0.0)  # enforce non-negativity

    return float(kappa_noisy)


# Total composition sum for salts must equal 1.0
total_fraction = 1.0

# For reproducibility of this simulated evaluation
np.random.seed(123)

ax_client = AxClient()
ax_client.create_experiment(
    name="battery_electrolyte_formulation_ionic_conductivity",
    parameters=[
        # Three free fractions; the 4th is derived as 1 - (f1 + f2 + f3)
        {"name": "salt1_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "salt2_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "salt3_fraction", "type": "range", "bounds": [0.0, 1.0]},
    ],
    objectives={
        objective_name: ObjectiveProperties(minimize=False),
    },
    # Reparameterized composition constraint: salt1 + salt2 + salt3 <= 1.0
    # with salt4 = 1.0 - (salt1 + salt2 + salt3)
    parameter_constraints=[
        "salt1_fraction + salt2_fraction + salt3_fraction <= 1.0",
    ],
)

# Run up to 40 sequential trials (experiments)
num_trials = 40
for i in range(num_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    f1 = float(parameterization["salt1_fraction"])
    f2 = float(parameterization["salt2_fraction"])
    f3 = float(parameterization["salt3_fraction"])
    # Compute the 4th fraction from the composition constraint, clip to [0, 1]
    f4 = max(0.0, total_fraction - (f1 + f2 + f3))

    conductivity = measure_ionic_conductivity(f1, f2, f3, f4)

    # Report the measured objective value back to Ax
    ax_client.complete_trial(trial_index=trial_index, raw_data=conductivity)

# Retrieve and print best-found formulation
best_parameters, best_values = ax_client.get_best_parameters()
best_f1 = float(best_parameters["salt1_fraction"])
best_f2 = float(best_parameters["salt2_fraction"])
best_f3 = float(best_parameters["salt3_fraction"])
best_f4 = max(0.0, total_fraction - (best_f1 + best_f2 + best_f3))

print("Best formulation found:")
print(
    {
        "salt1_fraction": best_f1,
        "salt2_fraction": best_f2,
        "salt3_fraction": best_f3,
        "salt4_fraction": best_f4,
    }
)
print("Best observed ionic conductivity (Ax summary):", best_values)

# Plot observed objective values and best-to-date
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives[0]], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.maximum.accumulate(df[objectives[0]].values),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(f"{objectives[0]} (mS/cm)")
ax.legend()
plt.tight_layout()
plt.show()