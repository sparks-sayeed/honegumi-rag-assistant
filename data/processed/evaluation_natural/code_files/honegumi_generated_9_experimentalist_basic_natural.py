# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


objective_name = "compressive_strength_mpa"


def measure_concrete_compressive_strength(
    cement_fraction: float,
    water_fraction: float,
    aggregate_fraction: float,
    rng: np.random.RandomState,
) -> float:
    """
    Simulated compressive strength (MPa) for a concrete mix defined by fractions
    of cement, water, and aggregate that sum to 1.

    Model notes (heuristic but physically motivated):
    - Follows Abram's law: strength increases as water/cement ratio decreases.
    - Moderate aggregate content improves packing; too much reduces paste and strength.
    - Small linear terms capture additional trends; Gaussian noise represents measurement noise.

    The function is smooth and noisy to be suitable for Bayesian optimization.

    Returns:
        Compressive strength in MPa (float).
    """
    eps = 1e-8
    w_c = water_fraction / max(cement_fraction, eps)

    # Abram's law-like term: larger when w/c is small
    abram_term = 85.0 * (w_c + 0.1) ** (-0.7)

    # Aggregate packing benefit around ~0.65 aggregate fraction
    packing_term = -30.0 * (aggregate_fraction - 0.65) ** 2 + 10.0

    # Small linear terms for cement/water contribution
    linear_term = 12.0 * cement_fraction - 6.0 * water_fraction

    # Base strength plus terms
    strength = 10.0 + abram_term + packing_term + linear_term

    # Additive Gaussian noise (measurement/process noise)
    noise = rng.normal(loc=0.0, scale=2.0)
    strength_noisy = float(np.clip(strength + noise, a_min=1.0, a_max=120.0))
    return strength_noisy


sum_to_one_total = 1.0
rng = np.random.RandomState(12345)

ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "cement_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "water_fraction", "type": "range", "bounds": [0.0, 1.0]},
    ],
    objectives={
        objective_name: ObjectiveProperties(minimize=False),
    },
    parameter_constraints=[
        # Composition: cement + water <= 1, aggregate is computed as the remainder
        f"cement_fraction + water_fraction <= {sum_to_one_total}",
        # Ordering constraints to enforce cement >= water and aggregate is the largest
        "water_fraction <= cement_fraction",
        "2.0*cement_fraction + water_fraction <= 1.0",
        "cement_fraction + 2.0*water_fraction <= 1.0",
    ],
)

# Run 20 sequential trials (batch size = 1)
for _ in range(20):
    parameterization, trial_index = ax_client.get_next_trial()

    cement_fraction = float(parameterization["cement_fraction"])
    water_fraction = float(parameterization["water_fraction"])
    aggregate_fraction = float(sum_to_one_total - (cement_fraction + water_fraction))

    strength_mpa = measure_concrete_compressive_strength(
        cement_fraction=cement_fraction,
        water_fraction=water_fraction,
        aggregate_fraction=aggregate_fraction,
        rng=rng,
    )

    ax_client.complete_trial(trial_index=trial_index, raw_data=strength_mpa)

best_parameters, best_values = ax_client.get_best_parameters()

# Plot results
df = ax_client.get_trials_data_frame()

# Try wide format first; fallback to pivot if needed
if objective_name in df.columns:
    y_vals = df[objective_name].astype(float).values
    x_vals = np.arange(len(y_vals))
else:
    # Fallback for long format
    if {"trial_index", "metric_name", "mean"}.issubset(set(df.columns)):
        wide = df.pivot(index="trial_index", columns="metric_name", values="mean").sort_index()
        y_vals = wide[objective_name].astype(float).values
        x_vals = wide.index.values
    else:
        # Last resort: try to extract via any numeric column
        numeric_cols = df.select_dtypes(include=["number"]).columns.tolist()
        if numeric_cols:
            y_vals = df[numeric_cols[0]].astype(float).values
            x_vals = np.arange(len(y_vals))
        else:
            y_vals = np.array([])
            x_vals = np.array([])

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
if y_vals.size > 0:
    ax.scatter(x_vals, y_vals, ec="k", fc="none", label="Observed")
    ax.plot(
        x_vals,
        np.maximum.accumulate(y_vals),
        color="#0033FF",
        lw=2,
        label="Best to Trial",
    )
ax.set_xlabel("Trial Number")
ax.set_ylabel("Compressive Strength (MPa)")
ax.set_title("Concrete Mix Optimization (Cement/Water/Aggregate)")
ax.legend()
plt.tight_layout()
plt.show()