# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


from ax.modelbridge.factory import Models
from ax.modelbridge.generation_strategy import GenerationStep, GenerationStrategy
from botorch.acquisition import UpperConfidenceBound

from ax.modelbridge.registry import Specified_Task_ST_MTGP_trans
from ax.core.observation import ObservationFeatures

obj1_name = "branin"


def branin_mt(x1, x2, task):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # if multi-task, add a penalty based on task
    penalty_lookup = {"A": 1.0, "B": 1.1 + x1 + 2 * x2}
    y += penalty_lookup[task]

    return y


gs = GenerationStrategy(
    steps=[
        GenerationStep(
            model=Models.SOBOL,
            num_trials=4,  # how many sobol trials to perform (rule of thumb: 2 * number of params)
            min_trials_observed=3,
            max_parallelism=5,
            model_kwargs={"seed": 999, "transforms": Specified_Task_ST_MTGP_trans},
            model_gen_kwargs={"deduplicate": True},
        ),
        GenerationStep(
            model=Models.BOTORCH_MODULAR,
            num_trials=-1,
            max_parallelism=3,
            model_kwargs={
                "botorch_acqf_class": UpperConfidenceBound,
                "transforms": Specified_Task_ST_MTGP_trans,
            },
        ),
    ]
)

ax_client = AxClient(generation_strategy=gs)

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
        {
            "name": "task",
            "type": "choice",
            "values": ["A", "B"],
            "is_task": True,
            "target_value": "B",
        },
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial(
        fixed_features=ObservationFeatures({"task": "A" if i % 2 == 0 else "B"})
    )

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    task = parameterization["task"]

    results = branin_mt(x1, x2, task)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
task = "A"  # specify task results to plot
df = df[df.task == task]
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_title(f"Task {task}")
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Generated by an adapted Honegumi template for multi-task optimization of ceramic binder systems
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt

from ax.modelbridge.factory import Models
from ax.modelbridge.generation_strategy import GenerationStep, GenerationStrategy
from botorch.acquisition import UpperConfidenceBound

from ax.modelbridge.registry import Specified_Task_ST_MTGP_trans
from ax.core.observation import ObservationFeatures


objective_name = "green_strength"

rng = np.random.default_rng(seed=1234)


def simulate_green_strength(
    binder_wt_pct: float,
    plasticizer_wt_pct: float,
    dispersant_wt_pct: float,
    solids_loading_pct: float,
    cosolvent_fraction: float,
    mixing_time_min: float,
    ceramic_matrix: str,
) -> float:
    """
    Synthetic, physics-inspired surrogate for green strength (MPa) of ceramic bodies
    formed with polymeric binder systems across different ceramic matrices.

    The function encodes:
    - Unimodal optima for composition/process parameters
    - Task-specific optima and scaling to enable knowledge transfer
    - Parameter interactions (e.g., binder x solids loading)
    - Heteroskedastic but modest measurement noise

    NOTE: Replace this surrogate with actual experimental measurement logic to use in production.
    """
    # Task-specific baselines and optima
    task_params = {
        "alumina": {
            "base": 14.0,
            "binder_opt": 4.8,
            "plasticizer_opt": 1.2,
            "dispersant_opt": 0.6,
            "solids_opt": 59.0,
            "cosolvent_opt": 0.35,
            "mix_opt": 50.0,
            "scale": 1.0,
        },
        "zirconia": {
            "base": 16.0,
            "binder_opt": 5.5,
            "plasticizer_opt": 1.6,
            "dispersant_opt": 0.8,
            "solids_opt": 61.0,
            "cosolvent_opt": 0.40,
            "mix_opt": 60.0,
            "scale": 1.1,
        },
        "silicon_carbide": {
            "base": 12.0,
            "binder_opt": 4.2,
            "plasticizer_opt": 0.9,
            "dispersant_opt": 0.5,
            "solids_opt": 57.0,
            "cosolvent_opt": 0.30,
            "mix_opt": 55.0,
            "scale": 0.9,
        },
    }

    p = task_params[ceramic_matrix]

    def gaussian_peak(x, mu, w):
        # Unimodal preference around mu with width parameter w
        return np.exp(-0.5 * ((x - mu) / w) ** 2)

    # Individual contributions (each in [~0, 1])
    binder_term = gaussian_peak(binder_wt_pct, p["binder_opt"], w=1.2)
    plasticizer_term = gaussian_peak(plasticizer_wt_pct, p["plasticizer_opt"], w=0.6)
    dispersant_term = gaussian_peak(dispersant_wt_pct, p["dispersant_opt"], w=0.35)
    solids_term = gaussian_peak(solids_loading_pct, p["solids_opt"], w=3.5)
    cosolvent_term = gaussian_peak(cosolvent_fraction, p["cosolvent_opt"], w=0.15)
    mixing_term = gaussian_peak(mixing_time_min, p["mix_opt"], w=18.0)

    # Interactions: binder x solids, plasticizer x cosolvent, mixing x dispersant
    interaction = (
        0.35 * binder_term * solids_term
        + 0.20 * plasticizer_term * cosolvent_term
        + 0.15 * mixing_term * dispersant_term
    )

    # Aggregate score on [0, ~2], then scale to MPa
    score = (
        0.30 * binder_term
        + 0.20 * plasticizer_term
        + 0.15 * dispersant_term
        + 0.20 * solids_term
        + 0.05 * cosolvent_term
        + 0.10 * mixing_term
        + interaction
    )

    # Task-specific base and scale
    strength_mpa = p["base"] + p["scale"] * (10.0 * score)

    # Mild penalties for impractical regions to encode realism
    # Excessive plasticizer or dispersant softens green body
    penalty = 0.0
    if plasticizer_wt_pct > 3.5:
        penalty -= 0.5 * (plasticizer_wt_pct - 3.5)
    if dispersant_wt_pct > 1.2:
        penalty -= 0.8 * (dispersant_wt_pct - 1.2)
    # Too low solids loading weakens body
    if solids_loading_pct < 50.0:
        penalty -= 0.1 * (50.0 - solids_loading_pct)

    # Additive noise (unknown to model) to reflect experimental variability
    noise_sigma = 0.45 + 0.05 * (1.0 - solids_term)  # slightly higher if far from solids optimum
    noise = rng.normal(0.0, noise_sigma)

    return float(max(0.0, strength_mpa + penalty + noise))


# Use a GenerationStrategy with Sobol initialization followed by MTGP with UCB
gs = GenerationStrategy(
    steps=[
        GenerationStep(
            model=Models.SOBOL,
            num_trials=18,  # ~2 * number of tunable parameters is a reasonable rule of thumb
            min_trials_observed=12,
            max_parallelism=5,
            model_kwargs={"seed": 999, "transforms": Specified_Task_ST_MTGP_trans},
            model_gen_kwargs={"deduplicate": True},
        ),
        GenerationStep(
            model=Models.BOTORCH_MODULAR,
            num_trials=-1,  # Continue with BO for the rest of the budget
            max_parallelism=1,  # Batch size is 1 per problem statement
            model_kwargs={
                "botorch_acqf_class": UpperConfidenceBound,
                "transforms": Specified_Task_ST_MTGP_trans,
            },
        ),
    ]
)

ax_client = AxClient(generation_strategy=gs)

ax_client.create_experiment(
    name="ceramic_binder_multitask_green_strength",
    parameters=[
        {"name": "binder_wt_pct", "type": "range", "bounds": [1.0, 10.0]},
        {"name": "plasticizer_wt_pct", "type": "range", "bounds": [0.0, 5.0]},
        {"name": "dispersant_wt_pct", "type": "range", "bounds": [0.0, 2.0]},
        {"name": "solids_loading_pct", "type": "range", "bounds": [45.0, 65.0]},
        {"name": "cosolvent_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "mixing_time_min", "type": "range", "bounds": [10.0, 120.0]},
        {
            "name": "ceramic_matrix",
            "type": "choice",
            "values": ["alumina", "zirconia", "silicon_carbide"],
            "is_task": True,
            "target_value": "alumina",  # Primary task for acquisition; we still generate for all via fixed_features
        },
    ],
    objectives={
        objective_name: ObjectiveProperties(minimize=False),
    },
)

# Schedule: 40 experiments per task (total 120), interleaved to promote knowledge transfer
task_sequence = ["alumina", "zirconia", "silicon_carbide"]
total_trials = 120

for i in range(total_trials):
    current_task = task_sequence[i % len(task_sequence)]

    parameterization, trial_index = ax_client.get_next_trial(
        fixed_features=ObservationFeatures({"ceramic_matrix": current_task})
    )

    # Extract parameters
    binder_wt_pct = float(parameterization["binder_wt_pct"])
    plasticizer_wt_pct = float(parameterization["plasticizer_wt_pct"])
    dispersant_wt_pct = float(parameterization["dispersant_wt_pct"])
    solids_loading_pct = float(parameterization["solids_loading_pct"])
    cosolvent_fraction = float(parameterization["cosolvent_fraction"])
    mixing_time_min = float(parameterization["mixing_time_min"])
    ceramic_matrix = parameterization["ceramic_matrix"]

    # Evaluate green strength (MPa)
    green_strength_value = simulate_green_strength(
        binder_wt_pct=binder_wt_pct,
        plasticizer_wt_pct=plasticizer_wt_pct,
        dispersant_wt_pct=dispersant_wt_pct,
        solids_loading_pct=solids_loading_pct,
        cosolvent_fraction=cosolvent_fraction,
        mixing_time_min=mixing_time_min,
        ceramic_matrix=ceramic_matrix,
    )

    # Report a single noisy observation; Ax will infer the noise model
    ax_client.complete_trial(trial_index=trial_index, raw_data=green_strength_value)

# Retrieve and print best parameters overall (with respect to the target task setting)
best_parameters, metrics = ax_client.get_best_parameters()
print("Best parameters (overall):", best_parameters)
print("Best metrics (overall):", metrics)

# Plot results: best-so-far per task
df = ax_client.get_trials_data_frame()
metric_col = objective_name

unique_tasks = ["alumina", "zirconia", "silicon_carbide"]
fig, axes = plt.subplots(1, 3, figsize=(14, 4), dpi=150, sharey=True)

for ax, task in zip(axes, unique_tasks):
    dft = df[df["ceramic_matrix"] == task].copy()
    dft = dft.sort_values("trial_index")
    if len(dft) == 0:
        ax.set_title(f"Task {task} (no data)")
        continue
    ax.scatter(dft["trial_index"], dft[metric_col], ec="k", fc="none", label="Observed")
    ax.plot(
        dft["trial_index"],
        np.maximum.accumulate(dft[metric_col]),
        color="#0033FF",
        lw=2,
        label="Best to Trial",
    )
    ax.set_title(f"Task: {task}")
    ax.set_xlabel("Trial Index")
    ax.set_ylabel("Green Strength (MPa)")
    ax.legend()

plt.tight_layout()
plt.show()

# Print best observed per task
for task in unique_tasks:
    dft = df[df["ceramic_matrix"] == task]
    if len(dft) > 0:
        idx = dft[metric_col].idxmax()
        row = dft.loc[idx]
        print(
            f"Best for {task}: {row[metric_col]:.3f} MPa at trial {int(row['trial_index'])}"
        )