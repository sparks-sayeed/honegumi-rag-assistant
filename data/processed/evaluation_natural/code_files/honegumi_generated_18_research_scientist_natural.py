# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"
obj2_name = "branin_swapped"


def branin3_moo(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    # second objective has x1 and x2 swapped
    y2 = float(
        (x1 - 5.1 / (4 * np.pi**2) * x2**2 + 5.0 / np.pi * x2 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x2)
        + 10
    )

    # Contrived way to incorporate x3 into the second objective
    y2 = y2 * (1 - 0.1 * x1 * x2 * x3)

    return {obj1_name: y, obj2_name: y2}


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
        obj2_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
    ],
)


for i in range(21):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]
    x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

    results = branin3_moo(x1, x2, x3)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)
pareto_results = ax_client.get_pareto_optimal_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto[objectives[0]],
    pareto[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])

ax.legend()
plt.show()

# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from ax.service.ax_client import AxClient, ObjectiveProperties


# Metric names
MECH_PERF = "mechanical_performance"  # maximize
PROC_TIME = "processing_time"         # minimize

# Parameter names
A = "component_A_fraction"
B = "component_B_fraction"
C = "component_C_fraction"
D = "component_D_fraction"


rng = np.random.default_rng(42)


def evaluate_adhesive_formulation(parameterization: dict) -> dict:
    """
    Simulated evaluation for a 4-component adhesive formulation under a composition constraint.
    Returns noisy measurements (mean, SEM) for both objectives:
      - mechanical_performance (maximize)
      - processing_time (minimize)

    Components (fractions summing to 1):
      - component_A_fraction: base polymer
      - component_B_fraction: tackifier resin
      - component_C_fraction: crosslinker
      - component_D_fraction: solvent

    Domain-inspired model:
      - Mechanical performance increases with base polymer and crosslinker and has positive synergy (A*C).
        Too much solvent reduces strength; excessive tackifier beyond ~0.3 hurts performance.
      - Processing time increases with crosslinker (curing) and with viscosity (polymer + tackifier),
        and decreases with solvent.

    Noise model: Gaussian noise with fixed SEM for each metric.
    """
    fA = float(parameterization[A])
    fB = float(parameterization[B])
    fC = float(parameterization[C])
    fD = float(parameterization[D])

    # Safety: clip to [0, 1] and softly re-normalize if slightly off due to numerical tolerances
    fracs = np.array([fA, fB, fC, fD], dtype=float)
    fracs = np.clip(fracs, 0.0, 1.0)
    s = fracs.sum()
    if s > 0:
        fracs = fracs / s
    fA, fB, fC, fD = fracs.tolist()

    # Mechanical performance (arbitrary units, higher is better)
    strength_base = 40.0 * fA + 20.0 * fB + 60.0 * fC + 5.0 * fD
    synergy_ac = 80.0 * (fA * fC)
    penalty_solvent = 45.0 * (fD ** 2)
    penalty_tackifier_excess = 25.0 * max(0.0, fB - 0.30) ** 2
    strength = strength_base + synergy_ac - penalty_solvent - penalty_tackifier_excess
    strength = max(0.0, strength)

    # Processing time (minutes, lower is better)
    base_time = 6.0
    viscosity_term = 28.0 * (0.8 * fA + 1.0 * fB) ** 2
    curing_term = 32.0 * fC
    solvent_reduction = -14.0 * fD
    time_min = base_time + viscosity_term + curing_term + solvent_reduction
    time_min = max(0.2, time_min)

    # Add observation noise and return (mean, SEM)
    noise_sd_strength = 1.0
    noise_sd_time = 0.25
    observed_strength = float(strength + rng.normal(0.0, noise_sd_strength))
    observed_time = float(max(0.2, time_min + rng.normal(0.0, noise_sd_time)))

    return {
        MECH_PERF: (observed_strength, noise_sd_strength),
        PROC_TIME: (observed_time, noise_sd_time),
    }


def compute_pareto_mask(mech_vals: np.ndarray, time_vals: np.ndarray) -> np.ndarray:
    """
    Compute Pareto non-dominated mask for two objectives:
      - mechanical_performance (maximize)
      - processing_time (minimize)
    A point i is dominated if there exists j such that:
      mech[j] >= mech[i] and time[j] <= time[i] with at least one strict inequality.
    """
    n = len(mech_vals)
    dominated = np.zeros(n, dtype=bool)
    for i in range(n):
        if dominated[i]:
            continue
        for j in range(n):
            if i == j:
                continue
            if (mech_vals[j] >= mech_vals[i] and time_vals[j] <= time_vals[i]) and (
                mech_vals[j] > mech_vals[i] or time_vals[j] < time_vals[i]
            ):
                dominated[i] = True
                break
    return ~dominated


def main():
    ax_client = AxClient()

    ax_client.create_experiment(
        name="adhesive_formulation_multi_objective",
        parameters=[
            {"name": A, "type": "range", "bounds": [0.0, 1.0]},
            {"name": B, "type": "range", "bounds": [0.0, 1.0]},
            {"name": C, "type": "range", "bounds": [0.0, 1.0]},
            {"name": D, "type": "range", "bounds": [0.0, 1.0]},
        ],
        objectives={
            MECH_PERF: ObjectiveProperties(minimize=False),  # maximize
            PROC_TIME: ObjectiveProperties(minimize=True),   # minimize
        },
        # Enforce composition equality via two linear constraints (sum == 1):
        parameter_constraints=[
            f"{A} + {B} + {C} + {D} <= 1.0",
            f"-{A} - {B} - {C} - {D} <= -1.0",
        ],
    )

    # Run optimization
    total_trials = 40
    for _ in range(total_trials):
        parameterization, trial_index = ax_client.get_next_trial()
        results = evaluate_adhesive_formulation(parameterization)
        ax_client.complete_trial(trial_index=trial_index, raw_data=results)

    # Retrieve observed data
    df = ax_client.get_trials_data_frame()
    # Keep only rows with both metrics present
    df = df.dropna(subset=[MECH_PERF, PROC_TIME])

    # Compute Pareto frontier from observed data
    mech = df[MECH_PERF].to_numpy(dtype=float)
    proc = df[PROC_TIME].to_numpy(dtype=float)
    pareto_mask = compute_pareto_mask(mech, proc)
    pareto_df = df.loc[pareto_mask].copy()
    pareto_df = pareto_df.sort_values(by=[MECH_PERF, PROC_TIME], ascending=[True, True])

    # Plot results: mechanical_performance (x, maximize) vs processing_time (y, minimize)
    fig, ax = plt.subplots(figsize=(7, 5), dpi=150)
    ax.scatter(df[MECH_PERF], df[PROC_TIME], fc="None", ec="k", label="Observed")
    if len(pareto_df) > 1:
        ax.plot(
            pareto_df[MECH_PERF],
            pareto_df[PROC_TIME],
            color="#0033FF",
            lw=2,
            label="Pareto Front (observed)",
        )
    elif len(pareto_df) == 1:
        ax.scatter(
            pareto_df[MECH_PERF],
            pareto_df[PROC_TIME],
            color="#0033FF",
            s=60,
            label="Pareto Point (observed)",
        )

    ax.set_xlabel("Mechanical performance (a.u., higher is better)")
    ax.set_ylabel("Processing time (minutes, lower is better)")
    ax.set_title("Adhesive formulation: Pareto trade-off")
    ax.legend()
    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    main()