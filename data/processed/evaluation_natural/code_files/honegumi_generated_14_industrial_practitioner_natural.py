# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from typing import Dict, Tuple
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# -----------------------------
# Domain-specific configuration
# -----------------------------
# We mix three liquids (red, yellow, blue) whose fractions must sum to 1.0 to match a target spectrum.
# The spectral sensor has 8 channels (e.g., across wavelengths).
NUM_CHANNELS = 8
TOTAL_FRACTION = 1.0  # red_fraction + yellow_fraction + blue_fraction == 1.0

# Define wavelength channels (for documentation; not used directly in computation)
CHANNEL_WAVELENGTHS_NM = np.array([450, 500, 550, 600, 650, 700, 750, 800])

# Component spectra for each liquid across 8 channels (values in [0, 1], illustrative but realistic)
RED_SPECTRUM = np.array([0.05, 0.07, 0.10, 0.20, 0.60, 0.80, 0.85, 0.80])
YELLOW_SPECTRUM = np.array([0.10, 0.20, 0.60, 0.80, 0.70, 0.50, 0.30, 0.20])
BLUE_SPECTRUM = np.array([0.80, 0.70, 0.40, 0.20, 0.10, 0.05, 0.05, 0.05])

# Define a target mixture to match (can be replaced with measured target spectrum)
TARGET_RED_FRACTION = 0.50
TARGET_YELLOW_FRACTION = 0.40
TARGET_BLUE_FRACTION = 0.10
TARGET_SPECTRUM = (
    TARGET_RED_FRACTION * RED_SPECTRUM
    + TARGET_YELLOW_FRACTION * YELLOW_SPECTRUM
    + TARGET_BLUE_FRACTION * BLUE_SPECTRUM
)

# Sensor noise model (Gaussian) and batch volume assumptions
SENSOR_NOISE_STD_PER_CHANNEL = 0.01  # reflectance units
BATCH_VOLUME_ML = 100.0  # assumed batch volume used per trial
RMSE_REFERENCE_FOR_WASTE = 0.20  # scale for mapping error to expected waste

# Random number generator for reproducibility
rng = np.random.default_rng(seed=2025)

# Objective metric names
SPECTRAL_ERROR_METRIC = "spectral_match_error"  # RMSE across 8 spectral channels (minimize)
MATERIAL_WASTE_METRIC = "material_waste"        # mL (minimize)


def evaluate_color_mix(red_fraction: float, yellow_fraction: float, blue_fraction: float) -> Dict[str, Tuple[float, float]]:
    """Evaluate the color mixture against the target using an 8-channel spectral sensor model.

    Returns a dict mapping metric name to (mean, sem), where:
      - spectral_match_error: RMSE between measured spectrum and target across 8 channels
      - material_waste: estimated waste volume in mL for the batch (monotonic with error)

    Note: This function simulates a physical measurement by adding sensor noise. Replace the
    simulated parts with actual sensor readings in production.
    """
    # Compute ideal mixture spectrum (linear mixing as fractions sum to 1)
    ideal_spectrum = (
        red_fraction * RED_SPECTRUM
        + yellow_fraction * YELLOW_SPECTRUM
        + blue_fraction * BLUE_SPECTRUM
    )

    # Simulate a noisy measurement from the spectral sensor
    noise = rng.normal(loc=0.0, scale=SENSOR_NOISE_STD_PER_CHANNEL, size=NUM_CHANNELS)
    measured_spectrum = np.clip(ideal_spectrum + noise, 0.0, 1.0)

    # Compute RMSE to target
    diff = measured_spectrum - TARGET_SPECTRUM
    rmse = float(np.sqrt(np.mean(diff**2)))

    # Approximate SEM for RMSE from sensor noise (assumes independent channels)
    rmse_sem = float(SENSOR_NOISE_STD_PER_CHANNEL / np.sqrt(NUM_CHANNELS))

    # Map spectral error to expected material waste for this batch
    waste_mL = float(BATCH_VOLUME_ML * min(1.0, rmse / RMSE_REFERENCE_FOR_WASTE))
    waste_sem = float((BATCH_VOLUME_ML / RMSE_REFERENCE_FOR_WASTE) * rmse_sem)
    waste_sem = float(min(waste_sem, BATCH_VOLUME_ML))  # cap SEM at batch volume

    return {
        SPECTRAL_ERROR_METRIC: (rmse, rmse_sem),
        MATERIAL_WASTE_METRIC: (waste_mL, waste_sem),
    }


# -----------------------------
# Ax setup and optimization run
# -----------------------------
ax_client = AxClient(random_seed=12345)

ax_client.create_experiment(
    name="color_matching_3pigments_moo",
    parameters=[
        {"name": "red_fraction", "type": "range", "bounds": [0.0, TOTAL_FRACTION]},
        {"name": "yellow_fraction", "type": "range", "bounds": [0.0, TOTAL_FRACTION]},
    ],
    objectives={
        SPECTRAL_ERROR_METRIC: ObjectiveProperties(minimize=True),
        MATERIAL_WASTE_METRIC: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"red_fraction + yellow_fraction <= {TOTAL_FRACTION}",  # enforce blue >= 0
    ],
)

# Run sequential trials within the 30-trial budget
N_TRIALS = 30
for _ in range(N_TRIALS):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract free parameters and compute the dependent blue fraction
    red_fraction = float(parameterization["red_fraction"])
    yellow_fraction = float(parameterization["yellow_fraction"])
    blue_fraction = float(max(0.0, TOTAL_FRACTION - (red_fraction + yellow_fraction)))  # enforce composition constraint

    # Evaluate and report results
    results = evaluate_color_mix(red_fraction, yellow_fraction, blue_fraction)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve Pareto-optimal parameterizations
pareto_parameters = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

# -----------------------------
# Visualization of outcomes
# -----------------------------
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(7, 5), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto_df = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed trials")
ax.plot(
    pareto_df[objectives[0]],
    pareto_df[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Empirical Pareto front",
)
ax.set_xlabel(f"{objectives[0]} (RMSE)")
ax.set_ylabel(f"{objectives[1]} (mL)")
ax.set_title("Color Matching: Spectral Error vs. Material Waste")
ax.legend()
plt.tight_layout()
plt.show()