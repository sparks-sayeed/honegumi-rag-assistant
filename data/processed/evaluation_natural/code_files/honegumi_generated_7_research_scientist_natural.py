# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain-specific objective names
MECH_STRENGTH = "mechanical_strength"          # MPa (higher is better)
CORR_PERF = "corrosion_performance"            # corrosion resistance index (higher is better)


def evaluate_fe_cr_ni_mo_alloy(chromium_fraction: float, nickel_fraction: float, molybdenum_fraction: float) -> dict:
    """
    Simulated evaluation of an Fe-Cr-Ni-Mo alloy.

    Inputs are atomic/weight fractions of alloying additions (Fe is balance):
      - chromium_fraction (Cr)
      - nickel_fraction (Ni)
      - molybdenum_fraction (Mo)
      with linear constraint Cr + Ni + Mo <= 1.0.

    Returns:
      A dict mapping objective name -> (mean, sem)
      - mechanical_strength: approximate room-temperature strength in MPa
      - corrosion_performance: a corrosion resistance index inspired by PREN-like scaling

    Notes:
    - This is a physics-inspired surrogate with noise to mimic measurement uncertainty.
    - Replace this with actual experiment/simulation integration as needed.
    """
    cr = float(chromium_fraction)
    ni = float(nickel_fraction)
    mo = float(molybdenum_fraction)
    fe = max(0.0, 1.0 - (cr + ni + mo))  # Fe balance; safeguard against tiny numerical drift

    rng = np.random.default_rng()

    # Mechanical strength model (MPa), loosely inspired by solid solution strengthening trends.
    # Base Fe strength plus contributions and curvature/penalty terms to induce trade-offs.
    base_strength = 250.0
    strength = (
        base_strength
        + 600.0 * cr
        + 1200.0 * mo
        + 300.0 * ni
        + 800.0 * cr * mo
        - 300.0 * (ni - 0.20) ** 2
        - 200.0 * (cr - 0.18) ** 2
        - 400.0 * (mo - 0.08) ** 2
    )
    # Additive noise to mimic experiment uncertainty
    strength_noise = rng.normal(0.0, 8.0)  # ~8 MPa SEM scale
    strength = float(max(0.0, strength + strength_noise))

    # Corrosion performance index (higher is better).
    # PREN-inspired scaling: Cr and Mo dominate; Ni modestly beneficial; high Fe reduces resistance.
    corrosion_index = (
        100.0 * (cr + 3.3 * mo + 0.2 * ni)
        - 20.0 * fe
        + 15.0 * cr * mo
        - 5.0 * ni ** 2
    )
    corrosion_noise = rng.normal(0.0, 1.5)
    corrosion_index = float(max(0.0, corrosion_index + corrosion_noise))

    # Return mean and SEM for each objective
    return {
        MECH_STRENGTH: (strength, 8.0),
        CORR_PERF: (corrosion_index, 1.5),
    }


ax_client = AxClient()

# Create experiment with multi-objective optimization (maximize both objectives)
ax_client.create_experiment(
    name="fe_cr_ni_mo_multiobjective",
    parameters=[
        {"name": "chromium_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "nickel_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "molybdenum_fraction", "type": "range", "bounds": [0.0, 1.0]},
    ],
    objectives={
        MECH_STRENGTH: ObjectiveProperties(minimize=False),
        CORR_PERF: ObjectiveProperties(minimize=False),
    },
    # Linear constraint: Fe is balance, so Cr + Ni + Mo <= 1.0
    parameter_constraints=[
        "1.0*chromium_fraction + 1.0*nickel_fraction + 1.0*molybdenum_fraction <= 1.0",
    ],
)

# Run Bayesian optimization loop
num_trials = 50
for i in range(num_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    cr = parameterization["chromium_fraction"]
    ni = parameterization["nickel_fraction"]
    mo = parameterization["molybdenum_fraction"]

    results = evaluate_fe_cr_ni_mo_alloy(cr, ni, mo)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve Pareto-optimal observed points
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

# Build DataFrame of all observed results
df = ax_client.get_trials_data_frame()

# Extract Pareto frontier metrics for plotting
pareto_points = []
for _, (_, values) in pareto.items():
    ms = values.get(MECH_STRENGTH)
    cp = values.get(CORR_PERF)
    # values may be mean or (mean, sem); normalize to mean
    if isinstance(ms, (tuple, list)):
        ms = ms[0]
    if isinstance(cp, (tuple, list)):
        cp = cp[0]
    pareto_points.append({MECH_STRENGTH: ms, CORR_PERF: cp})
pareto_df = pd.DataFrame(pareto_points)
if not pareto_df.empty:
    pareto_df = pareto_df.sort_values(MECH_STRENGTH)

# Plot observed points and empirical Pareto front
fig, ax = plt.subplots(figsize=(6, 4), dpi=150)

# If df is wide with metric columns (as in AxClient.get_trials_data_frame), plot directly
if MECH_STRENGTH in df.columns and CORR_PERF in df.columns:
    ax.scatter(
        df[MECH_STRENGTH],
        df[CORR_PERF],
        fc="None",
        ec="k",
        label="Observed",
    )
else:
    # Fallback: pivot if needed
    if {"arm_name", "metric_name", "mean"}.issubset(df.columns):
        wide = df.pivot_table(index="arm_name", columns="metric_name", values="mean")
        if MECH_STRENGTH in wide.columns and CORR_PERF in wide.columns:
            ax.scatter(
                wide[MECH_STRENGTH],
                wide[CORR_PERF],
                fc="None",
                ec="k",
                label="Observed",
            )

# Plot Pareto front as a line (sorted by mechanical strength)
if not pareto_df.empty:
    ax.plot(
        pareto_df[MECH_STRENGTH],
        pareto_df[CORR_PERF],
        color="#0033FF",
        lw=2,
        label="Pareto Front",
    )

ax.set_xlabel("Mechanical strength (MPa)")
ax.set_ylabel("Corrosion performance (index)")
ax.legend()
plt.tight_layout()
plt.show()