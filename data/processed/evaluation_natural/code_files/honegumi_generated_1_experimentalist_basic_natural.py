# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Problem: Optimize sintering temperature (°C) and time (hours) to maximize ceramic relative density (%).
metric_name = "relative_density_percent"


def evaluate_sintering_density(sintering_temperature_c: float, sintering_time_h: float, rng: np.random.Generator) -> float:
    """
    Simulated evaluation of relative density (%) after sintering.

    Replace this model with real experimental measurement:
      - Heat sample at `sintering_temperature_c` (°C) for `sintering_time_h` (hours).
      - Measure bulk density and divide by theoretical density to obtain relative density (%).

    This surrogate captures common behavior:
      - Density increases with temperature up to an optimum, then may drop (over-sintering, abnormal grain growth).
      - Density increases with time and saturates; very long times can slightly degrade density.
      - Includes small Gaussian measurement noise to reflect experimental variability.
    """
    T = sintering_temperature_c
    t = sintering_time_h

    # Temperature effect: peak around an optimal temperature (e.g., alumina near 1450°C)
    temp_opt = 1450.0
    temp_sigma = 90.0
    temp_peak = np.exp(-0.5 * ((T - temp_opt) / temp_sigma) ** 2)  # [0, 1]

    # Time effect: logistic approach to saturation
    t50 = 2.2  # hours to reach 50% of time-driven densification
    k_time = 1.2
    time_progress = 1.0 / (1.0 + np.exp(-k_time * (t - t50)))  # [0, 1]

    # Over-sintering penalties (at very high T and very long time)
    over_temp_penalty = np.clip((T - (temp_opt + 100.0)) / 160.0, 0.0, 1.0)  # grows when T >> opt
    over_time_penalty = np.clip((t - 6.0) / 3.0, 0.0, 1.0)  # grows when time >> 6h

    # Base relative density model
    base_min = 55.0  # % minimum expected density in poor conditions
    base_gain = 45.0  # % possible improvement
    density = base_min + base_gain * (temp_peak * time_progress)

    # Apply penalties (coupled to progress so penalties matter when densification is advanced)
    density -= 10.0 * over_temp_penalty * time_progress
    density -= 6.0 * over_time_penalty * temp_peak

    # Add small measurement/process noise
    noise = rng.normal(loc=0.0, scale=0.5)  # ~0.5% absolute noise
    density_noisy = density + noise

    # Physical clipping
    density_noisy = float(np.clip(density_noisy, 50.0, 100.0))
    return density_noisy


def main() -> None:
    rng = np.random.default_rng(42)

    ax_client = AxClient()

    # Define search space for sintering
    ax_client.create_experiment(
        parameters=[
            {
                "name": "sintering_temperature_c",
                "type": "range",
                "bounds": [1100.0, 1600.0],
            },
            {
                "name": "sintering_time_h",
                "type": "range",
                "bounds": [0.5, 8.0],
            },
        ],
        objectives={metric_name: ObjectiveProperties(minimize=False)},
    )

    # Run optimization for 30 trials (budget)
    n_trials = 30
    for _ in range(n_trials):
        parameterization, trial_index = ax_client.get_next_trial()

        # Extract parameters
        sintering_temperature_c = float(parameterization["sintering_temperature_c"])
        sintering_time_h = float(parameterization["sintering_time_h"])

        # Evaluate experiment (replace with real measurement for your setup)
        result = evaluate_sintering_density(sintering_temperature_c, sintering_time_h, rng)

        # Report back the measured objective
        ax_client.complete_trial(trial_index=trial_index, raw_data=result)

    # Best found settings
    best_parameters, best_metrics = ax_client.get_best_parameters()
    print("Best sintering settings found:")
    print(best_parameters)
    print("Best observed relative density metric:")
    print(best_metrics)

    # Plot results
    df = ax_client.get_trials_data_frame()
    df = df.reset_index(drop=True)
    if metric_name in df.columns:
        y = df[metric_name].astype(float).to_numpy()
        x = np.arange(len(y))
        best_so_far = np.maximum.accumulate(y)

        fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
        ax.scatter(x, y, ec="k", fc="none", label="Observed")
        ax.plot(x, best_so_far, color="#0033FF", lw=2, label="Best so far")
        ax.set_xlabel("Trial Number")
        ax.set_ylabel("Relative Density (%)")
        ax.set_title("Sintering Optimization: Maximize Relative Density")
        ax.legend()
        plt.tight_layout()
        plt.show()
    else:
        print("No results to plot.")


if __name__ == "__main__":
    main()