# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from typing import Dict, Tuple
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


objective_name = "edge_roughness_micrometers"


def evaluate_laser_cut(laser_power_watts: float, cutting_speed_mm_per_s: float) -> Tuple[float, float]:
    """Evaluate laser cut edge roughness in micrometers for given power and speed.

    This function simulates the physical process with a semi-empirical model and noise.
    Replace this stub with your real experimental measurement pipeline.

    Real-world usage (recommended):
      - Command the laser cutter to run a straight cut at (laser_power_watts, cutting_speed_mm_per_s).
      - Measure edge roughness Ra (micrometers) using a surface profilometer or high-res microscopy + image analysis.
      - Return (mean_roughness_um, standard_error_um) where standard_error_um reflects measurement uncertainty.

    Parameters
    ----------
    laser_power_watts : float
        Laser output power in watts.
    cutting_speed_mm_per_s : float
        Cutting head travel speed in mm/s.

    Returns
    -------
    (roughness_um, sem_um) : (float, float)
        Estimated edge roughness in micrometers and its standard error (noise model).
    """
    # Semi-empirical surrogate model:
    # - Edge quality is primarily governed by line energy (J/mm) = W / (mm/s).
    # - There is an optimal line energy and an optimal speed; deviating from either increases roughness.
    # - Additive Gaussian noise mimics process variation and measurement noise.

    # Compute line energy (J/mm)
    line_energy = laser_power_watts / np.maximum(cutting_speed_mm_per_s, 1e-6)

    # Tunable "optima" for the surrogate model (these are generic; adjust to your material/machine)
    optimal_line_energy = 0.8  # J/mm (typical scale for thin sheet metals with fiber laser; adjust as needed)
    optimal_speed = 1500.0     # mm/s
    line_energy_scale = 0.3    # spread around optimal line energy
    speed_scale = 800.0        # spread around optimal speed

    # Quadratic penalties around optima
    penalty_line_energy = ((line_energy - optimal_line_energy) / line_energy_scale) ** 2
    penalty_speed = ((cutting_speed_mm_per_s - optimal_speed) / speed_scale) ** 2

    # Base roughness floor and weights for penalties
    base_roughness = 3.0  # micrometers, a realistic lower bound for good cuts on thin sheet
    roughness_um_mean = base_roughness + 15.0 * penalty_line_energy + 8.0 * penalty_speed

    # Add process and measurement noise (heteroscedastic)
    process_std = 0.4 + 0.05 * roughness_um_mean
    noise = np.random.normal(0.0, process_std)
    roughness_observed_um = max(0.2, roughness_um_mean + noise)

    # Standard error estimate (SEM) for Ax noise model; adjust if you know your metrology precision
    sem_um = process_std

    return float(roughness_observed_um), float(sem_um)


def main() -> None:
    np.random.seed(0)

    # Configure Ax Bayesian optimization client
    ax_client = AxClient()

    # Create the experiment: optimize for minimal edge roughness
    ax_client.create_experiment(
        name="laser_cutting_edge_quality_optimization",
        parameters=[
            {
                "name": "laser_power_watts",
                "type": "range",
                "bounds": [500.0, 3000.0],  # Adjust to your machine (e.g., 500–3000 W fiber laser)
            },
            {
                "name": "cutting_speed_mm_per_s",
                "type": "range",
                "bounds": [200.0, 6000.0],  # Adjust to your mechanics/material
            },
        ],
        objectives={
            objective_name: ObjectiveProperties(minimize=True),
        },
        # By default Ax assumes noisy observations; we provide SEM with each measurement below.
    )

    total_trials = 30  # Budget

    for _ in range(total_trials):
        parameterization, trial_index = ax_client.get_next_trial()

        # Extract suggested settings
        power_w = float(parameterization["laser_power_watts"])
        speed_mm_s = float(parameterization["cutting_speed_mm_per_s"])

        # Evaluate experiment (replace with your real cut-and-measure routine)
        try:
            roughness_um, sem_um = evaluate_laser_cut(power_w, speed_mm_s)
            ax_client.complete_trial(
                trial_index=trial_index,
                raw_data={objective_name: (roughness_um, sem_um)},
            )
        except Exception as e:
            # Mark the trial as failed if evaluation could not be performed
            ax_client.log_trial_failure(trial_index=trial_index, metadata={"error": str(e)})
            continue

    # Retrieve best parameters and their metrics
    best_parameters, best_metrics = ax_client.get_best_parameters()
    best_roughness_mean = best_metrics[objective_name]["mean"]
    best_roughness_sem = best_metrics[objective_name].get("sem", None)

    print("Best settings found:")
    print(f"  laser_power_watts: {best_parameters['laser_power_watts']:.3f} W")
    print(f"  cutting_speed_mm_per_s: {best_parameters['cutting_speed_mm_per_s']:.3f} mm/s")
    if best_roughness_sem is not None:
        print(f"  {objective_name}: {best_roughness_mean:.3f} ± {best_roughness_sem:.3f} (SEM)")
    else:
        print(f"  {objective_name}: {best_roughness_mean:.3f}")

    # Plot optimization progress
    df = ax_client.get_trials_data_frame()
    if objective_name in df.columns:
        y_series = df[objective_name]
        x_series = df.index

        fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
        ax.scatter(x_series, y_series, ec="k", fc="none", label="Observed")
        ax.plot(x_series, np.minimum.accumulate(y_series.values), color="#0033FF", lw=2, label="Best to Trial")
        ax.set_xlabel("Trial Number")
        ax.set_ylabel(objective_name)
        ax.set_title("Laser Cutting Optimization: Edge Roughness vs. Trial")
        ax.legend()
        plt.tight_layout()
        plt.show()
    else:
        print("Warning: Could not find the objective column in the trials DataFrame for visualization.")


if __name__ == "__main__":
    main()