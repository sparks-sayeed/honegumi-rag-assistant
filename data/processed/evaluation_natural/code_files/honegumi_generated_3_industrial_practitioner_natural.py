# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from typing import Dict, Tuple

from ax.service.ax_client import AxClient, ObjectiveProperties


# Domain-specific metric names
STRENGTH_NAME = "tensile_strength_mpa"
BIODEG_NAME = "biodegradability_index"

# Random seed for reproducibility in synthetic evaluation
np.random.seed(123)


def evaluate_polymer(parameters: Dict[str, float]) -> Dict[str, Tuple[float, float]]:
    """
    Evaluate polymer formulation/process settings on:
      - tensile strength (MPa): maximize, aim >= 70 MPa
      - biodegradability index [0..1]: maximize

    Parameters expected in 'parameters':
      - monomer_1, monomer_2, monomer_3, monomer_4 (fractions in [0, 1])
      - extrusion_rate (mm/s) in [5, 50]  [adjust to your process]
      - temperature_celsius in [120, 200] [adjust to your process]

    Composition constraint is enforced via reparameterization:
      monomer_5 = 1.0 - (monomer_1 + monomer_2 + monomer_3 + monomer_4)
      This guarantees the 5 monomer fractions sum to 1.0 exactly.

    NOTE: Replace this synthetic model with actual lab measurements or a high-fidelity simulator.
    Return values are tuples of (mean, SEM).
    """
    m1 = float(parameters["monomer_1"])
    m2 = float(parameters["monomer_2"])
    m3 = float(parameters["monomer_3"])
    m4 = float(parameters["monomer_4"])
    rate = float(parameters["extrusion_rate"])  # mm/s
    temp = float(parameters["temperature_celsius"])  # Â°C

    # Compute the implied 5th monomer to satisfy the composition equality exactly
    m5 = 1.0 - (m1 + m2 + m3 + m4)
    # If numerical issues cause a tiny negative value, clamp to 0 and adjust proportions slightly
    if m5 < 0:
        # Penalize hard if violated (shouldn't happen with the <= constraint), then clamp
        m5 = 0.0

    # --- Synthetic physics-informed model (placeholder for real measurements) ---

    # Resin contributions to strength (MPa) for each monomer type
    # Tune these weights to reflect empirical knowledge of monomer effects on strength.
    strength_weights = {
        "m1": 120.0,  # high-strength monomer (e.g., aromatic unit)
        "m2": 80.0,   # moderately strong, more biodegradable
        "m3": 100.0,  # stiffening monomer
        "m4": 65.0,   # flexible monomer
        "m5": 90.0,   # balanced
    }
    S_resin = (
        strength_weights["m1"] * m1
        + strength_weights["m2"] * m2
        + strength_weights["m3"] * m3
        + strength_weights["m4"] * m4
        + strength_weights["m5"] * m5
    )

    # Process effects on strength: assume peaks at moderate rate and temperature
    # Adjust centers/widths to your extruder/material.
    rate_center, rate_width = 22.0, 15.0
    temp_center, temp_width = 170.0, 22.0
    rate_factor = np.exp(-((rate - rate_center) / rate_width) ** 2)
    temp_factor = np.exp(-((temp - temp_center) / temp_width) ** 2)

    # Interaction term: certain pairs improve strength (e.g., crystallinity modifiers)
    strength_interactions = 25.0 * (m1 * m3) + 10.0 * (m3 * m5) - 8.0 * (m4 * m2)

    # Combine to get final strength
    strength_mean = (S_resin * (0.90 + 0.30 * rate_factor * temp_factor)) + strength_interactions

    # Biodegradability base contributions [0..1]
    biodeg_weights = {
        "m1": 0.2,  # low biodegradability
        "m2": 0.9,  # high biodegradability
        "m3": 0.4,  # medium-low
        "m4": 0.8,  # high
        "m5": 0.7,  # medium-high
    }
    B_base = (
        biodeg_weights["m1"] * m1
        + biodeg_weights["m2"] * m2
        + biodeg_weights["m3"] * m3
        + biodeg_weights["m4"] * m4
        + biodeg_weights["m5"] * m5
    )

    # Process impact on biodegradability:
    # - Higher temperatures can reduce biodegradability via increased crystallinity.
    # - Very high shear (rate) may reduce molecular weight, slightly increasing biodegradability.
    rate_norm = (rate - 5.0) / (50.0 - 5.0)
    temp_penalty = 0.17 * ((temp - 165.0) / 40.0) ** 2  # penalty grows with deviation from 165C
    shear_boost = 0.05 * rate_norm  # small positive effect with rate
    synergy_boost = 0.15 * (m2 * m5 + m4 * m5)

    biodeg_mean = B_base * (1.0 - temp_penalty + shear_boost) + synergy_boost
    biodeg_mean = float(np.clip(biodeg_mean, 0.0, 1.0))

    # Add synthetic measurement noise, report SEM
    strength_noise = np.random.normal(0.0, 2.0)
    biodeg_noise = np.random.normal(0.0, 0.03)

    strength_observed = float(strength_mean + strength_noise)
    biodeg_observed = float(np.clip(biodeg_mean + biodeg_noise, 0.0, 1.0))

    strength_sem = 2.0
    biodeg_sem = 0.03

    return {
        STRENGTH_NAME: (strength_observed, strength_sem),
        BIODEG_NAME: (biodeg_observed, biodeg_sem),
    }


# Historical data (3 prior experiments). Fractions sum to 1.0 across five monomers.
historical_data = pd.DataFrame(
    [
        {
            "monomer_1": 0.35,
            "monomer_2": 0.10,
            "monomer_3": 0.25,
            "monomer_4": 0.10,
            "monomer_5": 0.20,
            "extrusion_rate": 20.0,
            "temperature_celsius": 170.0,
        },
        {
            "monomer_1": 0.15,
            "monomer_2": 0.30,
            "monomer_3": 0.20,
            "monomer_4": 0.15,
            "monomer_5": 0.20,
            "extrusion_rate": 30.0,
            "temperature_celsius": 160.0,
        },
        {
            "monomer_1": 0.25,
            "monomer_2": 0.20,
            "monomer_3": 0.30,
            "monomer_4": 0.05,
            "monomer_5": 0.20,
            "extrusion_rate": 15.0,
            "temperature_celsius": 180.0,
        },
    ]
)


# Initialize Ax client and define the experiment
ax_client = AxClient()

# We reparameterize the 5-component composition by optimizing 4 components and computing the 5th.
ax_client.create_experiment(
    name="polymer_moo_formulation_experiment",
    parameters=[
        {"name": "monomer_1", "type": "range", "bounds": [0.0, 1.0], "value_type": "float"},
        {"name": "monomer_2", "type": "range", "bounds": [0.0, 1.0], "value_type": "float"},
        {"name": "monomer_3", "type": "range", "bounds": [0.0, 1.0], "value_type": "float"},
        {"name": "monomer_4", "type": "range", "bounds": [0.0, 1.0], "value_type": "float"},
        # monomer_5 is computed as 1 - (m1 + m2 + m3 + m4); do not include it in the search space
        {"name": "extrusion_rate", "type": "range", "bounds": [5.0, 50.0], "value_type": "float"},  # mm/s
        {"name": "temperature_celsius", "type": "range", "bounds": [120.0, 200.0], "value_type": "float"},
    ],
    objectives={
        STRENGTH_NAME: ObjectiveProperties(minimize=False, threshold=70.0),  # target spec: >= 70 MPa
        BIODEG_NAME: ObjectiveProperties(minimize=False),  # threshold inferred
    },
    parameter_constraints=[
        # Composition constraint: monomer_1 + monomer_2 + monomer_3 + monomer_4 <= 1.0
        # with monomer_5 computed as the remainder to sum to 1.0.
        "monomer_1 + monomer_2 + monomer_3 + monomer_4 <= 1.0",
    ],
)

# Attach historical trials (convert to the reparameterized space by dropping monomer_5)
for i in range(len(historical_data)):
    row = historical_data.iloc[i].to_dict()
    paramization = {
        "monomer_1": row["monomer_1"],
        "monomer_2": row["monomer_2"],
        "monomer_3": row["monomer_3"],
        "monomer_4": row["monomer_4"],  # monomer_5 is implied
        "extrusion_rate": row["extrusion_rate"],
        "temperature_celsius": row["temperature_celsius"],
    }
    ax_client.attach_trial(paramization)
    # Evaluate with our function
    results = evaluate_polymer(paramization)
    ax_client.complete_trial(trial_index=i, raw_data=results)

# Run the optimization loop
N_TRIALS = 25
for _ in range(N_TRIALS):
    parameters, trial_index = ax_client.get_next_trial()
    results = evaluate_polymer(parameters)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve Pareto-optimal results (based on observed data)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

# Prepare data for plotting
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

# Extract observed points for the two objectives
# The service API data frame contains mean values under the metric columns.
x_vals = df[objectives[0]].values
y_vals = df[objectives[1]].values

# Extract Pareto frontier points
pareto_points = [vals[0] for _, vals in pareto.items()]  # list of dicts with means
pareto_df = pd.DataFrame(pareto_points)
pareto_df = pareto_df.sort_values(by=objectives[0])

# Plot
fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(x_vals, y_vals, fc="None", ec="k", label="Observed")
ax.plot(
    pareto_df[objectives[0]].values,
    pareto_df[objectives[1]].values,
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.axvline(70.0, color="r", linestyle="--", linewidth=1.2, label="Strength spec (70 MPa)")
ax.set_xlabel("Tensile strength (MPa)")
ax.set_ylabel("Biodegradability index")
ax.legend(loc="lower right")
plt.tight_layout()
plt.show()