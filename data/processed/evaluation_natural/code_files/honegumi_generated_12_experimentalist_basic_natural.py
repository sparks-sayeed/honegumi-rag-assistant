# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"
obj2_name = "branin_swapped"


def branin_moo(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # second objective has x1 and x2 swapped
    y2 = float(
        (x1 - 5.1 / (4 * np.pi**2) * x2**2 + 5.0 / np.pi * x2 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x2)
        + 10
    )

    return {obj1_name: y, obj2_name: y2}


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
        obj2_name: ObjectiveProperties(minimize=True),
    },
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin_moo(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)
pareto_results = ax_client.get_pareto_optimal_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto[objectives[0]],
    pareto[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])

ax.legend()
plt.show()

# Generated from Honegumi skeleton and adapted to ceramic binder formulation optimization
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from typing import Dict, Tuple

from ax.service.ax_client import AxClient, ObjectiveProperties


# Objective metric names: maximize green strength (MPa) for each ceramic system
OBJ_ALUMINA = "green_strength_alumina"
OBJ_ZIRCONIA = "green_strength_zirconia"
OBJ_SIC = "green_strength_silicon_carbide"

# Reproducible RNG for the synthetic evaluator; replace with real measurements in production
rng = np.random.default_rng(2025)


def evaluate_binder_formulation(parameterization: Dict[str, float]) -> Dict[str, Tuple[float, float]]:
    """
    Synthetic evaluation of green strength for three ceramic systems given a single binder formulation.
    Replace this stub with actual laboratory measurements or a validated simulation.

    Parameters expected in `parameterization`:
    - binder_solids_wt_pct: Binder solids as wt% of ceramic powder (1–10%)
    - polymer_fraction_in_binder: Fraction of binder solids that is polymer (0.60–0.95)
    - dispersant_wt_pct: Dispersant as wt% of ceramic powder (0.0–2.0%)
    - slurry_solids_loading_pct: Total solids loading (ceramic + binder solids) in slurry (%; 45–65%)
    - polymer_mw_kDa: Polymer molecular weight (kDa; 50–600)
    - crosslinker_wt_pct: Crosslinker as wt% of ceramic powder (0.0–2.0%)
    - curing_temperature_celsius: Curing temperature (°C; 25–120)
    - curing_time_minutes: Curing time (min; 10–120)
    - drying_rate_scale: Dimensionless drying rate factor (0.5=slow, 1.0=nominal, 2.0=fast)

    Returns:
    Dict mapping objective name to (mean_value_MPa, sem_MPa).
    """
    # Extract parameters
    binder_solids = float(parameterization["binder_solids_wt_pct"])
    polymer_frac = float(parameterization["polymer_fraction_in_binder"])
    dispersant = float(parameterization["dispersant_wt_pct"])
    solids_loading = float(parameterization["slurry_solids_loading_pct"])
    mw_kDa = float(parameterization["polymer_mw_kDa"])
    crosslinker = float(parameterization["crosslinker_wt_pct"])
    temp_c = float(parameterization["curing_temperature_celsius"])
    time_min = float(parameterization["curing_time_minutes"])
    drying_rate = float(parameterization["drying_rate_scale"])

    # Helper: bounded quadratic "preference" around an optimum
    def concave_pref(x, x_opt, width):
        return 1.0 - ((x - x_opt) / width) ** 2

    # Preference terms (clipped to [0, 1.2] to avoid runaway)
    p_binder = np.clip(concave_pref(binder_solids, 5.0, 3.0), -0.5, 1.2)
    p_polymer_frac = np.clip(concave_pref(polymer_frac, 0.80, 0.10), -0.5, 1.2)
    p_dispersant = np.clip(concave_pref(dispersant, 0.40, 0.30), -0.8, 1.2)
    p_solids = np.clip(concave_pref(solids_loading, 58.0, 7.0), -0.8, 1.2)
    # Saturating effect of molecular weight
    p_mw = 1.2 * (1.0 - np.exp(-(mw_kDa / 200.0)))
    p_mw = np.clip(p_mw, 0.0, 1.2)
    p_cross = np.clip(concave_pref(crosslinker, 0.8, 0.6), -0.8, 1.2)
    # Curing synergy: both temperature and time need to be near optimum
    p_temp = np.exp(-((temp_c - 80.0) / 20.0) ** 2)
    p_time = np.exp(-((time_min - 60.0) / 25.0) ** 2)
    p_curing = p_temp * p_time
    # Drying: too fast creates defects; modestly slow is better
    p_drying = np.clip(concave_pref(drying_rate, 0.85, 0.45), -1.0, 1.2)

    # Base score (unitless) aggregating terms; tuned weights to produce realistic MPa scale after scaling
    base_score = (
        15.0 * p_binder
        + 10.0 * p_polymer_frac
        + 6.0 * p_dispersant
        + 12.0 * p_solids
        + 8.0 * p_mw
        + 7.0 * p_cross
        + 10.0 * p_curing
        + 5.0 * p_drying
        + 5.0 * p_cross * p_curing  # crosslinker-curing synergy
    )

    # Ceramic-specific adjustments capturing typical behavior differences
    # Alumina: baseline behavior
    alumina_factor = 1.00
    alumina_adj = 0.5 * max(0.0, p_solids) + 0.3 * max(0.0, p_polymer_frac)

    # Zirconia: benefits from adequate dispersant and higher solids; penalized if solids too low
    zirconia_factor = 1.05
    zirconia_adj = (
        1.2 * max(0.0, dispersant - 0.35)  # bonus for sufficient dispersant
        + 0.8 * max(0.0, (solids_loading - 55.0) / 10.0)  # higher solids help
        - 1.0 * max(0.0, 55.0 - solids_loading) / 10.0  # penalty if too low solids
    )

    # SiC: hydrophobic, needs higher MW and crosslinker; penalized by fast drying and very high solids
    sic_factor = 0.95
    sic_adj = (
        1.0 * max(0.0, (mw_kDa - 200.0) / 200.0)
        + 0.8 * max(0.0, crosslinker - 0.6)
        - 1.2 * max(0.0, drying_rate - 1.1)  # fast drying hurts
        - 0.8 * max(0.0, solids_loading - 62.0) / 5.0  # too high solids can cause defects
    )

    # Convert to MPa scale
    scale_to_mpa = 0.40
    mu_alumina = scale_to_mpa * base_score * alumina_factor + alumina_adj
    mu_zirconia = scale_to_mpa * base_score * zirconia_factor + zirconia_adj
    mu_sic = scale_to_mpa * base_score * sic_factor + sic_adj

    # Ensure non-negative strengths
    mu_alumina = float(max(0.0, mu_alumina))
    mu_zirconia = float(max(0.0, mu_zirconia))
    mu_sic = float(max(0.0, mu_sic))

    # Add measurement noise and return SEM; heteroscedasticity can be modeled if known
    noise_sd_al = 0.8
    noise_sd_zi = 0.9
    noise_sd_sic = 1.0

    obs_al = mu_alumina + rng.normal(0.0, noise_sd_al)
    obs_zi = mu_zirconia + rng.normal(0.0, noise_sd_zi)
    obs_sic = mu_sic + rng.normal(0.0, noise_sd_sic)

    return {
        OBJ_ALUMINA: (obs_al, noise_sd_al),
        OBJ_ZIRCONIA: (obs_zi, noise_sd_zi),
        OBJ_SIC: (obs_sic, noise_sd_sic),
    }


# Create Ax client and experiment
ax_client = AxClient()
ax_client.create_experiment(
    name="ceramic_binder_green_strength",
    parameters=[
        {
            "name": "binder_solids_wt_pct",
            "type": "range",
            "bounds": [1.0, 10.0],
            "value_type": "float",
        },
        {
            "name": "polymer_fraction_in_binder",
            "type": "range",
            "bounds": [0.60, 0.95],
            "value_type": "float",
        },
        {
            "name": "dispersant_wt_pct",
            "type": "range",
            "bounds": [0.0, 2.0],
            "value_type": "float",
        },
        {
            "name": "slurry_solids_loading_pct",
            "type": "range",
            "bounds": [45.0, 65.0],
            "value_type": "float",
        },
        {
            "name": "polymer_mw_kDa",
            "type": "range",
            "bounds": [50.0, 600.0],
            "value_type": "float",
            "log_scale": True,
        },
        {
            "name": "crosslinker_wt_pct",
            "type": "range",
            "bounds": [0.0, 2.0],
            "value_type": "float",
        },
        {
            "name": "curing_temperature_celsius",
            "type": "range",
            "bounds": [25.0, 120.0],
            "value_type": "float",
        },
        {
            "name": "curing_time_minutes",
            "type": "range",
            "bounds": [10.0, 120.0],
            "value_type": "float",
        },
        {
            "name": "drying_rate_scale",
            "type": "range",
            "bounds": [0.5, 2.0],
            "value_type": "float",
        },
    ],
    objectives={
        OBJ_ALUMINA: ObjectiveProperties(minimize=False),  # Maximize green strength (MPa)
        OBJ_ZIRCONIA: ObjectiveProperties(minimize=False),
        OBJ_SIC: ObjectiveProperties(minimize=False),
    },
)

# Optimization loop: budget of 120 trials (approx. 40 per ceramic type equivalent)
N_TRIALS = 120
for i in range(N_TRIALS):
    parameters, trial_index = ax_client.get_next_trial()
    results = evaluate_binder_formulation(parameters)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Fetch observed data into a DataFrame
df = ax_client.get_trials_data_frame()

# Ensure metric columns exist; pivot if necessary
objective_names = [OBJ_ALUMINA, OBJ_ZIRCONIA, OBJ_SIC]
if not all(obj in df.columns for obj in objective_names):
    if {"metric_name", "mean"}.issubset(df.columns):
        # Pivot long to wide: one column per metric's mean
        pivot = df.pivot_table(
            index=["trial_index", "arm_name"], columns="metric_name", values="mean"
        ).reset_index()
        # Keep unique parameter columns if present
        param_cols = [c for c in df.columns if c.startswith("parameters.")]
        if param_cols:
            df_params = df[["trial_index", "arm_name"] + param_cols].drop_duplicates()
            df = pd.merge(df_params, pivot, on=["trial_index", "arm_name"], how="right")
        else:
            df = pivot
    else:
        raise RuntimeError("Unexpected trials data frame format; cannot locate metric columns.")

# Compute Pareto-nondominated mask for 3 objectives (maximize all)
def pareto_nondominated_mask(points: np.ndarray) -> np.ndarray:
    n = points.shape[0]
    mask = np.ones(n, dtype=bool)
    for i in range(n):
        if not mask[i]:
            continue
        dominates_i = (points >= points[i]).all(axis=1) & (points > points[i]).any(axis=1)
        mask[dominates_i] = False
    return mask


valid_rows = df.dropna(subset=objective_names).copy()
outcomes = valid_rows[objective_names].to_numpy(dtype=float)
nd_mask = pareto_nondominated_mask(outcomes)
pareto_df = valid_rows.loc[nd_mask].copy()

# Print a concise summary of Pareto-optimal green strength triplets
print("Number of Pareto-optimal binder formulations found:", len(pareto_df))
print(pareto_df[["arm_name"] + objective_names].sort_values(OBJ_ALUMINA, ascending=False).head(10))

# Pairwise scatter plots of objectives with Pareto set highlighted
pairs = [
    (OBJ_ALUMINA, OBJ_ZIRCONIA),
    (OBJ_ALUMINA, OBJ_SIC),
    (OBJ_ZIRCONIA, OBJ_SIC),
]
fig, axes = plt.subplots(1, 3, figsize=(15, 4), dpi=140)
for ax, (x_obj, y_obj) in zip(axes, pairs):
    ax.scatter(valid_rows[x_obj], valid_rows[y_obj], s=25, fc="None", ec="gray", label="Observed")
    ax.scatter(pareto_df[x_obj], pareto_df[y_obj], s=30, c="#0033FF", label="Pareto-optimal")
    ax.set_xlabel(f"{x_obj} (MPa)")
    ax.set_ylabel(f"{y_obj} (MPa)")
    ax.grid(alpha=0.2)
    ax.legend(loc="best", fontsize=8)
    ax.set_title(f"{x_obj} vs {y_obj}")
fig.tight_layout()
plt.show()