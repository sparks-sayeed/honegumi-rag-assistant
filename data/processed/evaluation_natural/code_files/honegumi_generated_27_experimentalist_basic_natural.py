# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Problem: Formulate an optical glass from 3 oxides (fractions sum to 1.0).
# Objectives:
#   - Maximize refractive_index (n_d ~ 589 nm)
#   - Minimize dispersion (use a proxy similar to inverse Abbe number; lower is better)
#
# This script uses Ax (Bayesian optimization) to propose compositions. The evaluation
# function simulates realistic trends using a Lorentz-Lorenz mixing model for refractive index
# and a convex mixture + interaction terms for dispersion. Gaussian measurement noise is added
# to emulate experimental uncertainty.
#
# Replace the evaluate_glass_formulation stub with real measurement code if available.


# Metric names
REFRACTIVE_INDEX_NAME = "refractive_index"  # maximize
DISPERSION_NAME = "dispersion"              # minimize (proxy for inverse Abbe number; lower is less dispersive)

# Total for compositional constraint (sum of oxide fractions equals 1.0)
TOTAL_FRACTION = 1.0

# Random seed for reproducibility of the simulated evaluation
RNG = np.random.default_rng(seed=12345)


def evaluate_glass_formulation(
    oxide_1_fraction: float,
    oxide_2_fraction: float,
    oxide_3_fraction: float,
    noise_enabled: bool = True,
) -> dict:
    """
    Simulate refractive index and dispersion for a ternary oxide glass.

    Notes:
    - Refractive index is computed via a Lorentz-Lorenz-style mixing rule with mild interaction terms.
    - Dispersion is modeled as a convex mixture of component "inverse Abbe" proxies with interactions.
    - Both metrics include small Gaussian noise to mimic measurement uncertainty.

    Oxide components (hypothetical, unnamed):
      - oxide_1: "high-index, high-dispersion" contributor (e.g., TiO2-like behavior)
      - oxide_2: "low-index, low-dispersion" contributor (e.g., SiO2-like behavior)
      - oxide_3: "mid-to-high index, moderate dispersion" contributor (e.g., La2O3-like behavior)

    Returns:
      {
        "refractive_index": float,  # higher is better
        "dispersion": float,        # lower is better
      }
    """

    # Sanity check: fractions sum to 1 within numerical tolerance
    f1, f2, f3 = float(oxide_1_fraction), float(oxide_2_fraction), float(oxide_3_fraction)
    s = f1 + f2 + f3
    if not np.isfinite(s) or abs(s - 1.0) > 1e-6:
        raise ValueError(f"Fractions must sum to 1.0; got {s} from {f1}, {f2}, {f3}")

    # Hypothetical component optical properties (d-line ~589 nm)
    # Component refractive indices (illustrative values)
    n_components = np.array([2.40, 1.46, 1.90])  # oxide_1, oxide_2, oxide_3

    # Component Abbe numbers (higher => lower dispersion); use inverse as dispersion proxy
    Vd_components = np.array([20.0, 67.0, 50.0])
    inverse_abbe_components = 1.0 / Vd_components  # larger => more dispersion

    fractions = np.array([f1, f2, f3])

    # Refractive index via Lorentz-Lorenz mixing
    # R = (n^2 - 1)/(n^2 + 2)
    R_components = (n_components**2 - 1.0) / (n_components**2 + 2.0)
    R_mix = np.dot(fractions, R_components)

    # Add mild pairwise interaction terms in R-space to capture non-ideal mixing
    # Positive interactions involving oxide_1 generally boost refractive index.
    k12, k13, k23 = 0.015, 0.025, 0.010  # small to keep R_mix < 1
    R_mix += k12 * f1 * f2 + k13 * f1 * f3 + k23 * f2 * f3

    # Invert Lorentz-Lorenz to get refractive index
    # n = sqrt((1 + 2R)/(1 - R))
    # Ensure numerical stability
    R_mix = np.clip(R_mix, 1e-6, 0.95)
    n_true = float(np.sqrt((1.0 + 2.0 * R_mix) / (1.0 - R_mix)))

    # Dispersion proxy (lower is better). Start with convex mixture of inverse Abbe numbers.
    dispersion_true = float(np.dot(fractions, inverse_abbe_components))

    # Add interactions: oxide_1 with others increases dispersion; oxide_2 with oxide_3 slightly reduces it
    d12, d13, d23 = 0.004, 0.006, -0.0015
    dispersion_true += d12 * f1 * f2 + d13 * f1 * f3 + d23 * f2 * f3
    dispersion_true = max(1e-4, dispersion_true)  # keep positive

    # Add measurement noise
    n_noise_sd = 0.002 if noise_enabled else 0.0
    d_noise_sd = 0.0005 if noise_enabled else 0.0
    n_obs = float(n_true + RNG.normal(0.0, n_noise_sd))
    d_obs = float(max(1e-5, dispersion_true + RNG.normal(0.0, d_noise_sd)))

    # Provide SEM estimates (can be tuned to your lab's repeatability)
    # Ax accepts either raw values or (value, SEM) tuples per metric.
    results = {
        REFRACTIVE_INDEX_NAME: (n_obs, n_noise_sd),
        DISPERSION_NAME: (d_obs, d_noise_sd),
    }
    return results


# Initialize Ax client
ax_client = AxClient()

# Create experiment with compositional (sum-to-one) constraint via reparameterization:
# Optimize over oxide_1_fraction and oxide_2_fraction; set oxide_3_fraction = 1 - (f1 + f2)
ax_client.create_experiment(
    name="optical_glass_ternary_moo",
    parameters=[
        {"name": "oxide_1_fraction", "type": "range", "bounds": [0.0, TOTAL_FRACTION]},
        {"name": "oxide_2_fraction", "type": "range", "bounds": [0.0, TOTAL_FRACTION]},
    ],
    objectives={
        REFRACTIVE_INDEX_NAME: ObjectiveProperties(minimize=False),
        DISPERSION_NAME: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"oxide_1_fraction + oxide_2_fraction <= {TOTAL_FRACTION}",
    ],
)

# Optimization budget
num_trials = 38

for i in range(num_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    f1 = float(parameterization["oxide_1_fraction"])
    f2 = float(parameterization["oxide_2_fraction"])
    f3 = TOTAL_FRACTION - (f1 + f2)

    # Numerical guard (should be non-negative due to constraint)
    f3 = max(0.0, f3)

    results = evaluate_glass_formulation(f1, f2, f3, noise_enabled=True)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve Pareto-optimal points from observed data
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

# Convert Pareto set to DataFrame for plotting
objectives = ax_client.objective_names
pareto_records = []
for params, (means, cov) in pareto.items():
    rec = {"oxide_1_fraction": params.get("oxide_1_fraction", np.nan),
           "oxide_2_fraction": params.get("oxide_2_fraction", np.nan)}
    # Recover oxide_3 from composition
    rec["oxide_3_fraction"] = TOTAL_FRACTION - (rec["oxide_1_fraction"] + rec["oxide_2_fraction"])
    # Metrics
    rec[REFRACTIVE_INDEX_NAME] = means.get(REFRACTIVE_INDEX_NAME, np.nan)
    rec[DISPERSION_NAME] = means.get(DISPERSION_NAME, np.nan)
    pareto_records.append(rec)
pareto_df = pd.DataFrame(pareto_records)
pareto_df = pareto_df.sort_values(REFRACTIVE_INDEX_NAME)

# All observed trials
trials_df = ax_client.get_trials_data_frame()

# Plot observed data and empirical Pareto front
fig, ax = plt.subplots(figsize=(6, 4), dpi=150)

ax.scatter(
    trials_df[REFRACTIVE_INDEX_NAME],
    trials_df[DISPERSION_NAME],
    fc="None",
    ec="k",
    label="Observed",
)

if not pareto_df.empty:
    ax.plot(
        pareto_df[REFRACTIVE_INDEX_NAME],
        pareto_df[DISPERSION_NAME],
        color="#0033FF",
        lw=2,
        label="Pareto Front (Observed)",
    )

ax.set_xlabel("Refractive index (maximize)")
ax.set_ylabel("Dispersion (minimize)")
ax.set_title("Optical Glass Formulation: Refractive Index vs Dispersion")
ax.legend()
plt.tight_layout()
plt.show()