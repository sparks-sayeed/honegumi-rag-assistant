# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"
obj2_name = "branin_swapped"


def branin3_moo(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    # second objective has x1 and x2 swapped
    y2 = float(
        (x1 - 5.1 / (4 * np.pi**2) * x2**2 + 5.0 / np.pi * x2 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x2)
        + 10
    )

    # Contrived way to incorporate x3 into the second objective
    y2 = y2 * (1 - 0.1 * x1 * x2 * x3)

    return {obj1_name: y, obj2_name: y2}


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
        obj2_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
    ],
)


for i in range(21):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]
    x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

    results = branin3_moo(x1, x2, x3)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)
pareto_results = ax_client.get_pareto_optimal_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto[objectives[0]],
    pareto[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])

ax.legend()
plt.show()

# Generated by adapting a Honegumi skeleton to the optical glass formulation problem
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from ax.service.ax_client import AxClient, ObjectiveProperties


# Domain-specific metric names
REFRACTIVE_INDEX = "refractive_index"  # maximize
DISPERSION = "dispersion"              # minimize


def evaluate_optical_glass(oxide_1_fraction: float, oxide_2_fraction: float, oxide_3_fraction: float):
    """
    Evaluate optical properties of a ternary glass composition.

    Parameters are oxide fractions that sum to 1.0. This function simulates:
    - refractive_index: computed via a Lorentz–Lorenz-inspired mixing rule
    - dispersion: a surrogate dispersion measure, where lower is better

    Notes:
    - This is a realistic surrogate suitable for guiding Bayesian optimization prior to lab measurements.
    - Replace with direct experimental measurements (or a high-fidelity simulator) when available.
    """

    w = np.array([oxide_1_fraction, oxide_2_fraction, oxide_3_fraction])

    # Refractive index via Lorentz–Lorenz-inspired mixing:
    # (n^2 - 1) / (n^2 + 2) = sum_i w_i * k_i, with k_i < 1 for stability.
    # Choose k values to create a trade-off (oxide_3 raises n but tends to increase dispersion).
    k = np.array([0.12, 0.20, 0.45])  # polarizability-like contributions
    S = float(np.dot(w, k))
    # Safety guard to keep S in a valid range
    S = min(max(S, 1e-6), 0.95)
    n_squared = (1.0 + 2.0 * S) / (1.0 - S)
    refractive_index = float(np.sqrt(n_squared))

    # Surrogate dispersion model (lower is better):
    # Base linear contributions plus nonlinear interaction terms to induce shape.
    d = np.array([0.010, 0.020, 0.045])  # base dispersion-like contributions
    linear_disp = float(np.dot(w, d))
    interaction_disp = 0.02 * (w[0] * w[1] + w[1] * w[2] + w[0] * w[2])
    # Tie dispersion weakly to refractive index to model realistic trade-off trends
    n_anchor = 1.60
    dispersion = linear_disp + interaction_disp + 0.008 * max(refractive_index - n_anchor, 0.0)

    # Add experimental noise to reflect real lab variability
    rng = np.random.default_rng()
    n_sem = 0.002  # ~2e-3 absolute SEM
    d_sem = 0.001  # absolute SEM for dispersion surrogate

    n_obs = refractive_index + rng.normal(0.0, n_sem)
    d_obs = dispersion + rng.normal(0.0, d_sem)

    return {
        REFRACTIVE_INDEX: (n_obs, n_sem),
        DISPERSION: (d_obs, d_sem),
    }


def is_dominated(i_vals, j_vals, maximize_mask):
    """
    Return True if point i is dominated by point j.
    maximize_mask: array-like of booleans indicating which objectives are to be maximized.
    """
    better_or_equal = []
    strictly_better = []

    for (i_val, j_val, maximize) in zip(i_vals, j_vals, maximize_mask):
        if maximize:
            better_or_equal.append(j_val >= i_val - 1e-12)
            strictly_better.append(j_val > i_val + 1e-12)
        else:
            better_or_equal.append(j_val <= i_val + 1e-12)
            strictly_better.append(j_val < i_val - 1e-12)

    return all(better_or_equal) and any(strictly_better)


def non_dominated_mask(Y, maximize_mask):
    """
    Compute non-dominated set mask for Y (n x m), given maximize/minimize per objective.
    """
    n = Y.shape[0]
    mask = np.ones(n, dtype=bool)
    for i in range(n):
        if not mask[i]:
            continue
        for j in range(n):
            if i == j or not mask[i]:
                continue
            if is_dominated(Y[i], Y[j], maximize_mask):
                mask[i] = False
    return mask


def main():
    np.random.seed(123)

    ax_client = AxClient()

    # Reparameterize composition with 2 free variables and a sum constraint
    # oxide_3_fraction = 1.0 - (oxide_1_fraction + oxide_2_fraction)
    ax_client.create_experiment(
        name="optical_glass_ternary_moo",
        parameters=[
            {"name": "oxide_1_fraction", "type": "range", "bounds": [0.0, 1.0]},
            {"name": "oxide_2_fraction", "type": "range", "bounds": [0.0, 1.0]},
        ],
        objectives={
            REFRACTIVE_INDEX: ObjectiveProperties(minimize=False),
            DISPERSION: ObjectiveProperties(minimize=True),
        },
        parameter_constraints=[
            "oxide_1_fraction + oxide_2_fraction <= 1.0",
        ],
    )

    # Run 38 sequential trials (melts)
    total_trials = 38
    for _ in range(total_trials):
        params, trial_index = ax_client.get_next_trial()

        o1 = float(params["oxide_1_fraction"])
        o2 = float(params["oxide_2_fraction"])
        o3 = 1.0 - (o1 + o2)

        data = evaluate_optical_glass(o1, o2, o3)
        ax_client.complete_trial(trial_index=trial_index, raw_data=data)

    # Retrieve results
    df = ax_client.get_trials_data_frame()

    # Construct a tidy DataFrame with parameters and metrics
    # Ensure missing columns are handled robustly
    keep_cols = []
    for col in ["trial_index", "arm_name", "oxide_1_fraction", "oxide_2_fraction", REFRACTIVE_INDEX, DISPERSION]:
        if col in df.columns:
            keep_cols.append(col)
    results = df[keep_cols].copy()

    # Add derived third fraction
    if "oxide_1_fraction" in results.columns and "oxide_2_fraction" in results.columns:
        results["oxide_3_fraction"] = 1.0 - (results["oxide_1_fraction"].astype(float) + results["oxide_2_fraction"].astype(float))

    # Compute non-dominated set on observed data
    metric_data = results[[REFRACTIVE_INDEX, DISPERSION]].to_numpy(dtype=float)
    maximize_mask = np.array([True, False])  # refractive_index maximize, dispersion minimize
    nd_mask = non_dominated_mask(metric_data, maximize_mask)
    pareto_df = results.loc[nd_mask].copy()

    # Print Pareto-optimal compositions
    pareto_display = pareto_df[
        ["oxide_1_fraction", "oxide_2_fraction", "oxide_3_fraction", REFRACTIVE_INDEX, DISPERSION]
    ].sort_values(by=[DISPERSION, REFRACTIVE_INDEX], ascending=[True, False])
    print("Observed Pareto-optimal (non-dominated) compositions:")
    print(pareto_display.to_string(index=False, float_format=lambda x: f"{x:.5f}"))

    # Plot observed data and Pareto front
    fig, ax = plt.subplots(figsize=(6.5, 4.5), dpi=150)
    ax.scatter(results[DISPERSION], results[REFRACTIVE_INDEX], facecolors="none", edgecolors="k", label="Observed")
    pareto_sorted = pareto_df.sort_values(by=DISPERSION, ascending=True)
    ax.plot(pareto_sorted[DISPERSION], pareto_sorted[REFRACTIVE_INDEX], color="#0033FF", lw=2, label="Pareto Front")
    ax.set_xlabel("Dispersion (lower is better)")
    ax.set_ylabel("Refractive Index (higher is better)")
    ax.set_title("Optical Glass Ternary: Pareto Front (Observed)")
    ax.legend()
    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    main()