# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin3(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    return y


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
        "x1 <= x2",  # example of an order constraint
    ],
)


batch_size = 2


for i in range(21):

    parameterizations, optimization_complete = ax_client.get_next_trials(batch_size)
    for trial_index, parameterization in list(parameterizations.items()):
        # extract parameters
        x1 = parameterization["x1"]
        x2 = parameterization["x2"]
        x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

        results = branin3(x1, x2, x3)
        ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()
df.index = df.index // batch_size

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Anti-corrosion coating formulation optimization with Ax (Bayesian optimization)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


np.random.seed(12345)


def evaluate_coating_formulation(
    resin: float,
    inhibitor: float,
    insulator: float,
    stabilizer: float,
    coating_thickness: float,
) -> dict:
    """
    Simulated evaluation of corrosion damage (lower is better).
    Domain-informed surrogate capturing expected trends:
      - Higher resin and insulator improve barrier properties.
      - Inhibitor reduces corrosion rate but excessive amounts can weaken film.
      - Stabilizer has an optimum at ~0.08; too little/too much is detrimental.
      - Thicker coatings reduce damage with diminishing returns; excessive thickness can crack.

    Returns a dict with a single key "corrosion_damage".
    Replace this function body with your lab automation / measurement pipeline to use real data.
    """

    # Numerical safety: enforce feasible domain within small tolerance
    total = resin + inhibitor + insulator + stabilizer
    if not np.isfinite(total) or total <= 0:
        return {"corrosion_damage": 10.0}

    # Slight renormalization in case of tiny numerical drift from equality constraint
    if abs(total - 1.0) > 1e-6:
        resin, inhibitor, insulator, stabilizer = (
            resin / total,
            inhibitor / total,
            insulator / total,
            stabilizer / total,
        )

    # Domain-shape constants
    thickness_um = float(coating_thickness)
    thickness_um = np.clip(thickness_um, 5.0, 200.0)

    # Barrier score from film-forming resin and insulator
    barrier_score = 0.65 * resin + 0.55 * insulator  # weighted toward resin
    barrier_score = np.clip(barrier_score, 0.0, 1.0)

    # Thickness effect: diminishing returns, mild penalty when very thick
    # Decreases damage as thickness increases, but very thick (>150 um) slightly increases due to cracking risk
    thickness_reduction = 1.0 / (1.0 + (thickness_um / 60.0) ** 0.9)  # in (0,1]
    over_thickness_penalty = 1.0 + 0.25 * max(0.0, (thickness_um - 150.0) / 50.0) ** 2

    # Inhibitor effect: reduces corrosion rate but saturates; high levels can weaken film slightly
    inhibitor_benefit = 1.0 - 0.75 * (1.0 - np.exp(-inhibitor / 0.12))  # in [0.25, 1]
    inhibitor_overuse_penalty = 1.0 + 0.4 * max(0.0, inhibitor - 0.25)

    # Resin sufficiency: too little resin harms integrity/adhesion
    resin_low_penalty = 1.0 + 0.9 * max(0.0, 0.30 - resin)

    # Stabilizer has an optimum around 0.08
    stabilizer_penalty = 1.0 + 2.0 * (stabilizer - 0.08) ** 2

    # Barrier effectiveness couples barrier score and thickness
    barrier_effect = 1.0 / (1.0 + 3.2 * barrier_score * (1.0 - np.exp(-thickness_um / 85.0)))

    # Additional mild penalty if resin is not clearly larger than others (should be handled by constraint)
    order_safety_penalty = 1.0 + 0.2 * max(0.0, inhibitor - resin) + 0.2 * max(0.0, insulator - resin)

    # Aggregate damage model (lower is better)
    # Start from an environmental baseline and apply multiplicative factors
    baseline_damage = 1.6  # arbitrary units
    damage = (
        baseline_damage
        * barrier_effect
        * inhibitor_benefit
        * thickness_reduction
        * inhibitor_overuse_penalty
        * resin_low_penalty
        * stabilizer_penalty
        * over_thickness_penalty
        * order_safety_penalty
    )

    # Add measurement/process noise to emulate real experiments
    # Heteroscedastic: relative to damage level plus a small floor
    noise = np.random.normal(loc=0.0, scale=0.04 * damage + 0.01)
    noisy_damage = float(max(0.0, damage + noise))

    return {"corrosion_damage": noisy_damage}


objective_name = "corrosion_damage"

# Create Ax client and define the optimization problem
ax_client = AxClient()

ax_client.create_experiment(
    name="anti_corrosion_coating_optimization",
    parameters=[
        {"name": "resin", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "inhibitor", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "insulator", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "stabilizer", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "coating_thickness", "type": "range", "bounds": [5.0, 200.0]},
    ],
    objectives={objective_name: ObjectiveProperties(minimize=True)},
    parameter_constraints=[
        # Composition equality: resin + inhibitor + insulator + stabilizer == 1.0
        "resin + inhibitor + insulator + stabilizer <= 1.0",
        "-resin - inhibitor - insulator - stabilizer <= -1.0",
        # Order constraints based on hypothesis: resin >= inhibitor and resin >= insulator
        "inhibitor <= resin",
        "insulator <= resin",
    ],
)

# Batch size (parallelism)
batch_size = 6

# Number of batches to run
num_batches = 20

# Optimization loop
for batch_idx in range(num_batches):
    parameterizations, optimization_complete = ax_client.get_next_trials(batch_size)
    for trial_index, params in list(parameterizations.items()):
        # Extract parameters for this trial
        resin = params["resin"]
        inhibitor = params["inhibitor"]
        insulator = params["insulator"]
        stabilizer = params["stabilizer"]
        coating_thickness = params["coating_thickness"]

        # Run the (simulated) experiment
        results = evaluate_coating_formulation(
            resin=resin,
            inhibitor=inhibitor,
            insulator=insulator,
            stabilizer=stabilizer,
            coating_thickness=coating_thickness,
        )

        # Report result back to Ax
        ax_client.complete_trial(trial_index=trial_index, raw_data=results[objective_name])

# Retrieve best found parameters
best_parameters, best_values = ax_client.get_best_parameters()
best_damage = best_values[objective_name]["objective"] if isinstance(best_values, dict) else best_values

print("Best parameters found:")
for k, v in best_parameters.items():
    print(f"  {k}: {v:.6f}")
print(f"Best observed corrosion_damage: {best_damage:.6f}")

# Visualization: best-so-far over batches
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()
df.index = df.index // batch_size

fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Batch Number")
ax.set_ylabel(objectives[0])
ax.set_title("Anti-corrosion coating optimization (lower is better)")
ax.legend()
plt.tight_layout()
plt.show()