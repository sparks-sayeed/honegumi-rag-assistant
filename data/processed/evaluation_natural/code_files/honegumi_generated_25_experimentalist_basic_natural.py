# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    return y


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Optimizing fermentation medium (glucose, nitrogen source, phosphate) for maximum biomass yield
# Generated from Honegumi skeleton and adapted to a real-world problem
# %pip install ax-platform==0.4.3 matplotlib

from typing import Dict, Tuple
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from ax.service.ax_client import AxClient, ObjectiveProperties


objective_name = "biomass_yield_gDCW_per_L"  # Biomass yield (dry cell weight) in g/L

# Random number generator for simulated measurement noise (remove seeding in production)
_rng = np.random.default_rng(seed=42)


def evaluate_fermentation(
    glucose_g_per_l: float,
    nitrogen_source_g_per_l: float,
    phosphate_g_per_l: float,
) -> Dict[str, Tuple[float, float]]:
    """Evaluate biomass yield for a given fermentation medium composition.

    This function currently simulates biomass yield using a plausible bioprocess model with:
    - Saturation (Monod-like) effects for C, N, P
    - Inhibition at excessive concentrations (osmotic/toxic)
    - Penalty for deviation from a target C:N:P ratio
    - Additive Gaussian measurement noise, returning both mean and SEM

    TODO: Replace this simulation with the actual lab or simulation measurement:
      - Set up the culture with the provided concentrations
      - Measure biomass yield (e.g., gDCW/L or OD600 converted to gDCW/L)
      - Estimate measurement noise (SEM) from replicates or instrumentation
    """
    # Target concentrations (approximate reasonable optima)
    target_glucose = 20.0       # g/L
    target_nitrogen = 1.2       # g/L (e.g., as ammonium source mass-equivalent)
    target_phosphate = 0.5      # g/L (e.g., KH2PO4 mass-equivalent)

    # Monod-like saturation constants
    Kc = 5.0   # g/L for glucose
    Kn = 0.3   # g/L for nitrogen source
    Kp = 0.1   # g/L for phosphate

    # Base achievable biomass yield at optimum (gDCW/L)
    Y_max = 15.0

    # Saturation (limitation) factors
    s_c = glucose_g_per_l / (Kc + glucose_g_per_l)
    s_n = nitrogen_source_g_per_l / (Kn + nitrogen_source_g_per_l)
    s_p = phosphate_g_per_l / (Kp + phosphate_g_per_l)
    limitation = min(s_c, s_n, s_p)

    # Inhibition penalties for excessive concentrations (Gaussian tails)
    inh_c = np.exp(-((max(0.0, glucose_g_per_l - 30.0) / 10.0) ** 2))
    inh_n = np.exp(-((max(0.0, nitrogen_source_g_per_l - 2.0) / 0.5) ** 2))
    inh_p = np.exp(-((max(0.0, phosphate_g_per_l - 1.2) / 0.4) ** 2))

    # Ratio penalty: closeness to target stoichiometry (mass-based proxy)
    v_g = glucose_g_per_l / max(target_glucose, 1e-9)
    v_n = nitrogen_source_g_per_l / max(target_nitrogen, 1e-9)
    v_p = phosphate_g_per_l / max(target_phosphate, 1e-9)
    ratio_penalty = np.exp(-1.5 * ((v_g - 1.0) ** 2 + (v_n - 1.0) ** 2 + (v_p - 1.0) ** 2))

    # Deterministic yield model
    modeled_yield = Y_max * limitation * inh_c * inh_n * inh_p * ratio_penalty

    # Measurement noise (simulate experimental variability)
    noise_sd = 0.1 + 0.05 * modeled_yield  # heteroscedastic noise
    measured_yield = max(0.0, modeled_yield + _rng.normal(0.0, noise_sd))

    # Estimated standard error of the mean (example)
    sem = max(0.05, 0.2 + 0.03 * measured_yield)

    return {objective_name: (float(measured_yield), float(sem))}


# Initialize Ax optimization client
ax_client = AxClient()

# Define the search space for medium composition
ax_client.create_experiment(
    parameters=[
        {
            "name": "glucose_g_per_l",
            "type": "range",
            "bounds": [0.0, 40.0],  # typical workable range for many microbes
        },
        {
            "name": "nitrogen_source_g_per_l",
            "type": "range",
            "bounds": [0.0, 3.0],  # e.g., ammonium or urea source mass-equivalent
        },
        {
            "name": "phosphate_g_per_l",
            "type": "range",
            "bounds": [0.0, 1.5],  # e.g., KH2PO4 mass-equivalent
        },
    ],
    objectives={
        objective_name: ObjectiveProperties(minimize=False),
    },
)

# Run the optimization for a total budget of 30 cultures
total_trials = 30
for _ in range(total_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters
    glucose = float(parameterization["glucose_g_per_l"])
    nitrogen = float(parameterization["nitrogen_source_g_per_l"])
    phosphate = float(parameterization["phosphate_g_per_l"])

    # Evaluate the fermentation
    results = evaluate_fermentation(glucose, nitrogen, phosphate)

    # Report result (mean and SEM) back to Ax
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Get best parameters and their estimated outcome
best_parameters, best_metrics = ax_client.get_best_parameters()

print("Best medium composition found:")
for k, v in best_parameters.items():
    print(f"  {k}: {v:.4f}")

bm = best_metrics[objective_name]
best_mean = bm["mean"] if isinstance(bm, dict) else bm[0]
best_sem = bm["sem"] if isinstance(bm, dict) else bm[1]
print(f"Estimated best {objective_name}: {best_mean:.3f} Â± {best_sem:.3f} (SEM)")

# Plot results
df = ax_client.get_trials_data_frame()
y = df[objective_name].values
trial_numbers = df.index.values

fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
ax.scatter(trial_numbers, y, ec="k", fc="none", label="Observed")
ax.plot(trial_numbers, np.maximum.accumulate(y), color="#0033FF", lw=2, label="Best to Trial")
ax.set_xlabel("Trial Number")
ax.set_ylabel(objective_name)
ax.legend()
plt.tight_layout()
plt.show()