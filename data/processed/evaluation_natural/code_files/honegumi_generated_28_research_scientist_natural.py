# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from typing import Dict, Tuple
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Problem: Optimize extraction efficiency as a function of temperature and solvent ratio
# Parameters:
#   - temperature_celsius: temperature of extraction in degrees Celsius
#   - solvent_ratio: solvent-to-feed ratio (dimensionless fraction, e.g., 0.1 to 0.9)
# Objective:
#   - extraction_efficiency: percentage yield of extraction (maximize)
# Experimental setup:
#   - 26 trials, single-trial batches, noisy measurements


objective_name = "extraction_efficiency"

_rng = np.random.default_rng(123)


def evaluate_extraction_process(temperature_celsius: float, solvent_ratio: float) -> Dict[str, Tuple[float, float]]:
    """
    Simulated evaluation of extraction efficiency.

    This function provides a realistic synthetic response surface for extraction efficiency that depends on:
    - A temperature optimum (e.g., dissolution and mass transfer effects)
    - A solvent ratio optimum (e.g., sufficient solvent without excessive dilution)
    - Mild interaction and periodic effects (e.g., equipment behavior, mixing regimes)
    - Additive Gaussian noise to emulate measurement/process noise

    Returns:
        Dict mapping metric name to a (mean, SEM) tuple as expected by Ax.
    """
    # Physical-like response surface (values roughly 0-100%)
    # Optima chosen for demonstration; adjust to your process specifics if known.
    t_opt = 65.0
    r_opt = 0.60
    sigma_t = 10.0
    sigma_r = 0.12

    # Main peak (Gaussian in T and ratio)
    term_t = np.exp(-0.5 * ((temperature_celsius - t_opt) / sigma_t) ** 2)
    term_r = np.exp(-0.5 * ((solvent_ratio - r_opt) / sigma_r) ** 2)

    # Mild interaction/periodic structure
    interaction = 0.20 * np.sin(0.09 * (temperature_celsius - 25.0)) + 0.05 * np.cos(10.0 * solvent_ratio)

    # Combine terms into efficiency
    efficiency_mean = 40.0 + 55.0 * (term_t * term_r) + 10.0 * interaction
    efficiency_mean = float(np.clip(efficiency_mean, 0.0, 100.0))

    # Additive measurement/process noise
    noise_sd = 1.5  # percentage points SEM
    noisy_measurement = float(np.clip(efficiency_mean + _rng.normal(0.0, noise_sd), 0.0, 100.0))

    # Return (mean, SEM) for the metric
    return {objective_name: (noisy_measurement, noise_sd)}


# Initialize Ax optimization client
ax_client = AxClient()

# Define search space and objective
ax_client.create_experiment(
    name="extraction_efficiency_optimization",
    parameters=[
        {
            "name": "temperature_celsius",
            "type": "range",
            "bounds": [30.0, 90.0],
            "value_type": "float",
            "log_scale": False,
        },
        {
            "name": "solvent_ratio",
            "type": "range",
            "bounds": [0.10, 0.90],  # fraction of solvent relative to feed
            "value_type": "float",
            "log_scale": False,
        },
    ],
    objectives={
        objective_name: ObjectiveProperties(minimize=False),
    },
    choose_generation_strategy=True,
    is_test=False,
)

# Run optimization for the specified budget
total_trials = 26
for _ in range(total_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    temperature_celsius = float(parameterization["temperature_celsius"])
    solvent_ratio = float(parameterization["solvent_ratio"])

    results = evaluate_extraction_process(temperature_celsius, solvent_ratio)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve best found parameters and corresponding metric
best_parameters, best_metrics = ax_client.get_best_parameters()
best_efficiency = best_metrics[objective_name]["mean"]

print("Best parameters found:")
print(best_parameters)
print(f"Best extraction efficiency (mean): {best_efficiency:.2f} %")

# Visualization: progress over trials
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

# Robustly select the metric column for plotting (mean values)
if objective_name in df.columns:
    y_series = df[objective_name].astype(float)
else:
    matches = [c for c in df.columns if objective_name in str(c) and "sem" not in str(c).lower()]
    y_series = df[matches[0]].astype(float) if matches else pd.Series([], dtype=float)

fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
ax.scatter(df.index, y_series, ec="k", fc="none", label="Observed")
ax.plot(df.index, np.maximum.accumulate(y_series), color="#0033FF", lw=2, label="Best to Trial")
ax.set_xlabel("Trial Number")
ax.set_ylabel("Extraction Efficiency (%)")
ax.set_title("Optimization Progress")
ax.legend()
plt.tight_layout()
plt.show()

# Visualization: explored design space with measured outcomes
if {"temperature_celsius", "solvent_ratio"}.issubset(df.columns):
    fig2, ax2 = plt.subplots(figsize=(6, 5), dpi=150)
    sc = ax2.scatter(
        df["solvent_ratio"],
        df["temperature_celsius"],
        c=y_series,
        cmap="viridis",
        s=60,
        edgecolor="k",
    )
    ax2.set_xlabel("Solvent Ratio (fraction)")
    ax2.set_ylabel("Temperature (Â°C)")
    ax2.set_title("Explored Conditions Colored by Extraction Efficiency")
    cbar = plt.colorbar(sc, ax=ax2)
    cbar.set_label("Extraction Efficiency (%)")
    plt.tight_layout()
    plt.show()