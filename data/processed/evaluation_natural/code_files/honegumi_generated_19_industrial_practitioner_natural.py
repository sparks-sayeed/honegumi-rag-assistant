# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    return y


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        "1.0*x1 + 0.5*x2 <= 15.0",  # example of a linear constraint. Note the lack of space around the asterisks
    ],
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Generated from Honegumi skeleton and adapted for reactor yield optimization
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


np.random.seed(42)


def evaluate_reactor_yield(temperature_c: float, pressure_bar: float, residence_time_min: float) -> float:
    """
    Synthetic, executable evaluation for reactor product yield (%).

    This function simulates a first-order desired reaction with a concurrent degradation pathway.
    It returns a noisy yield percentage in [0, 100], given:
      - temperature_c: Reactor temperature in degrees Celsius
      - pressure_bar: Reactor pressure in bar
      - residence_time_min: Residence time in minutes

    Model:
      Desired conversion: X = 1 - exp(-k_desired * t)
        k_desired = A * exp(-Ea / (R * T)) * (pressure_bar / P_ref) ** beta

      Degradation penalty: D = exp(-k_deg * t)
        k_deg = A_d * exp(-Ead / (R * T))

      Yield fraction = X * D
      Yield percent = 100 * Yield fraction + measurement noise

    Notes:
      - T in Kelvin
      - R = 8.314 J/mol/K
      - Chosen constants produce a smooth landscape with a practical optimum inside the provided bounds.
    """
    # Constants
    R = 8.314  # J/mol/K
    T_k = temperature_c + 273.15

    # Desired pathway kinetics (per minute)
    A = 2.0e7        # pre-exponential factor, 1/min
    Ea = 6.5e4       # J/mol
    P_ref = 5.0      # bar
    beta = 0.6       # pressure order for desired pathway

    k_desired = A * np.exp(-Ea / (R * T_k)) * (max(pressure_bar, 0.1) / P_ref) ** beta

    # Degradation pathway (per minute)
    A_d = 4.0e-4     # 1/min
    Ea_d = 8.0e4     # J/mol
    k_deg = A_d * np.exp(-Ea_d / (R * T_k))

    t = max(residence_time_min, 0.0)

    # Conversion to desired product
    X = 1.0 - np.exp(-k_desired * t)
    X = np.clip(X, 0.0, 1.0)

    # Degradation penalty
    D = np.exp(-k_deg * t)
    D = np.clip(D, 0.0, 1.0)

    yield_fraction = X * D

    # Add modest measurement/process noise (heteroscedastic-like)
    noise_sd = 1.5 + 0.5 * (pressure_bar / 30.0) + 0.5 * (temperature_c / 220.0)
    noise = np.random.normal(0.0, noise_sd)

    yield_percent = 100.0 * yield_fraction + noise
    yield_percent = float(np.clip(yield_percent, 0.0, 100.0))

    return yield_percent


# Instantiate Ax client
ax_client = AxClient()

# Define experiment: maximize product yield within safety constraints
ax_client.create_experiment(
    name="reactor_yield_optimization",
    parameters=[
        {
            "name": "temperature_c",
            "type": "range",
            "bounds": [60.0, 220.0],
            "value_type": "float",
        },
        {
            "name": "pressure_bar",
            "type": "range",
            "bounds": [1.0, 30.0],
            "value_type": "float",
        },
        {
            "name": "residence_time_min",
            "type": "range",
            "bounds": [1.0, 240.0],
            "value_type": "float",
        },
    ],
    objectives={
        "product_yield_percent": ObjectiveProperties(minimize=False),
    },
    parameter_constraints=[
        # Linear safety envelope (dimensionless severity index):
        #  0.003*temperature_c + 0.03*pressure_bar + 0.003*residence_time_min <= 1.2
        # This discourages simultaneous extremes in T, P, and time.
        "0.003*temperature_c + 0.03*pressure_bar + 0.003*residence_time_min <= 1.2",
    ],
)

# Optimization budget
n_trials = 35

for i in range(n_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters for clarity
    temperature_c = float(parameterization["temperature_c"])
    pressure_bar = float(parameterization["pressure_bar"])
    residence_time_min = float(parameterization["residence_time_min"])

    # Run the experiment/simulation to obtain yield
    observed_yield = evaluate_reactor_yield(
        temperature_c=temperature_c,
        pressure_bar=pressure_bar,
        residence_time_min=residence_time_min,
    )

    # Report result back to Ax
    ax_client.complete_trial(trial_index=trial_index, raw_data=observed_yield)

# Get best parameters and corresponding objective
best_parameters, best_values = ax_client.get_best_parameters()
best_yield = best_values["product_yield_percent"]["value"]

print("Best operating conditions found:")
print(best_parameters)
print(f"Estimated best product yield: {best_yield:.2f} %")

# Plot observed yields and best-so-far trajectory
objective_names = ax_client.objective_names
df = ax_client.get_trials_data_frame()

y_series = df[objective_names[0]]

fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
ax.scatter(df.index, y_series, ec="k", fc="none", label="Observed yield")
ax.plot(
    df.index,
    np.maximum.accumulate(y_series),
    color="#0033FF",
    lw=2,
    label="Best-so-far",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel("Product Yield (%)")
ax.set_title("Reactor Yield Optimization (Bayesian Optimization with Ax)")
ax.legend()
plt.tight_layout()
plt.show()