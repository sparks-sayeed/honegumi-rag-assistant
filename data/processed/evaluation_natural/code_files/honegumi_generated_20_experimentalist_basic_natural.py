# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


def evaluate_led_thermal_performance(
    heat_sink_area_cm2: float,
    thermal_paste_thickness_um: float,
    ambient_c: float = 25.0,
    led_power_w: float = 5.0,
    rng: np.random.Generator | None = None,
) -> float:
    """
    Compute LED junction temperature (Celsius) based on a simple steady-state thermal model.

    Parameters
    - heat_sink_area_cm2: External surface area of the heat sink in cm^2 (higher lowers thermal resistance).
    - thermal_paste_thickness_um: Thickness of thermal interface material (TIM) in micrometers (lower lowers thermal resistance).
    - ambient_c: Ambient temperature in Celsius.
    - led_power_w: Electrical power dissipated as heat in Watts.
    - rng: Optional numpy Generator for reproducible noise.

    Model:
    Tj = Tamb + P * (R_jc + R_tim + R_hs) + epsilon
      where
        R_jc: junction-to-case thermal resistance (K/W), constant for a given LED package
        R_tim: thermal resistance of interface layer (K/W) = t / (k_TIM * A_contact)
        R_hs: heat sink thermal resistance to ambient (K/W) ≈ 1 / (h * A_ext)
        epsilon: measurement/process noise term to simulate real-world noise

    Returns
    - junction temperature in Celsius (float)
    """
    if rng is None:
        rng = np.random.default_rng()

    # Constants (typical values; adjust if you have vendor data)
    R_jc_k_per_w = 3.0  # LED junction-to-case thermal resistance (K/W)
    k_tim_w_per_mk = 3.0  # TIM thermal conductivity (W/m-K)
    A_contact_m2 = 1.0e-4  # Contact area between LED base and heat sink (1 cm^2) in m^2
    h_w_per_m2k = 20.0  # Convective heat transfer coefficient (W/m^2-K), natural to mild forced convection

    # Conversions
    A_ext_m2 = float(heat_sink_area_cm2) * 1.0e-4  # cm^2 -> m^2
    thickness_m = float(thermal_paste_thickness_um) * 1.0e-6  # um -> m

    # Guard against pathological inputs (though bounds should prevent this)
    A_ext_m2 = max(A_ext_m2, 1e-6)
    thickness_m = max(thickness_m, 1e-7)

    # Thermal resistances
    R_tim_k_per_w = thickness_m / (k_tim_w_per_mk * A_contact_m2)
    R_hs_k_per_w = 1.0 / (h_w_per_m2k * A_ext_m2)

    # Junction temperature
    tj_c = ambient_c + led_power_w * (R_jc_k_per_w + R_tim_k_per_w + R_hs_k_per_w)

    # Add small measurement/process noise
    noise_c = rng.normal(0.0, 0.3)  # ~0.3 C std dev
    return float(tj_c + noise_c)


def main() -> None:
    objective_name = "junction_temperature_c"
    rng = np.random.default_rng(seed=42)

    ax_client = AxClient()
    ax_client.create_experiment(
        name="led_junction_temperature_minimization",
        parameters=[
            {
                "name": "heat_sink_area_cm2",
                "type": "range",
                "bounds": [20.0, 100.0],  # typical compact heat sink external area range
            },
            {
                "name": "thermal_paste_thickness_um",
                "type": "range",
                "bounds": [10.0, 300.0],  # thin to thick TIM layer
            },
        ],
        objectives={
            objective_name: ObjectiveProperties(minimize=True),
        },
        tracking_metric_names=[objective_name],
        is_test=False,
    )

    num_trials = 28  # Budget: can make 28 packages
    observation_history = []

    for _ in range(num_trials):
        parameterization, trial_index = ax_client.get_next_trial()

        # Extract parameters
        heat_sink_area_cm2 = parameterization["heat_sink_area_cm2"]
        thermal_paste_thickness_um = parameterization["thermal_paste_thickness_um"]

        # Evaluate junction temperature
        junction_temp_c = evaluate_led_thermal_performance(
            heat_sink_area_cm2=heat_sink_area_cm2,
            thermal_paste_thickness_um=thermal_paste_thickness_um,
            rng=rng,
        )

        # Report result
        ax_client.complete_trial(trial_index=trial_index, raw_data=junction_temp_c)
        observation_history.append(junction_temp_c)

    # Best found parameters and value
    best_parameters, best_values = ax_client.get_best_parameters()
    best_mean = best_values[objective_name][0]
    best_sem = best_values[objective_name][1]

    print("Best parameters found:")
    for k, v in best_parameters.items():
        print(f"  {k}: {v:.6g}")
    print(f"Estimated best {objective_name}: {best_mean:.3f} ± {best_sem:.3f} C")

    # Plot optimization trace
    history = np.array(observation_history, dtype=float)
    best_so_far = np.minimum.accumulate(history)

    fig, ax = plt.subplots(figsize=(7, 4), dpi=140)
    ax.scatter(np.arange(1, len(history) + 1), history, ec="k", fc="none", label="Observed")
    ax.plot(np.arange(1, len(history) + 1), best_so_far, color="#0033FF", lw=2, label="Best so far")
    ax.set_xlabel("Trial number")
    ax.set_ylabel("LED junction temperature (C)")
    ax.set_title("LED Package Optimization: Junction Temperature Minimization")
    ax.grid(True, alpha=0.3)
    ax.legend()
    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    main()