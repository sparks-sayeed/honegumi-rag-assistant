# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from typing import Dict, Tuple
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Reproducibility for the synthetic evaluation stub below
np.random.seed(123)

# Domain-specific names
OBJECTIVE_NAME = "activity"  # Catalytic activity (maximize)
PARAM_TEMPERATURE = "calcination_temperature_c"  # degrees Celsius
PARAM_TIME = "calcination_time_h"  # hours


def evaluate_catalyst_activity(calcination_temperature_c: float, calcination_time_h: float) -> Dict[str, Tuple[float, float]]:
    """
    Evaluate catalytic activity for a given calcination schedule.

    This is a realistic stub to enable running the optimization loop.
    Replace with your actual lab/plant evaluation:
      - Schedule calcination at (temperature, time)
      - Produce a batch and measure catalytic activity on your standard test reaction
      - Return the measured activity (and optionally its standard error)

    Model rationale (synthetic):
      - Activity has a peak around an optimal temperature and time due to phase formation.
      - Too high temperature or too long time causes sintering and loss of surface area.
      - Optimal time decreases mildly as temperature increases (faster kinetics).
      - Add measurement/process noise to reflect real experiments.

    Returns:
      A dict with the single objective:
        {
          "activity": (value, sem)  # sem = standard error of the mean (or measurement uncertainty)
        }
    """
    T = float(calcination_temperature_c)
    t = float(calcination_time_h)

    # Temperature-time interaction: optimal time shifts lower at higher temperature
    t_opt = 5.0 - 0.004 * (T - 600.0)  # hours

    # Peak around T_opt=600C, t_opt as above; widths reflect process sensitivity
    T_opt = 600.0  # deg C
    sigma_T = 80.0
    sigma_t = 1.8

    # Base peak amplitude (arbitrary activity units, e.g., mol_product g_cat^-1 h^-1)
    amplitude = 100.0
    baseline = 5.0

    # 2D Gaussian peak with interaction via t_opt(T)
    temp_term = np.exp(-0.5 * ((T - T_opt) / sigma_T) ** 2)
    time_term = np.exp(-0.5 * ((t - t_opt) / sigma_t) ** 2)

    # Include a mild penalty for extreme durations to mimic over-/under-calcination side effects
    duration_penalty = np.exp(-0.03 * max(0.0, t - 8.0)) * np.exp(-0.03 * max(0.0, 1.0 - t))

    true_activity = baseline + amplitude * temp_term * time_term * duration_penalty

    # Add realistic noise (process + measurement), heteroscedastic around 2-5% of signal
    noise_sd = max(1.0, 0.03 * true_activity)
    noisy_activity = float(np.random.normal(loc=true_activity, scale=noise_sd))

    # Report a standard error (if you don't have it, you can report a fixed small value)
    sem = float(max(0.5, 0.5 * noise_sd))

    return {OBJECTIVE_NAME: (noisy_activity, sem)}


# Initialize Ax optimization client
ax_client = AxClient()

# Create experiment: optimize calcination temperature and time to maximize activity
ax_client.create_experiment(
    name="catalyst_calcination_optimization",
    parameters=[
        # Typical calcination ranges; adjust to your process limits
        {"name": PARAM_TEMPERATURE, "type": "range", "bounds": [350.0, 800.0]},
        {"name": PARAM_TIME, "type": "range", "bounds": [1.0, 10.0]},
    ],
    objectives={
        OBJECTIVE_NAME: ObjectiveProperties(minimize=False),
    },
    # By default, Ax assumes observations are noisy if you provide (mean, sem)
)

# Budget: 25 trials
N_TRIALS = 25

for i in range(N_TRIALS):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters
    T_c = float(parameterization[PARAM_TEMPERATURE])
    t_h = float(parameterization[PARAM_TIME])

    try:
        results = evaluate_catalyst_activity(T_c, t_h)
        ax_client.complete_trial(trial_index=trial_index, raw_data=results)
    except Exception as exc:
        # If evaluation fails, mark the trial as failed so Ax can recover
        ax_client.log_trial_failure(trial_index=trial_index)

# Best parameters found
best_parameters, best_metrics = ax_client.get_best_parameters()

print("Best calcination recipe found:")
print(f"  - Temperature (C): {best_parameters.get(PARAM_TEMPERATURE):.2f}")
print(f"  - Time (h):        {best_parameters.get(PARAM_TIME):.2f}")
best_activity = best_metrics[OBJECTIVE_NAME]["mean"]
best_activity_sem = best_metrics[OBJECTIVE_NAME].get("sem", None)
if best_activity_sem is not None:
    print(f"Estimated activity: {best_activity:.2f} Â± {best_activity_sem:.2f}")
else:
    print(f"Estimated activity: {best_activity:.2f}")

# Plot results
df = ax_client.get_trials_data_frame()
if OBJECTIVE_NAME in df.columns:
    y = df[OBJECTIVE_NAME].astype(float)
else:
    # Fallback: find the first column that matches the objective name pattern
    possible_cols = [c for c in df.columns if OBJECTIVE_NAME in str(c)]
    if not possible_cols:
        raise RuntimeError("Could not find activity column in trials dataframe.")
    y = df[possible_cols[0]].astype(float)

fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
ax.scatter(df.index, y, ec="k", fc="none", label="Observed activity")
ax.plot(df.index, np.maximum.accumulate(y), color="#0033FF", lw=2, label="Best so far")
ax.set_xlabel("Trial number")
ax.set_ylabel("Catalytic activity (arb. units)")
ax.set_title("Calcination optimization: activity over trials")
ax.legend()
plt.tight_layout()
plt.show()