# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Problem-specific configuration
EDGE_ROUGHNESS_METRIC = "edge_roughness_microns"
BUDGET_TRIALS = 30

# Reproducibility for the simulated evaluator (remove seeding for real experiments)
_rng = np.random.default_rng(2025)


def evaluate_laser_cut(laser_power_watts: float, traverse_speed_mm_per_s: float) -> dict:
    """
    Simulate measuring edge roughness (Ra, micrometers) for a laser cutting pass.

    This stub encodes a plausible relationship:
    - Roughness is minimized near an optimal linear energy density (LED = power/speed).
    - Deviations in speed and power away from nominal settings slightly worsen roughness.
    - Mild interaction/texture terms and measurement noise are added.

    Replace this function with actual measurement logic (e.g., run a cut and
    measure Ra via profilometer) and return the measured value and its SEM.

    Returns:
        Dict with EDGE_ROUGHNESS_METRIC -> (mean_value, sem)
    """
    # Compute linear energy density (J/mm). 1 W = 1 J/s, so W / (mm/s) = J/mm.
    led_j_per_mm = laser_power_watts / traverse_speed_mm_per_s

    # Choose plausible optima (adjust to your process/material):
    led_opt = 1.2       # J/mm
    speed_opt = 1200.0  # mm/s
    power_opt = 1500.0  # W

    # Base roughness and penalty terms (units: micrometers, Ra)
    base_ra = 1.6
    term_led = 7.5 * (led_j_per_mm - led_opt) ** 2
    term_speed = 1.2 * ((traverse_speed_mm_per_s - speed_opt) / speed_opt) ** 2
    term_power = 0.8 * ((laser_power_watts - power_opt) / power_opt) ** 2

    # Mild nonconvex texture from process dynamics
    interaction = 0.15 * np.sin(0.0025 * traverse_speed_mm_per_s) * np.cos(0.003 * laser_power_watts)

    # True (noise-free) roughness model
    roughness_true = base_ra + term_led + term_speed + term_power + interaction

    # Measurement noise level grows slightly as process moves away from optimum LED
    noise_sigma = 0.10 + 0.05 * min((led_j_per_mm - led_opt) ** 2, 1.0)

    # Simulated measurement with noise
    measured_ra = float(max(0.05, roughness_true + _rng.normal(0.0, noise_sigma)))
    sem = float(noise_sigma)  # standard error of mean (single measurement; adjust if averaging)

    return {EDGE_ROUGHNESS_METRIC: (measured_ra, sem)}


# Set up Ax optimization client
ax_client = AxClient()

# Define search space for laser cutting parameters (adjust bounds to your machine/material)
ax_client.create_experiment(
    parameters=[
        # Laser output power in Watts
        {"name": "laser_power_watts", "type": "range", "bounds": [200.0, 3000.0]},
        # Traverse speed in mm/s
        {"name": "traverse_speed_mm_per_s", "type": "range", "bounds": [100.0, 4000.0]},
    ],
    objectives={
        EDGE_ROUGHNESS_METRIC: ObjectiveProperties(minimize=True),
    },
)

# Optimization loop
for _ in range(BUDGET_TRIALS):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters
    power_w = float(parameterization["laser_power_watts"])
    speed_mms = float(parameterization["traverse_speed_mm_per_s"])

    # Run evaluation (replace with real experiment/measurement in production)
    results = evaluate_laser_cut(power_w, speed_mms)

    # Report results (with noise/SEM) back to Ax
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve best found settings
try:
    best_parameters, best_values = ax_client.get_best_parameters()
    print("Best parameters found:")
    for k, v in best_parameters.items():
        print(f"  {k}: {v}")
    print("Best objective (posterior):", best_values)
except Exception as e:
    print("Could not compute best parameters:", e)

# Plot optimization trace
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

# Extract observed means for the objective
y = df[objectives[0]].to_numpy()
t = np.arange(len(y))

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(t, y, ec="k", fc="none", label="Observed")
ax.plot(t, np.minimum.accumulate(y), color="#0033FF", lw=2, label="Best to Trial")
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])
ax.set_title("Laser Cutting: Edge Roughness Optimization")
ax.legend()
plt.tight_layout()
plt.show()