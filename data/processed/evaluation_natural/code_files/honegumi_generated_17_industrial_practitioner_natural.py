# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    return y


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Laser cutting parameter optimization using Ax Platform
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Random generator for reproducible noisy measurements (set to None for different runs)
RNG = np.random.default_rng(seed=42)


def evaluate_edge_roughness(laser_power_watts: float, traverse_speed_mm_s: float) -> dict:
    """
    Evaluate edge roughness (in micrometers) for given laser cutting parameters.

    Domain notes:
    - Smooth edges typically occur around a suitable energy-per-length ratio (J/mm = W / (mm/s)).
    - Too little energy (under-cut) or too much energy (over-melt) increases roughness.
    - Noise is present due to process variability (focus drift, material heterogeneity, etc.).

    This function is a realistic stub that simulates the process with a physics-inspired model.
    Replace with actual measurement or simulation calls in production.

    TODO: Replace with actual evaluation logic:
      - Run a cut with the given power and speed
      - Measure edge roughness Ra or Rz in micrometers
      - Return as {"edge_roughness_micrometers": measured_value}

    Returns:
        dict: {"edge_roughness_micrometers": float}
    """
    # Nominal optimal region for a typical fiber laser cutting thin steel (example)
    optimal_energy_j_per_mm = 80.0  # J/mm
    optimal_power_w = 2000.0        # W
    optimal_speed_mm_s = 25.0       # mm/s

    # Compute energy per unit length
    energy_j_per_mm = laser_power_watts / max(traverse_speed_mm_s, 1e-6)

    # Base smoothness (lower is better)
    base_roughness = 2.0  # micrometers

    # Penalize deviation from optimal energy density (log-quadratic to be scale-aware)
    energy_dev = np.log(max(energy_j_per_mm, 1e-6) / optimal_energy_j_per_mm)
    energy_penalty = 6.0 * (energy_dev ** 2)

    # Additional mild penalties for deviating from typical good setpoints
    power_penalty = 0.000002 * (laser_power_watts - optimal_power_w) ** 2
    speed_penalty = 0.004 * (traverse_speed_mm_s - optimal_speed_mm_s) ** 2

    # Hard penalty for severe under/over energy where the cut is often poor
    severe_low = energy_j_per_mm < 40.0
    severe_high = energy_j_per_mm > 160.0
    severe_penalty = 20.0 if (severe_low or severe_high) else 0.0

    # Aggregate deterministic component
    roughness = base_roughness + energy_penalty + power_penalty + speed_penalty + severe_penalty

    # Heteroskedastic noise: more variability away from the optimum
    noise_sd = 0.1 + 0.01 * abs(energy_j_per_mm - optimal_energy_j_per_mm) / optimal_energy_j_per_mm
    noise = float(RNG.normal(0.0, noise_sd))

    roughness_noisy = max(0.1, roughness + noise)  # ensure positive

    return {"edge_roughness_micrometers": float(roughness_noisy)}


# Initialize Ax client and define experiment
ax_client = AxClient()

# Define search space: laser power (W) and traverse speed (mm/s)
# Adjust bounds to your machine/material capabilities as needed.
ax_client.create_experiment(
    parameters=[
        {"name": "laser_power_watts", "type": "range", "bounds": [500.0, 4000.0]},
        {"name": "traverse_speed_mm_s", "type": "range", "bounds": [5.0, 100.0]},
    ],
    objectives={
        "edge_roughness_micrometers": ObjectiveProperties(minimize=True),
    },
)

# Run optimization loop with a budget of 30 trials
budget_trials = 30

observed_power = []
observed_speed = []
observed_roughness = []

for _ in range(budget_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    power_w = float(parameterization["laser_power_watts"])
    speed_mm_s = float(parameterization["traverse_speed_mm_s"])

    try:
        results = evaluate_edge_roughness(power_w, speed_mm_s)
        ax_client.complete_trial(trial_index=trial_index, raw_data=results)

        observed_power.append(power_w)
        observed_speed.append(speed_mm_s)
        observed_roughness.append(results["edge_roughness_micrometers"])
    except Exception as e:
        # If an evaluation fails, mark the trial as failed and continue
        ax_client.log_trial_failure(trial_index=trial_index)
        print(f"Trial {trial_index} failed during evaluation: {e}")

# Retrieve best parameters
best_parameters, best_metrics = ax_client.get_best_parameters()

best_mean = best_metrics["edge_roughness_micrometers"]["mean"]
best_sem = best_metrics["edge_roughness_micrometers"]["sem"]
print("Best parameters found:")
print(f"  laser_power_watts: {best_parameters['laser_power_watts']:.3f} W")
print(f"  traverse_speed_mm_s: {best_parameters['traverse_speed_mm_s']:.3f} mm/s")
print("Best observed edge roughness:")
print(f"  {best_mean:.3f} Â± {best_sem:.3f} micrometers")

# Visualization: objective value over trials
objective_name = "edge_roughness_micrometers"
df = ax_client.get_trials_data_frame()
df_valid = df[[objective_name]].dropna()
trial_indices = df_valid.index.to_numpy()
y_vals = df_valid[objective_name].to_numpy()
best_so_far = np.minimum.accumulate(y_vals)

fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
ax.scatter(trial_indices, y_vals, ec="k", fc="none", label="Observed")
ax.plot(trial_indices, best_so_far, color="#0033FF", lw=2, label="Best so far")
ax.set_xlabel("Trial Number")
ax.set_ylabel("Edge Roughness (micrometers)")
ax.set_title("Laser Cutting: Edge Roughness over Trials")
ax.legend()
plt.tight_layout()
plt.show()

# Visualization: parameter space colored by observed roughness
if observed_power and observed_speed and observed_roughness:
    fig2, ax2 = plt.subplots(figsize=(5.5, 5), dpi=150)
    sc = ax2.scatter(
        observed_speed,
        observed_power,
        c=observed_roughness,
        cmap="viridis_r",
        s=60,
        edgecolor="k",
    )
    cbar = plt.colorbar(sc, ax=ax2)
    cbar.set_label("Edge Roughness (micrometers)")
    ax2.set_xlabel("Traverse Speed (mm/s)")
    ax2.set_ylabel("Laser Power (W)")
    ax2.set_title("Observed Cuts in Parameter Space")
    plt.tight_layout()
    plt.show()