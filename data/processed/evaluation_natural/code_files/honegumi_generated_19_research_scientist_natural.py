# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    return y


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Optimizing chemical conversion yield with Ax (Bayesian optimization)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from typing import Dict, Any
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Single-objective: maximize product yield (percent)
YIELD_METRIC_NAME = "yield_percent"

# Random generator for reproducibility and to simulate measurement noise
rng = np.random.default_rng(seed=123)


def evaluate_reaction_yield(
    temperature_celsius: float,
    residence_time_min: float,
    catalyst_loading_wt_pct: float,
) -> float:
    """
    Simulate measuring chemical conversion yield (%) for given operating conditions.

    Replace this with your real evaluation logic, for example:
    - Run the physical experiment and record GC/HPLC yield (%)
    - Call a reactor simulation / kinetic model
    - Query a lab data acquisition system API

    Notes on this stub:
    - Produces a smooth response surface with a single broad optimum.
    - Adds Gaussian measurement noise (~2% absolute).
    - Clamps yield to [0, 100] percent.
    """

    T = float(temperature_celsius)
    t = float(residence_time_min)
    c = float(catalyst_loading_wt_pct)

    # A physically plausible surrogate surface:
    # Peak near T≈140 C, t≈40 min, c≈1.6 wt%
    # Gaussian-like bumps for each factor plus mild penalties for excessive T or catalyst.
    bump_T = np.exp(-((T - 140.0) / 18.0) ** 2)
    bump_t = np.exp(-((np.log(t) - np.log(40.0)) / 0.4) ** 2)
    bump_c = np.exp(-((c - 1.6) / 0.6) ** 2)

    base_yield = 10.0 + 90.0 * bump_T * bump_t * bump_c

    # Mild penalties for conditions that encourage side-reactions or coking
    def sigmoid(x: float, s: float = 2.0) -> float:
        return 1.0 / (1.0 + np.exp(-x / s))

    penalty_factor = 1.0 - 0.15 * sigmoid(T - 170.0) - 0.10 * sigmoid(c - 3.5)
    simulated_yield = base_yield * penalty_factor

    # Add measurement noise (absolute ±2% typical)
    noisy_yield = simulated_yield + rng.normal(loc=0.0, scale=2.0)

    # Clamp to [0, 100]
    return float(np.clip(noisy_yield, 0.0, 100.0))


# Initialize Ax client
ax_client = AxClient()

# Define search space: three process parameters
ax_client.create_experiment(
    parameters=[
        {
            "name": "temperature_celsius",
            "type": "range",
            "bounds": [80.0, 200.0],
        },
        {
            "name": "residence_time_min",
            "type": "range",
            "bounds": [5.0, 120.0],
        },
        {
            "name": "catalyst_loading_wt_pct",
            "type": "range",
            "bounds": [0.1, 5.0],
        },
    ],
    objectives={
        YIELD_METRIC_NAME: ObjectiveProperties(minimize=False),
    },
)

# Budgeted campaign: 35 experiments
N_TRIALS = 35

for _ in range(N_TRIALS):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters
    T = parameterization["temperature_celsius"]
    t = parameterization["residence_time_min"]
    c = parameterization["catalyst_loading_wt_pct"]

    try:
        # Run your experiment here and measure yield (%)
        yield_pct = evaluate_reaction_yield(T, t, c)

        # Report observation to Ax. Passing a float signals a noisy observation by default.
        ax_client.complete_trial(trial_index=trial_index, raw_data=yield_pct)
    except Exception:
        # Mark the trial as failed if evaluation crashes
        ax_client.log_trial_failure(trial_index=trial_index)

# Retrieve best-found parameters and corresponding metric
best_parameters, best_metrics = ax_client.get_best_parameters()

# Prepare results DataFrame
df = ax_client.get_trials_data_frame()

# Plot observed yields and best-so-far yield over trials
objective_name = ax_client.objective_names[0]
trial_numbers = np.arange(len(df))
y_obs = df[objective_name].astype(float).to_numpy()

fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
ax.scatter(trial_numbers, y_obs, ec="k", fc="none", label="Observed yield")
ax.plot(trial_numbers, np.maximum.accumulate(y_obs), color="#0033FF", lw=2, label="Best to trial")
ax.set_xlabel("Trial number")
ax.set_ylabel("Yield (%)")
ax.set_title("Bayesian optimization of chemical conversion yield")
ax.legend()
plt.tight_layout()
plt.show()