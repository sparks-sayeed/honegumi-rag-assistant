# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Problem: Optimize chemical conversion yield by tuning three process parameters
# Parameters:
#   - temperature_celsius (continuous): Reactor temperature in degrees Celsius
#   - residence_time_minutes (continuous): Residence time in minutes
#   - catalyst_loading_wt_percent (continuous): Catalyst mass fraction in wt%
#
# Objective:
#   - yield_percent (maximize): Reaction yield in percent [%]
#
# Experimental budget: 35 trials
# Noise model: True (evaluation includes realistic measurement noise)
#
# Note: Replace the evaluation function below with actual lab measurement or a high-fidelity
# simulator as needed. The provided function is a physically plausible surrogate with noise.


# Reproducible RNG for simulated measurement noise
_rng = np.random.default_rng(2025)


def evaluate_chemical_conversion(
    temperature_celsius: float,
    residence_time_minutes: float,
    catalyst_loading_wt_percent: float,
) -> float:
    """Simulate chemical conversion yield [%] given process conditions.

    This is a realistic stub capturing:
      - Temperature-dependent rate and selectivity (too cold: slow, too hot: side reactions)
      - Time-dependent conversion saturation
      - Catalyst loading with diminishing returns and an optimum before selectivity drops
      - Additive measurement noise (Gaussian) to reflect a noisy experimental setting

    TODO: Replace with actual experimental measurement logic:
      - Run the experiment at the specified conditions
      - Measure yield (in percent, 0-100)
      - Return the measured yield as a float

    Returns:
      Yield percent in [0, 100].
    """
    # Selectivity: peak around an optimal temperature and moderate catalyst loading
    t_opt = 85.0  # deg C
    t_sigma = 15.0  # controls how quickly selectivity falls off away from optimum
    s_temp = np.exp(-0.5 * ((temperature_celsius - t_opt) / t_sigma) ** 2)

    cat_opt = 2.0  # wt%
    cat_sigma = 1.5
    s_cat = np.exp(-0.5 * ((catalyst_loading_wt_percent - cat_opt) / cat_sigma) ** 2)

    # Combine selectivity effects; ensure not too punitive by adding a modest baseline
    selectivity = np.clip(s_temp * s_cat, 0.0, 1.0)

    # Kinetics: temperature accelerates rate; catalyst contributes with diminishing returns
    k_base = 0.03  # 1/min baseline rate constant scaling
    temp_rate_factor = np.exp(0.035 * (temperature_celsius - 60.0))  # ~3.5%/C sensitivity
    cat_rate_factor = 1.0 - np.exp(-1.2 * catalyst_loading_wt_percent)  # saturating with loading
    # Ensure some baseline rate even at very low catalyst
    k_eff = k_base * temp_rate_factor * (0.3 + 0.7 * cat_rate_factor)

    # Time dependence: saturation toward asymptote with effective rate constant
    conversion = 1.0 - np.exp(-k_eff * max(residence_time_minutes, 0.0))
    conversion = np.clip(conversion, 0.0, 1.0)

    # Maximum attainable yield fraction (accounting for thermodynamic/stoichiometric limits)
    max_yield_fraction = 0.98

    yield_fraction = max_yield_fraction * selectivity * conversion

    # Add realistic measurement/process noise (~1% absolute std in yield)
    noise_sd_fraction = 0.01
    noisy_yield_fraction = yield_fraction + _rng.normal(0.0, noise_sd_fraction)

    # Convert to percent and clamp to physical bounds [0, 100]
    yield_percent = float(np.clip(noisy_yield_fraction * 100.0, 0.0, 100.0))
    return yield_percent


# Set up Ax optimization
ax_client = AxClient(random_seed=123)

ax_client.create_experiment(
    name="chemical_conversion_yield_optimization",
    parameters=[
        {
            "name": "temperature_celsius",
            "type": "range",
            "bounds": [40.0, 120.0],
            "value_type": "float",
        },
        {
            "name": "residence_time_minutes",
            "type": "range",
            "bounds": [1.0, 120.0],
            "value_type": "float",
        },
        {
            "name": "catalyst_loading_wt_percent",
            "type": "range",
            "bounds": [0.1, 5.0],
            "value_type": "float",
        },
    ],
    objectives={
        "yield_percent": ObjectiveProperties(minimize=False),
    },
)

# Run optimization for the planned budget of 35 experiments
n_trials = 35
for _ in range(n_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters
    temp_c = float(parameterization["temperature_celsius"])
    time_min = float(parameterization["residence_time_minutes"])
    cat_wt = float(parameterization["catalyst_loading_wt_percent"])

    # Evaluate experiment (replace with actual measurement in production)
    try:
        measured_yield = evaluate_chemical_conversion(
            temperature_celsius=temp_c,
            residence_time_minutes=time_min,
            catalyst_loading_wt_percent=cat_wt,
        )
        ax_client.complete_trial(trial_index=trial_index, raw_data=measured_yield)
    except Exception as e:
        # If a run fails (instrument error, etc.), record failure and continue
        ax_client.log_trial_failure(trial_index=trial_index)
        print(f"Trial {trial_index} failed with error: {e}")

# Best found parameters and associated metric
best_parameters, best_metrics = ax_client.get_best_parameters()
print("Best Parameters Found:")
for k, v in best_parameters.items():
    print(f"  {k}: {v}")
print("Best Metrics:")
print(best_metrics)

# Plot results
objective_name = ax_client.objective_names[0]
df = ax_client.get_trials_data_frame()

# Ensure the DataFrame contains the objective column
if objective_name not in df.columns:
    raise RuntimeError(f"Objective column '{objective_name}' not found in trials DataFrame.")

y_vals = df[objective_name].astype(float).values
trial_numbers = df.index.values
best_so_far = np.maximum.accumulate(y_vals)

fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
ax.scatter(trial_numbers, y_vals, ec="k", fc="none", label="Observed yield (%)")
ax.plot(trial_numbers, best_so_far, color="#0033FF", lw=2, label="Best to date")
ax.set_xlabel("Trial number")
ax.set_ylabel("Yield (%)")
ax.set_title("Chemical Conversion Yield Optimization (Ax)")
ax.legend()
plt.tight_layout()
plt.show()