# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"
obj2_name = "branin_swapped"


def branin_moo(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # second objective has x1 and x2 swapped
    y2 = float(
        (x1 - 5.1 / (4 * np.pi**2) * x2**2 + 5.0 / np.pi * x2 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x2)
        + 10
    )

    return {obj1_name: y, obj2_name: y2}


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
        obj2_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        "1.0*x1 + 0.5*x2 <= 15.0",  # example of a linear constraint. Note the lack of space around the asterisks
    ],
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin_moo(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)
pareto_results = ax_client.get_pareto_optimal_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto[objectives[0]],
    pareto[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])

ax.legend()
plt.show()

# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from typing import Dict, Tuple

from ax.service.ax_client import AxClient, ObjectiveProperties


# Domain-specific objective names
OBJ_BINDING = "target_binding_affinity"  # higher is better
OBJ_SOLUBILITY = "aqueous_solubility"    # higher is better
OBJ_TOXICITY = "predicted_toxicity"      # lower is better


def _sigmoid(z: np.ndarray) -> np.ndarray:
    return 1.0 / (1.0 + np.exp(-z))


def evaluate_candidate_molecule(molecular_weight: float, logP: float, rng: np.random.RandomState) -> Dict[str, Tuple[float, float]]:
    """
    Domain-specific surrogate for experimental evaluation of a small-molecule candidate.

    This function produces realistically-behaving synthetic measurements for:
    - target_binding_affinity: proxy for potency/affinity (higher is better)
    - aqueous_solubility: proxy for solubility (higher is better)
    - predicted_toxicity: proxy for toxicity risk (lower is better)

    The relationships encode common medicinal chemistry heuristics:
    - Binding affinity tends to improve with increased hydrophobicity (logP) and size (MW) up to a point,
      then deteriorates due to poor ADME or steric effects. We model a 2D "sweet spot" around MW ~ 350, logP ~ 2.5.
    - Solubility decreases with increasing logP and increasing MW.
    - Toxicity risk tends to increase with lipophilicity and higher MW, with sharper rise at very high logP.

    Returns mean values with unknown SEM (set to None) to enable Ax to infer noise.
    """
    # Binding affinity (dimensionless score ~ 0..3), "sweet spot" near (MW=350, logP=2.5)
    binding_core = np.exp(-((molecular_weight - 350.0) / 120.0) ** 2 - ((logP - 2.5) / 1.2) ** 2)
    binding_shape = 2.5 * binding_core
    # Minor monotonic contribution from moderate lipophilicity (optimal around logP ~ 2)
    binding_lipo_boost = 0.3 * np.exp(-((logP - 2.0) / 1.5) ** 2)
    target_binding_affinity = binding_shape + binding_lipo_boost

    # Aqueous solubility (arbitrary units ~ 0..2), higher for lower MW and lower logP
    sol_mw_component = _sigmoid(-(molecular_weight - 300.0) / 100.0)
    sol_logp_component = _sigmoid(-(logP - 1.0) * 1.2)
    aqueous_solubility = 1.6 * sol_mw_component * sol_logp_component

    # Predicted toxicity risk (dimensionless ~ 0..2.5), lower is better
    tox_lipo = 0.7 * _sigmoid((logP - 2.0) * 1.0)
    tox_mw = 0.6 * _sigmoid((molecular_weight - 350.0) / 90.0)
    tox_high_logp_penalty = 0.7 * _sigmoid((logP - 4.0) * 2.0)  # sharper rise when logP > 4
    predicted_toxicity = tox_lipo + tox_mw + tox_high_logp_penalty

    # Add realistic measurement noise and clamp to valid ranges
    target_binding_affinity = max(0.0, target_binding_affinity + rng.normal(0.0, 0.05))
    aqueous_solubility = max(0.0, aqueous_solubility + rng.normal(0.0, 0.05))
    predicted_toxicity = max(0.0, predicted_toxicity + rng.normal(0.0, 0.03))

    # Return mean with unknown SEM so Ax infers noise
    return {
        OBJ_BINDING: (float(target_binding_affinity), None),
        OBJ_SOLUBILITY: (float(aqueous_solubility), None),
        OBJ_TOXICITY: (float(predicted_toxicity), None),
    }


def compute_pareto_mask(values: np.ndarray) -> np.ndarray:
    """
    Compute Pareto-optimal mask for points where higher is better for all objectives.
    values: shape (N, M), each column is an objective to maximize.
    Returns boolean mask of length N indicating Pareto-optimal points.
    """
    n_points = values.shape[0]
    is_efficient = np.ones(n_points, dtype=bool)
    for i in range(n_points):
        if not is_efficient[i]:
            continue
        # A point j dominates i if j >= i for all metrics and any strictly greater
        dominates = np.all(values >= values[i], axis=1) & np.any(values > values[i], axis=1)
        dominates[i] = False
        if np.any(dominates):
            is_efficient[i] = False
    return is_efficient


def plot_pairwise_with_pareto(results_df: pd.DataFrame, binding_col: str, solubility_col: str, toxicity_col: str) -> None:
    """
    Plot pairwise scatter of:
    - Binding vs Solubility (color by toxicity)
    and highlight Pareto-optimal points in 3-objective space
    (maximize binding, maximize solubility, minimize toxicity).
    """
    # Prepare wide DataFrame with one row per trial and columns for metrics and parameters
    pvt = results_df.pivot_table(
        index=["trial_index", "arm_name", "molecular_weight", "logP"],
        columns="metric_name",
        values="mean",
        aggfunc="last",
    ).reset_index()

    # Drop rows with any missing objective
    required_cols = [binding_col, solubility_col, toxicity_col]
    pvt = pvt.dropna(subset=required_cols)

    if pvt.empty:
        print("No complete observations to plot yet.")
        return

    # For Pareto with mixed directions, convert to all-maximization by negating toxicity
    obj_matrix = np.column_stack([pvt[binding_col].values, pvt[solubility_col].values, -pvt[toxicity_col].values])
    pareto_mask = compute_pareto_mask(obj_matrix)

    # Scatter: Binding vs Solubility, color by toxicity
    fig, ax = plt.subplots(figsize=(7, 5), dpi=150)
    sc = ax.scatter(
        pvt[binding_col],
        pvt[solubility_col],
        c=pvt[toxicity_col],
        cmap="viridis_r",
        edgecolors="k",
        alpha=0.7,
        label="Observed",
    )
    # Highlight Pareto points
    ax.scatter(
        pvt.loc[pareto_mask, binding_col],
        pvt.loc[pareto_mask, solubility_col],
        facecolors="none",
        edgecolors="#FF3333",
        s=80,
        linewidths=1.5,
        label="Pareto-optimal",
    )
    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label(toxicity_col)
    ax.set_xlabel(binding_col)
    ax.set_ylabel(solubility_col)
    ax.set_title("Binding vs Solubility (color: Toxicity)")
    ax.legend(loc="best")
    plt.tight_layout()
    plt.show()


def main():
    rng = np.random.RandomState(42)

    ax_client = AxClient()

    # Create experiment: drug-like search space with MW <= 500 and reasonable logP
    ax_client.create_experiment(
        name="drug_discovery_moo",
        parameters=[
            {
                "name": "molecular_weight",
                "type": "range",
                "bounds": [0.0, 500.0],  # drug-like space upper bound
                "value_type": "float",
            },
            {
                "name": "logP",
                "type": "range",
                "bounds": [-1.0, 5.0],  # reasonable drug-like lipophilicity range
                "value_type": "float",
            },
        ],
        objectives={
            OBJ_BINDING: ObjectiveProperties(minimize=False),  # maximize binding
            OBJ_SOLUBILITY: ObjectiveProperties(minimize=False),  # maximize solubility
            OBJ_TOXICITY: ObjectiveProperties(minimize=True),  # minimize toxicity
        },
        parameter_constraints=[
            "1.0*molecular_weight <= 500.0",
            "1.0*logP <= 5.0",
            "-1.0*logP <= 1.0",  # equivalent to logP >= -1.0
        ],
    )

    # Budget: 50 sequential trials
    NUM_TRIALS = 50
    for _ in range(NUM_TRIALS):
        parameterization, trial_index = ax_client.get_next_trial()

        mw = float(parameterization["molecular_weight"])
        lp = float(parameterization["logP"])

        results = evaluate_candidate_molecule(mw, lp, rng)
        ax_client.complete_trial(trial_index=trial_index, raw_data=results)

    # Retrieve Pareto-optimal parameterizations based on observed data
    pareto_obs = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
    print(f"Found {len(pareto_obs)} Pareto-optimal candidates (observed):")
    for i, (arm_name, (params, metrics)) in enumerate(pareto_obs.items(), start=1):
        metrics_summary = ", ".join(
            f"{k}={v[0]:.3f}" if isinstance(v, tuple) else f"{k}={v:.3f}" for k, v in metrics.items()
        )
        print(f"{i:2d}. {params} => {metrics_summary}")

    # Plot pairwise tradeoff with Pareto highlight
    df = ax_client.get_trials_data_frame()
    plot_pairwise_with_pareto(
        results_df=df,
        binding_col=OBJ_BINDING,
        solubility_col=OBJ_SOLUBILITY,
        toxicity_col=OBJ_TOXICITY,
    )


if __name__ == "__main__":
    main()