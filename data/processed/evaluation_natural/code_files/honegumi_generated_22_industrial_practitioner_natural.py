# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Problem: Optimize spray parameters for uniform coating thickness.
# Parameters:
#   - spray_distance_mm: distance from nozzle to surface in millimeters
#   - spray_pressure_bar: atomizing air pressure at the gun in bar
# Objective:
#   - Minimize coating_thickness_variation_microns_std: standard deviation of coating thickness across the panel (microns)
# Trial budget: 25 (noisy measurements)

objective_metric_name = "coating_thickness_variation_microns_std"

# Reproducible noise for the synthetic evaluation stub
rng = np.random.default_rng(12345)


def evaluate_coating_uniformity(spray_distance_mm: float, spray_pressure_bar: float) -> float:
    """
    Simulated evaluation of coating thickness uniformity.
    Returns the standard deviation of coating thickness across the panel in microns (lower is better).

    This stub captures typical behavior:
    - There is an optimal distance and pressure for uniform atomization and deposition.
    - Too close + high pressure -> bounce-back and uneven film.
    - Too far -> dry spray and uneven coverage.
    - Too low pressure -> poor atomization and mottling.

    TODO: Replace with actual measurement logic in production:
      - Run a spray test at the given distance and pressure
      - Measure thickness at multiple points and compute std in microns
      - Return that measured std as a float
    """
    d = float(spray_distance_mm)
    p = float(spray_pressure_bar)

    # Hypothetical optimum
    d0 = 200.0  # mm
    p0 = 1.8    # bar

    # Sensitivity scales (how quickly variation grows away from optimum)
    sd_d = 50.0   # mm
    sd_p = 0.35   # bar

    # Base variation at the optimum (microns std)
    base = 5.0

    # Quadratic bowl around optimum
    bowl = ((d - d0) / sd_d) ** 2 + ((p - p0) / sd_p) ** 2

    # Interaction: close distance with high pressure increases unevenness (bounce-back)
    interaction = 0.8 * np.tanh((200.0 - d) / 60.0) * np.tanh((p - p0) / 0.3)

    # Far distance penalty: dry spray when d is large
    far_penalty = 1.2 / (1.0 + np.exp(-(d - 260.0) / 12.0))

    # Low pressure penalty: poor atomization when pressure is low
    low_p_penalty = 1.0 / (1.0 + np.exp(-(1.3 - p) / 0.08))

    # Combine effects
    mean_std = base + 3.5 * bowl + 2.0 * far_penalty + 1.5 * low_p_penalty + 1.0 * interaction
    mean_std = float(max(0.5, mean_std))  # guard against negative

    # Measurement noise to reflect real-world variability
    noise = float(rng.normal(0.0, 0.4))
    observed_std = max(0.1, mean_std + noise)

    return observed_std


# Set up Ax optimization client
ax_client = AxClient()

# Define experiment with realistic ranges for spray application
ax_client.create_experiment(
    parameters=[
        {
            "name": "spray_distance_mm",
            "type": "range",
            "bounds": [100.0, 300.0],  # 10–30 cm typical working distance
        },
        {
            "name": "spray_pressure_bar",
            "type": "range",
            "bounds": [1.0, 3.0],  # typical HVLP atomization pressure range
        },
    ],
    objectives={
        objective_metric_name: ObjectiveProperties(minimize=True),
    },
)

# Run optimization for the available budget of 25 trials
num_trials = 25
for _ in range(num_trials):
    params, trial_index = ax_client.get_next_trial()

    # Extract parameters
    spray_distance_mm = params["spray_distance_mm"]
    spray_pressure_bar = params["spray_pressure_bar"]

    # Evaluate (replace with actual experiment/measurement in production)
    result_value = evaluate_coating_uniformity(spray_distance_mm, spray_pressure_bar)

    # Report result back to Ax
    ax_client.complete_trial(trial_index=trial_index, raw_data=result_value)

# Query best found parameters and outcome
best_parameters, best_metrics = ax_client.get_best_parameters()

print("Best spray settings found:")
print(f"  spray_distance_mm: {best_parameters['spray_distance_mm']:.2f} mm")
print(f"  spray_pressure_bar: {best_parameters['spray_pressure_bar']:.3f} bar")
print("Best observed objective:")
for metric_name, metric_info in best_metrics.items():
    # metric_info has fields: "mean" and "sem" if available
    mean_val = metric_info["mean"]
    sem_val = metric_info.get("sem", None)
    if sem_val is not None:
        print(f"  {metric_name}: {mean_val:.3f} ± {sem_val:.3f} (microns std)")
    else:
        print(f"  {metric_name}: {mean_val:.3f} (microns std)")

# Plot progress over trials
df = ax_client.get_trials_data_frame()
df_sorted = df.sort_values(by="trial_index")
trial_numbers = df_sorted["trial_index"].to_numpy()
y_vals = df_sorted[objective_metric_name].to_numpy()
cum_best = np.minimum.accumulate(y_vals)

fig, ax = plt.subplots(figsize=(7, 4.5), dpi=150)
ax.scatter(trial_numbers, y_vals, ec="k", fc="none", label="Observed")
ax.plot(trial_numbers, cum_best, color="#0033FF", lw=2, label="Best so far")
ax.set_xlabel("Trial Number")
ax.set_ylabel("Coating thickness std (microns) - lower is better")
ax.set_title("Optimization of Spray Distance and Pressure for Uniform Coating")
ax.grid(alpha=0.2)
ax.legend()
plt.tight_layout()
plt.show()