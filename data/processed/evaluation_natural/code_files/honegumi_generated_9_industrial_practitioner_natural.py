# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin3(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    return y


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
        "x1 <= x2",  # example of an order constraint
    ],
)


for i in range(21):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]
    x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

    results = branin3(x1, x2, x3)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Generated for optimizing high-strength concrete mix with Ax Platform
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


objective_name = "compressive_strength_mpa"


def evaluate_concrete_compressive_strength(
    cement_fraction: float,
    water_fraction: float,
    aggregate_fraction: float,
    rng: np.random.Generator,
) -> float:
    """
    Simulate compressive strength (MPa) of a concrete mix given fractions of
    cement, water, and aggregate that sum to 1.0.

    Model rationale:
    - Strength primarily depends on water-to-cement ratio (w/c): lower w/c
      generally yields higher strength, but there are practical bounds.
    - Cement paste content should not be too low or too high; moderate cement
      fraction yields stronger, well-bonded matrix.
    - Aggregate skeleton quality influences strength; moderate-high aggregate
      fraction with good packing is beneficial.

    Returns:
        float: Simulated compressive strength in MPa (includes measurement noise).
    """
    # Guard against division by zero in w/c; penalize mixes with negligible cement
    if cement_fraction <= 1e-6:
        base_strength = 2.0  # essentially no binding paste, near-zero strength
    else:
        w_c = water_fraction / cement_fraction
        # Core inverse-like relationship between strength and w/c
        # Calibrated to yield realistic strengths:
        # ~80 MPa around w/c ~ 0.25–0.35, ~40–50 MPa around w/c ~ 0.5
        base_strength = 200.0 / (1.0 + 6.0 * max(w_c, 1e-3))

    # Cement fraction influence: peak around ~0.22 with gentle falloff
    cement_peak = np.exp(-((cement_fraction - 0.22) / 0.08) ** 2)
    cement_multiplier = 0.8 + 0.4 * cement_peak  # between ~0.8 and 1.2

    # Aggregate skeleton influence: peak around ~0.65 with moderate width
    aggregate_peak = np.exp(-((aggregate_fraction - 0.65) / 0.10) ** 2)
    aggregate_multiplier = 0.9 + 0.2 * aggregate_peak  # between ~0.9 and 1.1

    # Penalize extreme w/c for workability/defect issues (very high or very low)
    if cement_fraction > 1e-6:
        w_c = water_fraction / cement_fraction
        workability_penalty = 1.0
        if w_c > 0.60:
            workability_penalty *= np.exp(-5.0 * (w_c - 0.60))  # sharp drop
        if w_c < 0.22:
            workability_penalty *= np.exp(-10.0 * (0.22 - w_c))  # too dry
    else:
        workability_penalty = 0.2

    strength = base_strength * cement_multiplier * aggregate_multiplier * workability_penalty

    # Add measurement/process noise (~2 MPa std dev)
    strength += rng.normal(0.0, 2.0)

    # Ensure non-negative
    strength = float(max(strength, 0.0))
    return strength


# Fractions sum to 1.0: cement_fraction + water_fraction + aggregate_fraction == 1.0
total_fraction = 1.0

# Random generator for reproducibility of the noisy evaluation
rng = np.random.default_rng(12345)

ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "cement_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "water_fraction", "type": "range", "bounds": [0.0, 1.0]},
        # aggregate_fraction is computed via composition: 1 - (cement + water)
    ],
    objectives={
        objective_name: ObjectiveProperties(minimize=False),
    },
    parameter_constraints=[
        # Composition (reparameterized): cement + water <= 1.0 (aggregate = 1 - (cement + water) >= 0)
        f"cement_fraction + water_fraction <= {total_fraction}",
        # Domain knowledge/order constraints:
        # cement >= water
        "water_fraction <= cement_fraction",
        # aggregate >= cement  -> 1 - (cement + water) >= cement -> 2*cement + water <= 1
        "2*cement_fraction + water_fraction <= 1.0",
        # aggregate >= water   -> 1 - (cement + water) >= water  -> cement + 2*water <= 1
        "cement_fraction + 2*water_fraction <= 1.0",
    ],
)

# Run up to 20 experimental trials (budget)
for _ in range(20):
    parameterization, trial_index = ax_client.get_next_trial()

    cement_fraction = float(parameterization["cement_fraction"])
    water_fraction = float(parameterization["water_fraction"])
    aggregate_fraction = float(total_fraction - (cement_fraction + water_fraction))

    # Safety clamp aggregate in case of tiny numerical drift
    aggregate_fraction = max(min(aggregate_fraction, 1.0), 0.0)

    strength_mpa = evaluate_concrete_compressive_strength(
        cement_fraction=cement_fraction,
        water_fraction=water_fraction,
        aggregate_fraction=aggregate_fraction,
        rng=rng,
    )

    # Report result (noisy observation)
    ax_client.complete_trial(trial_index=trial_index, raw_data=strength_mpa)

best_parameters, best_metrics = ax_client.get_best_parameters()

# Plot results
objective_names = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objective_names[0]], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.maximum.accumulate(df[objective_names[0]]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel("Compressive Strength (MPa)")
ax.legend()
plt.show()

print("Best mix found:")
print(best_parameters)
print("Best observed compressive strength (MPa):", best_metrics[objective_names[0]].mean)