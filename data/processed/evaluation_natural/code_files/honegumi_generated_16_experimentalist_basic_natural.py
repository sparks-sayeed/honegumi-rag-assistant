# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain-specific objective names
TEXTURE_METRIC = "texture_score"
TASTE_METRIC = "taste_score"

# Ingredient parameter names (fractions must sum to 1.0)
PROTEIN = "protein_powder_frac"
NUT_BUTTER = "nut_butter_frac"
SWEETENER = "sweetener_syrup_frac"
OAT_FLOUR = "oat_flour_frac"  # Derived as residual: 1 - (protein + nut_butter + sweetener)

rng = np.random.default_rng(seed=42)


def _sigmoid(x: float, center: float, k: float) -> float:
    return 1.0 / (1.0 + np.exp(-k * (x - center)))


def evaluate_protein_bar_recipe(
    protein_powder_frac: float,
    nut_butter_frac: float,
    sweetener_syrup_frac: float,
    oat_flour_frac: float,
) -> dict:
    """
    Simulated evaluation of a protein bar recipe that returns texture and taste scores.
    - All inputs are fractions that sum to 1.0 (composition constraint).
    - Scores are on a 0-100 scale (higher is better), with small observation noise.

    Replace this function with actual lab/kitchen measurements by:
      1) Preparing the bar using the provided fractions.
      2) Assigning human panel or instrument scores for texture and taste.
      3) Returning the measured means and their standard errors instead of simulated values.
    """

    # Targets (approximate "good" ratios) for texture balance
    targets = {
        PROTEIN: 0.27,
        NUT_BUTTER: 0.22,
        SWEETENER: 0.18,
        OAT_FLOUR: 0.33,
    }
    weights = {
        PROTEIN: 0.9,
        NUT_BUTTER: 0.7,
        SWEETENER: 0.6,
        OAT_FLOUR: 0.8,
    }

    # Quadratic deviation penalty from targets for texture
    deviations = {
        PROTEIN: (protein_powder_frac - targets[PROTEIN]) / max(targets[PROTEIN], 1e-6),
        NUT_BUTTER: (nut_butter_frac - targets[NUT_BUTTER]) / max(targets[NUT_BUTTER], 1e-6),
        SWEETENER: (sweetener_syrup_frac - targets[SWEETENER]) / max(targets[SWEETENER], 1e-6),
        OAT_FLOUR: (oat_flour_frac - targets[OAT_FLOUR]) / max(targets[OAT_FLOUR], 1e-6),
    }
    quad_penalty = (
        weights[PROTEIN] * deviations[PROTEIN] ** 2
        + weights[NUT_BUTTER] * deviations[NUT_BUTTER] ** 2
        + weights[SWEETENER] * deviations[SWEETENER] ** 2
        + weights[OAT_FLOUR] * deviations[OAT_FLOUR] ** 2
    )

    # Additional penalties capturing common failure modes
    dryness_penalty = 2.0 * max(0.0, protein_powder_frac - 0.32) + 2.0 * max(0.0, oat_flour_frac - 0.38)
    stickiness_penalty = 2.0 * max(0.0, sweetener_syrup_frac - 0.28) + 1.5 * max(0.0, nut_butter_frac - 0.40)

    # Texture score: high when close to targets and not too dry/sticky
    texture_base = 100.0 * max(0.0, 1.0 - 0.55 * quad_penalty)
    texture_score = texture_base - 30.0 * (dryness_penalty + stickiness_penalty)

    # Taste score: sweetness and nut aroma help; too much protein or oats can reduce palatability
    sweetness_component = _sigmoid(sweetener_syrup_frac, center=0.18, k=20.0)  # 0..1
    nut_component = nut_butter_frac  # linear contribution
    oats_balance_component = max(0.0, 1.0 - abs(oat_flour_frac - 0.30) / 0.30)  # 0..1, best near 0.30

    taste_raw = 100.0 * (0.50 * sweetness_component + 0.35 * nut_component + 0.15 * oats_balance_component)
    taste_penalties = (
        40.0 * max(0.0, protein_powder_frac - 0.30)
        + 20.0 * max(0.0, oat_flour_frac - 0.45)
        + 20.0 * max(0.0, sweetener_syrup_frac - 0.35)
    )
    taste_score = taste_raw - taste_penalties

    # Clip to 0..100
    texture_score = float(np.clip(texture_score, 0.0, 100.0))
    taste_score = float(np.clip(taste_score, 0.0, 100.0))

    # Add small observational noise and set SEM to reflect uncertainty
    texture_noise = float(rng.normal(0.0, 1.5))
    taste_noise = float(rng.normal(0.0, 1.5))
    texture_measured = float(np.clip(texture_score + texture_noise, 0.0, 100.0))
    taste_measured = float(np.clip(taste_score + taste_noise, 0.0, 100.0))

    # Return means and SEMs (standard errors of the mean)
    return {
        TEXTURE_METRIC: (texture_measured, 1.5),
        TASTE_METRIC: (taste_measured, 1.5),
    }


# Total for compositional constraint: all fractions sum to 1.0
TOTAL_FRACTION = 1.0

ax_client = AxClient()

# We parameterize 3 ingredients directly; the 4th (oat_flour_frac) is computed as the residual.
ax_client.create_experiment(
    name="protein_bar_recipe_optimization",
    parameters=[
        {"name": PROTEIN, "type": "range", "bounds": [0.0, 1.0]},
        {"name": NUT_BUTTER, "type": "range", "bounds": [0.0, 1.0]},
        {"name": SWEETENER, "type": "range", "bounds": [0.0, 1.0]},
    ],
    objectives={
        TEXTURE_METRIC: ObjectiveProperties(minimize=False),
        TASTE_METRIC: ObjectiveProperties(minimize=False),
    },
    parameter_constraints=[
        f"{PROTEIN} + {NUT_BUTTER} + {SWEETENER} <= {TOTAL_FRACTION}",  # ensures oat_flour_frac >= 0
    ],
)

# Budget: 35 trials
N_TRIALS = 35
for _ in range(N_TRIALS):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters
    protein = float(parameterization[PROTEIN])
    nut = float(parameterization[NUT_BUTTER])
    sweet = float(parameterization[SWEETENER])
    oat = float(TOTAL_FRACTION - (protein + nut + sweet))  # composition: sum to 1.0

    # Numerical safety (should be >= 0 due to constraint)
    if oat < -1e-8:
        # In case of numerical issues, fail the trial so it won't be repeated
        ax_client.log_trial_failure(trial_index=trial_index)
        continue

    results = evaluate_protein_bar_recipe(protein, nut, sweet, max(0.0, oat))
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve Pareto-optimal recipes
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

# Prepare a summary of Pareto-optimal recipes with full 4-ingredient compositions
pareto_rows = []
for arm_name, (params, (means, _sems)) in pareto.items():
    protein = float(params.get(PROTEIN, 0.0))
    nut = float(params.get(NUT_BUTTER, 0.0))
    sweet = float(params.get(SWEETENER, 0.0))
    oat = float(TOTAL_FRACTION - (protein + nut + sweet))
    pareto_rows.append(
        {
            "arm_name": arm_name,
            PROTEIN: protein,
            NUT_BUTTER: nut,
            SWEETENER: sweet,
            OAT_FLOUR: max(0.0, oat),
            "sum_check": protein + nut + sweet + max(0.0, oat),
            TEXTURE_METRIC: means[TEXTURE_METRIC],
            TASTE_METRIC: means[TASTE_METRIC],
        }
    )
pareto_df = pd.DataFrame(pareto_rows).sort_values(TEXTURE_METRIC, ascending=False).reset_index(drop=True)
print("Pareto-optimal recipes (top 10 shown):")
print(pareto_df.head(10).to_string(index=False))

# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]  # extract mean outcomes
pareto_plot_df = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto_plot_df[objectives[0]],
    pareto_plot_df[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])
ax.set_title("Protein Bar Optimization: Texture vs Taste")
ax.legend()
plt.tight_layout()
plt.show()