# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from typing import Dict, Tuple
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain: Optimize liquid-based color matching in subtractive RYB model under simplex constraint.
# We minimize the spectral distance (L2 over 8-channel reflectance) between the mixed sample and a target spectrum.

# Random seed for reproducibility of the simulated sensor noise
rng = np.random.default_rng(42)

# 8-channel "visible spectrum" sensor bands (nm), for documentation/plotting only
WAVELENGTHS_NM = np.array([450, 475, 500, 525, 550, 575, 600, 625])

# Base reflectance spectra for Red, Yellow, Blue pigments (subtractive colorants), per 8 channels.
# These are plausible, smooth reflectance profiles (values in [0, 1]).
# In practice, measure these with your multispectral sensor on pure colorant swatches.
REFLECTANCE_RED = np.array([0.10, 0.15, 0.25, 0.40, 0.60, 0.72, 0.82, 0.88])
REFLECTANCE_YELLOW = np.array([0.12, 0.18, 0.65, 0.78, 0.85, 0.90, 0.92, 0.92])
REFLECTANCE_BLUE = np.array([0.82, 0.75, 0.58, 0.40, 0.26, 0.20, 0.16, 0.12])

# Convert reflectance to absorbance (optical density) for subtractive mixing via Beer-Lambert law:
# A = -ln(R), R in (0,1]. Clip to avoid log(0).
EPS = 1e-6
ABSORBANCE_RED = -np.log(np.clip(REFLECTANCE_RED, EPS, 1.0))
ABSORBANCE_YELLOW = -np.log(np.clip(REFLECTANCE_YELLOW, EPS, 1.0))
ABSORBANCE_BLUE = -np.log(np.clip(REFLECTANCE_BLUE, EPS, 1.0))

# Define a reachable target spectrum by mixing the base colorants with fixed fractions.
# Replace TARGET_FRACTIONS_RYB with your desired target mixture if known, or replace TARGET_REFLECTANCE directly
# with a measured 8-channel reflectance from your sensor.
TARGET_FRACTIONS_RYB = (0.20, 0.60, 0.20)  # red, yellow, blue fractions summing to 1.0


def mix_reflectance_subtractive(red_fraction: float, yellow_fraction: float, blue_fraction: float) -> np.ndarray:
    """
    Compute the mixture reflectance under subtractive mixing using Beer-Lambert law.
    A_mix = r*A_R + y*A_Y + b*A_B; R_mix = exp(-A_mix)
    Fractions must be non-negative and sum to 1.
    """
    r, y, b = red_fraction, yellow_fraction, blue_fraction
    a_mix = r * ABSORBANCE_RED + y * ABSORBANCE_YELLOW + b * ABSORBANCE_BLUE
    r_mix = np.exp(-a_mix)
    return np.clip(r_mix, 0.0, 1.0)


# Precompute target reflectance
TARGET_REFLECTANCE = mix_reflectance_subtractive(*TARGET_FRACTIONS_RYB)


def spectral_distance_l2(reflectance_a: np.ndarray, reflectance_b: np.ndarray) -> float:
    """
    L2 distance between two 8-channel reflectance spectra, normalized by number of channels.
    """
    diff = reflectance_a - reflectance_b
    return float(np.sqrt(np.mean(diff**2)))


def evaluate_color_mixture(
    red_fraction: float, yellow_fraction: float, blue_fraction: float, noise_std: float = 0.005
) -> Dict[str, float]:
    """
    Evaluate the spectral distance between the mixed sample and the target spectrum.

    In a real setup:
    - Prepare the liquid mixture using (red_fraction, yellow_fraction, blue_fraction).
    - Measure its 8-channel reflectance with your multispectral sensor.
    - Compute the spectral distance between the measured reflectance and TARGET_REFLECTANCE.

    This function simulates the measurement with a realistic subtractive mixing model and Gaussian sensor noise.
    """
    # Simulate noiseless reflectance from subtractive mixing
    reflectance_mix = mix_reflectance_subtractive(red_fraction, yellow_fraction, blue_fraction)

    # Simulate sensor noise on the measured spectrum
    noisy_reflectance = reflectance_mix + rng.normal(0.0, noise_std, size=reflectance_mix.shape)
    noisy_reflectance = np.clip(noisy_reflectance, 0.0, 1.0)

    # Compute scalar objective: spectral distance to target (minimize)
    distance = spectral_distance_l2(noisy_reflectance, TARGET_REFLECTANCE)

    return {"spectral_distance": max(distance, 0.0)}


# Objective name for Ax
OBJECTIVE_NAME = "spectral_distance"

# The compositional constraint enforces: red + yellow + blue = 1 and all >= 0.
# We reparameterize by optimizing only red_fraction and yellow_fraction in [0, 1],
# with a linear constraint red + yellow <= 1, and set blue = 1 - (red + yellow).
TOTAL_FRACTION = 1.0

ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "red_fraction", "type": "range", "bounds": [0.0, TOTAL_FRACTION]},
        {"name": "yellow_fraction", "type": "range", "bounds": [0.0, TOTAL_FRACTION]},
    ],
    objectives={
        OBJECTIVE_NAME: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"red_fraction + yellow_fraction <= {TOTAL_FRACTION}",
    ],
)

# Run Bayesian optimization
N_TRIALS = 40
for _ in range(N_TRIALS):
    parameterization, trial_index = ax_client.get_next_trial()

    red_fraction = float(parameterization["red_fraction"])
    yellow_fraction = float(parameterization["yellow_fraction"])
    blue_fraction = float(TOTAL_FRACTION - (red_fraction + yellow_fraction))  # enforce simplex

    results = evaluate_color_mixture(red_fraction, yellow_fraction, blue_fraction)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, best_metrics = ax_client.get_best_parameters()

# Derive full RYB fractions for the best parameters
best_red = float(best_parameters["red_fraction"])
best_yellow = float(best_parameters["yellow_fraction"])
best_blue = float(TOTAL_FRACTION - (best_red + best_yellow))

# Plot objective over trials
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])
ax.set_title("Spectral Distance Minimization (RYB Subtractive Mix)")
ax.legend()
plt.tight_layout()
plt.show()

# Plot target vs best-found mixture reflectance spectra
best_mix_reflectance = mix_reflectance_subtractive(best_red, best_yellow, best_blue)

fig2, ax2 = plt.subplots(figsize=(6, 4), dpi=150)
ax2.plot(WAVELENGTHS_NM, TARGET_REFLECTANCE, "-o", label="Target", color="black")
ax2.plot(WAVELENGTHS_NM, best_mix_reflectance, "-o", label="Best Mix", color="#1f77b4")
ax2.set_xlabel("Wavelength (nm)")
ax2.set_ylabel("Reflectance")
ax2.set_title(
    f"Target vs Best Mix Spectrum\nBest R/Y/B = {best_red:.2f}/{best_yellow:.2f}/{best_blue:.2f}, "
    f"Distance = {float(list(best_metrics.values())[0]['spectral_distance'] if isinstance(list(best_metrics.values())[0], dict) and 'spectral_distance' in list(best_metrics.values())[0] else list(best_metrics.values())[0]):.4f}"
)
ax2.set_ylim(0, 1)
ax2.legend()
plt.tight_layout()
plt.show()