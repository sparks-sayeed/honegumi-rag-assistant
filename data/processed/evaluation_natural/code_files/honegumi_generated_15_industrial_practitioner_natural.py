# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Problem: Optimize solar cell process to maximize power conversion efficiency (PCE)
# Parameters:
#   - annealing_temperature_c (°C)
#   - deposition_rate_nm_s (nm/s)
# Objective:
#   - efficiency_percent (%), maximize
# Budget: 25 trials
# Noise model: True (measurements are noisy)


def measure_solar_cell_efficiency(
    annealing_temperature_c: float,
    deposition_rate_nm_s: float,
    rng: np.random.Generator,
) -> float:
    """
    Simulated evaluation of solar cell efficiency (PCE %) for given process settings.

    Replace this simulator with the real experimental measurement pipeline, e.g.:
      - Fabricate a test cell with the provided annealing temp and deposition rate.
      - Measure the J-V curve under AM1.5G illumination.
      - Compute PCE (%): max power / (100 mW/cm^2) * 100.
      - Return the measured efficiency as a float.

    This simulator encodes typical behavior:
      - A broad optimum around mid-high annealing temperatures.
      - An optimum deposition rate balancing morphology and recombination.
      - Interaction between temperature and deposition rate.
      - Additive measurement noise to mimic lab variability.
    """
    T = annealing_temperature_c
    R = deposition_rate_nm_s

    # Centering near plausible optima (domain-inspired, not material-specific)
    T0 = 470.0  # °C
    R0 = 1.5    # nm/s

    # Curvature (wider sensitivity in temperature than deposition rate)
    t_scale = 60.0
    r_scale = 0.6

    t = (T - T0) / t_scale
    r = (R - R0) / r_scale

    # Baseline peak efficiency (percent)
    peak_eff = 24.0

    # Quadratic bowl with interaction; mild periodic terms to mimic process subtleties
    deterministic = (
        peak_eff
        - 5.0 * t**2
        - 3.0 * r**2
        - 2.0 * t * r
        + 0.6 * np.sin(T / 35.0)
        + 0.3 * np.cos(R * 2.2)
    )

    # Penalize extreme process settings (edges of the bounds)
    edge_penalty = (
        0.15 * ((np.clip(T, 350.0, 600.0) - T) ** 2 + (np.clip(R, 0.3, 3.0) - R) ** 2)
    )
    deterministic -= edge_penalty

    # Additive Gaussian noise to represent measurement/process variability
    noise = rng.normal(loc=0.0, scale=0.35)

    efficiency_percent = float(deterministic + noise)

    # Clamp to physically plausible range for a lab cell (for numerical stability)
    efficiency_percent = float(np.clip(efficiency_percent, 5.0, 28.0))
    return efficiency_percent


# Set random seed for reproducibility of the simulator (does not affect Ax's generator)
rng = np.random.default_rng(2025)

objective_name = "efficiency_percent"

ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {
            "name": "annealing_temperature_c",
            "type": "range",
            "bounds": [350.0, 600.0],  # degrees Celsius
        },
        {
            "name": "deposition_rate_nm_s",
            "type": "range",
            "bounds": [0.3, 3.0],  # nm/s
        },
    ],
    objectives={
        objective_name: ObjectiveProperties(minimize=False),
    },
    # Observations are noisy; we provide only measured means (SEM unknown).
)

num_trials = 25

for _ in range(num_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract process parameters
    annealing_temperature_c = float(parameterization["annealing_temperature_c"])
    deposition_rate_nm_s = float(parameterization["deposition_rate_nm_s"])

    try:
        eff = measure_solar_cell_efficiency(
            annealing_temperature_c=annealing_temperature_c,
            deposition_rate_nm_s=deposition_rate_nm_s,
            rng=rng,
        )
        # Report the measured efficiency (mean only; Ax will model unknown noise)
        ax_client.complete_trial(trial_index=trial_index, raw_data=eff)
    except Exception:
        # If fabrication/measurement fails, record failed trial so Ax can proceed
        ax_client.log_trial_failure(trial_index=trial_index)

best_parameters, best_values = ax_client.get_best_parameters()

print("Best process settings found:")
for k, v in best_parameters.items():
    print(f"  {k}: {v:.6g}")
print(f"Best observed {objective_name}: {best_values[objective_name]:.4f} %")

# Plot results
df = ax_client.get_trials_data_frame()
y = df[objective_name].to_numpy()
x = np.arange(len(y))

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(x, y, ec="k", fc="none", label="Observed")

best_to_trial = np.maximum.accumulate(y)
ax.plot(x, best_to_trial, color="#0033FF", lw=2, label="Best to Trial")

ax.set_xlabel("Trial Number")
ax.set_ylabel("Efficiency (%)")
ax.set_title("Solar Cell Process Optimization: Efficiency vs. Trial")
ax.legend()
plt.tight_layout()
plt.show()