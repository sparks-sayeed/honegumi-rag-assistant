# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
from typing import Dict, Tuple
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


def evaluate_sintering_run(temperature_celsius: float, time_hours: float) -> Dict[str, Tuple[float, float]]:
    """
    Evaluate the ceramic sintering experiment and return the measured density.

    This stub simulates realistic sintering behavior:
    - Densification follows an Arrhenius temperature dependence and time-dependent rate.
    - Saturates near a maximum relative density (e.g., 0.98).
    - Slight degradation at very high temperature and long time due to trapped porosity/grain growth.
    - Adds measurement noise and returns both mean and SEM.

    Replace this function with actual experimental measurement:
      - Run the furnace at `temperature_celsius` for `time_hours`.
      - Measure the resulting (bulk) density. If using relative density, divide by theoretical density.
      - Return {"density": (measured_value, standard_error_of_mean)}.
    """
    # Constants and model parameters for synthetic behavior
    R = 8.314  # J/mol-K
    activation_energy = 200e3  # J/mol (example for diffusion-controlled sintering)
    A = 2.0e6  # 1/h^n, pre-exponential factor (tuned for hours scale)
    n_time = 0.7  # time exponent capturing non-linearity
    rho0 = 0.55  # initial green relative density
    rho_max = 0.98  # maximum achievable relative density (practical limit)

    # Convert to Kelvin
    temperature_kelvin = temperature_celsius + 273.15

    # Arrhenius rate constant
    k_T = A * np.exp(-activation_energy / (R * temperature_kelvin))

    # Densification curve (approaches rho_max with time and temperature)
    densification = rho0 + (rho_max - rho0) * (1.0 - np.exp(-k_T * (time_hours ** n_time)))

    # Mild degradation at extreme conditions (e.g., very high T and long t)
    T_degrade_c = 1150.0
    t_degrade_h = 5.0
    gamma = 0.02  # maximum degradation magnitude
    def sigmoid(x, s=25.0):
        return 1.0 / (1.0 + np.exp(-x / s))
    degrade = gamma * sigmoid(temperature_celsius - T_degrade_c) * sigmoid(24.0 * (time_hours - t_degrade_h))

    density_rel = densification - degrade

    # Add realistic measurement noise (e.g., 0.5% absolute relative density)
    rng = np.random.default_rng()
    measurement_std = 0.005
    noise = rng.normal(0.0, measurement_std)
    measured_density = float(np.clip(density_rel + noise, 0.0, 1.0))

    # Return mean and SEM (here we use the same value as an estimate of SEM for demonstration)
    return {"density": (measured_density, measurement_std)}


if __name__ == "__main__":
    RANDOM_SEED = 12345
    N_TRIALS = 25

    ax_client = AxClient(random_seed=RANDOM_SEED)

    ax_client.create_experiment(
        name="ceramic_sintering_density_optimization",
        parameters=[
            {
                "name": "temperature_celsius",
                "type": "range",
                "bounds": [800.0, 1200.0],
                "value_type": "float",
            },
            {
                "name": "time_hours",
                "type": "range",
                "bounds": [1.0, 6.0],
                "value_type": "float",
            },
        ],
        objectives={
            "density": ObjectiveProperties(minimize=False),
        },
        parameter_constraints=[],
        outcome_constraints=[],
        overwrite_existing_experiment=True,
    )

    observed_densities = []

    for _ in range(N_TRIALS):
        parameterization, trial_index = ax_client.get_next_trial()

        # Extract parameters for clarity
        temperature_celsius = float(parameterization["temperature_celsius"])
        time_hours = float(parameterization["time_hours"])

        # Evaluate experiment (replace with real experiment/measurement)
        result = evaluate_sintering_run(temperature_celsius, time_hours)
        observed_densities.append(result["density"][0])

        # Report result to Ax (mean, SEM)
        ax_client.complete_trial(trial_index=trial_index, raw_data=result)

    best_parameters, best_metrics = ax_client.get_best_parameters()

    # Print best found parameters and density
    best_density_mean, best_density_sem = best_metrics["density"]
    print("Best parameters found:")
    for k, v in best_parameters.items():
        print(f"  {k}: {v:.4g}")
    print(f"Best observed density (mean ± SEM): {best_density_mean:.4f} ± {best_density_sem:.4f}")

    # Plot results: observed densities and best-so-far trace (maximize)
    trials = np.arange(1, len(observed_densities) + 1)
    best_so_far = np.maximum.accumulate(observed_densities)

    fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
    ax.scatter(trials, observed_densities, ec="k", fc="none", label="Observed density")
    ax.plot(trials, best_so_far, color="#0033FF", lw=2, label="Best-so-far")
    ax.set_xlabel("Trial Number")
    ax.set_ylabel("Density (relative units)")
    ax.set_title("Sintering Density Optimization (Ax)")
    ax.legend()
    plt.tight_layout()
    plt.show()