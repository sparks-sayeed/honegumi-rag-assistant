# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"
obj2_name = "branin_swapped"


def branin_moo(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # second objective has x1 and x2 swapped
    y2 = float(
        (x1 - 5.1 / (4 * np.pi**2) * x2**2 + 5.0 / np.pi * x2 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x2)
        + 10
    )

    return {obj1_name: y, obj2_name: y2}


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
        obj2_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        "1.0*x1 + 0.5*x2 <= 15.0",  # example of a linear constraint. Note the lack of space around the asterisks
    ],
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin_moo(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)
pareto_results = ax_client.get_pareto_optimal_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto[objectives[0]],
    pareto[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])

ax.legend()
plt.show()

# Generated from Honegumi skeleton and adapted to lead compound MOO use case
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from typing import Dict, Tuple
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain-specific objective names
OBJ_AFFINITY = "target_affinity"
OBJ_SOLUBILITY = "aqueous_solubility"
OBJ_TOXICITY = "toxicity"


def evaluate_molecule(parameterization: Dict[str, float]) -> Dict[str, Tuple[float, float]]:
    """
    Evaluate a candidate molecule using simple surrogate relationships with noise.
    Returns mean and SEM for each metric as required by Ax MOO API.

    Parameters:
    - molecular_weight: float in [150, 500] Da
    - logP: float in [-1.0, 5.0]
    - h_bond_donors: float in [0, 5]
    - h_bond_acceptors: float in [0, 10]

    Objectives:
    - target_affinity (maximize): proxy of binding affinity; peaks at druglike regime.
    - aqueous_solubility (maximize): proxy using simplified ESOL-like relationship (log S, mol/L).
    - toxicity (minimize): proxy toxicity score increasing with lipophilicity and size.

    NOTE: Replace these surrogates with actual computation or model inference in production.
    """
    mw = float(parameterization["molecular_weight"])
    logp = float(parameterization["logP"])
    hbd = float(parameterization["h_bond_donors"])
    hba = float(parameterization["h_bond_acceptors"])

    # Optional: treat HBD/HBA as quasi-integers in the evaluator (rounding to nearest 0.5)
    # hbd = np.clip(np.round(hbd), 0, 5)
    # hba = np.clip(np.round(hba), 0, 10)

    rng = np.random.default_rng()

    # Target affinity: Gaussian bump around an "ideal" region with small contribution from polar contacts.
    aff_center_mw = 350.0
    aff_center_logp = 2.5
    aff_center_hbd = 1.0
    aff_center_hba = 3.0
    scale_mw = 100.0
    scale_logp = 1.5
    scale_hbd = 1.5
    scale_hba = 2.0

    gauss_term = np.exp(
        -((mw - aff_center_mw) / scale_mw) ** 2
        -((logp - aff_center_logp) / scale_logp) ** 2
        -((hbd - aff_center_hbd) / scale_hbd) ** 2
        -((hba - aff_center_hba) / scale_hba) ** 2
    )

    # Base affinity score between ~0 and 100, plus benefit for polar interactions
    target_affinity = 100.0 * gauss_term + 3.0 * (hbd + hba)
    target_affinity_noise_sd = 1.0
    target_affinity_meas = float(target_affinity + rng.normal(0.0, target_affinity_noise_sd))

    # Aqueous solubility (logS, mol/L): simplified ESOL-like relationship
    # logS â‰ˆ A - 0.63*logP - 0.0062*MW + minor positive effect from HBD/HBA
    A = 0.5
    logS = A - 0.63 * logp - 0.0062 * mw + 0.02 * (hbd + hba)
    solubility_noise_sd = 0.15
    aqueous_solubility_meas = float(logS + rng.normal(0.0, solubility_noise_sd))

    # Toxicity score (minimize): increases with logP, MW, and H-bond counts; add penalty for extreme lipophilicity
    lipophilicity_penalty = 0.25 * max(0.0, logp - 3.0) ** 2
    size_term = 0.012 * (mw - 200.0)
    tox = max(
        0.0,
        0.8 * max(logp, -1.0) + size_term + 0.2 * hba + 0.3 * hbd + lipophilicity_penalty,
    )
    toxicity_noise_sd = 0.2
    toxicity_meas = float(max(0.0, tox + rng.normal(0.0, toxicity_noise_sd)))

    return {
        OBJ_AFFINITY: (target_affinity_meas, target_affinity_noise_sd),
        OBJ_SOLUBILITY: (aqueous_solubility_meas, solubility_noise_sd),
        OBJ_TOXICITY: (toxicity_meas, toxicity_noise_sd),
    }


def is_pareto_efficient(points: np.ndarray) -> np.ndarray:
    """
    Identify Pareto-efficient points for a matrix of points to be maximized.
    points: shape (n_points, n_obj), higher is better in every column.
    Returns: boolean mask where True indicates a Pareto-efficient point.
    """
    n_points = points.shape[0]
    is_efficient = np.ones(n_points, dtype=bool)
    for i in range(n_points):
        if not is_efficient[i]:
            continue
        # Any point j that strictly dominates i (>= in all and > in at least one) -> i is not efficient.
        dominates = np.all(points >= points[i], axis=1) & np.any(points > points[i], axis=1)
        # Exclude self-comparison by making sure i doesn't eliminate itself.
        dominates[i] = False
        if np.any(dominates):
            is_efficient[i] = False
    return is_efficient


def main():
    np.random.seed(12345)

    ax_client = AxClient()

    # Create experiment with Lipinski search space and objectives
    ax_client.create_experiment(
        name="lead_compound_multiobjective_optimization",
        parameters=[
            {
                "name": "molecular_weight",
                "type": "range",
                "bounds": [150.0, 500.0],  # constrained by Lipinski MW <= 500
                "value_type": "float",
            },
            {
                "name": "logP",
                "type": "range",
                "bounds": [-1.0, 5.0],  # constrained by Lipinski logP <= 5
                "value_type": "float",
            },
            {
                "name": "h_bond_donors",
                "type": "range",
                "bounds": [0.0, 5.0],  # constrained by Lipinski HBD <= 5
                "value_type": "float",
            },
            {
                "name": "h_bond_acceptors",
                "type": "range",
                "bounds": [0.0, 10.0],  # constrained by Lipinski HBA <= 10
                "value_type": "float",
            },
        ],
        objectives={
            OBJ_AFFINITY: ObjectiveProperties(minimize=False),
            OBJ_SOLUBILITY: ObjectiveProperties(minimize=False),
            OBJ_TOXICITY: ObjectiveProperties(minimize=True),
        },
        parameter_constraints=[
            # Redundant with bounds, but included explicitly as per problem specification (linear constraints).
            "1.0*molecular_weight <= 500.0",
            "1.0*logP <= 5.0",
            "1.0*h_bond_donors <= 5.0",
            "1.0*h_bond_acceptors <= 10.0",
        ],
    )

    # Run optimization loop
    N_TRIALS = 40
    for _ in range(N_TRIALS):
        parameterization, trial_index = ax_client.get_next_trial()
        results = evaluate_molecule(parameterization)
        ax_client.complete_trial(trial_index=trial_index, raw_data=results)

    # Retrieve observed data
    df = ax_client.get_trials_data_frame()

    # Filter only completed trials with all objectives present
    metrics = [OBJ_AFFINITY, OBJ_SOLUBILITY, OBJ_TOXICITY]
    df = df.dropna(subset=metrics).reset_index(drop=True)

    # Compute Pareto-efficient set for 3 objectives with mixed sense:
    # maximize affinity and solubility; minimize toxicity -> convert by negating toxicity to include in maximization
    if len(df) > 0:
        pts = df[[OBJ_AFFINITY, OBJ_SOLUBILITY]].to_numpy(dtype=float)
        tox = df[[OBJ_TOXICITY]].to_numpy(dtype=float)
        combined = np.concatenate([pts, -tox], axis=1)  # higher better across all three columns now
        pareto_mask = is_pareto_efficient(combined)
        df["is_pareto"] = pareto_mask
    else:
        df["is_pareto"] = []

    # Print top Pareto candidates
    if "is_pareto" in df.columns and df["is_pareto"].any():
        pareto_df = df[df["is_pareto"]].copy()
        pareto_df_sorted = pareto_df.sort_values(by=[OBJ_AFFINITY, OBJ_SOLUBILITY, OBJ_TOXICITY], ascending=[False, False, True])
        print("Pareto-optimal candidates (observed):")
        print(
            pareto_df_sorted[
                ["molecular_weight", "logP", "h_bond_donors", "h_bond_acceptors", OBJ_AFFINITY, OBJ_SOLUBILITY, OBJ_TOXICITY]
            ].head(15).to_string(index=False)
        )
    else:
        print("No Pareto-optimal candidates identified yet.")

    # Visualization: Pairwise scatter of affinity vs solubility, colored by toxicity. Pareto points highlighted.
    if len(df) > 0:
        fig, ax = plt.subplots(figsize=(7, 5), dpi=150)
        sc = ax.scatter(
            df[OBJ_AFFINITY],
            df[OBJ_SOLUBILITY],
            c=df[OBJ_TOXICITY],
            cmap="viridis_r",
            edgecolor="k",
            alpha=0.8,
            label="Observed",
        )
        if "is_pareto" in df.columns and df["is_pareto"].any():
            ax.scatter(
                df.loc[df["is_pareto"], OBJ_AFFINITY],
                df.loc[df["is_pareto"], OBJ_SOLUBILITY],
                c=df.loc[df["is_pareto"], OBJ_TOXICITY],
                cmap="viridis_r",
                edgecolor="red",
                linewidth=1.2,
                s=70,
                marker="o",
                label="Pareto-optimal",
            )
        ax.set_xlabel("Target affinity (higher is better)")
        ax.set_ylabel("Aqueous solubility logS (higher is better)")
        cbar = plt.colorbar(sc, ax=ax)
        cbar.set_label("Toxicity (lower is better)")
        ax.legend()
        ax.set_title("Lead compound MOO: affinity vs solubility (colored by toxicity)")
        plt.tight_layout()
        plt.show()


if __name__ == "__main__":
    main()