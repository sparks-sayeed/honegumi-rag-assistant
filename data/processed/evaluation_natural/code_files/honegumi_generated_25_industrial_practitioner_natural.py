# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from typing import Dict, Tuple
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain: Fermentation medium optimization for maximizing product yield.
# We tune concentrations of three key nutrients in the medium and measure yield (g/L).
# Budget: 30 experimental batches (no constraints beyond parameter bounds).
np.random.seed(42)

yield_metric_name = "yield"  # g/L


def evaluate_fermentation(
    carbon_gL: float,
    nitrogen_gL: float,
    phosphate_gL: float,
) -> Dict[str, Tuple[float, float]]:
    """
    Evaluate fermentation yield given medium composition.

    Replace this stub with your actual experimental measurement logic, e.g.:
      - Prepare medium with given concentrations
      - Run fermentation
      - Measure product titer (g/L) as yield
      - Return {"yield": (measured_mean, measured_sem)}

    Below is a realistic synthetic model capturing:
      - Optimal concentrations with Gaussian-like response
      - Interaction/synergy between nutrients
      - Inhibition at high concentrations
      - Additive experimental noise
    """
    # Hypothetical optimal concentrations based on domain intuition
    mu_c, mu_n, mu_p = 50.0, 3.0, 1.0  # g/L
    sigma_c, sigma_n, sigma_p = 12.0, 0.9, 0.35

    # Gaussian response around optima for each nutrient
    c_factor = np.exp(-0.5 * ((carbon_gL - mu_c) / sigma_c) ** 2)
    n_factor = np.exp(-0.5 * ((nitrogen_gL - mu_n) / sigma_n) ** 2)
    p_factor = np.exp(-0.5 * ((phosphate_gL - mu_p) / sigma_p) ** 2)

    # Base maximum achievable yield (g/L) for this strain/process
    base_max_yield = 100.0

    # Interaction/synergy term (encourages balanced ratios)
    ratio_c_n = carbon_gL / max(nitrogen_gL, 1e-6)
    ratio_n_p = nitrogen_gL / max(phosphate_gL, 1e-6)
    balance_penalty = np.exp(-0.5 * (((ratio_c_n - 16.0) / 6.0) ** 2 + ((ratio_n_p - 3.0) / 1.5) ** 2))
    synergy = 1.0 + 0.15 * balance_penalty

    # Inhibition penalty at excessive totals
    total = carbon_gL + nitrogen_gL + phosphate_gL
    inhibition = np.exp(-max(0.0, total - 70.0) / 25.0)

    # Deterministic yield model
    deterministic_yield = base_max_yield * c_factor * n_factor * p_factor * synergy * inhibition

    # Add heteroscedastic noise to emulate experimental variability
    noise_sd = 0.03 * max(10.0, deterministic_yield) + 0.5  # scale with yield, plus baseline noise
    measured_yield = float(np.random.normal(loc=deterministic_yield, scale=noise_sd))

    # Ensure non-negative yield
    measured_yield = max(0.0, measured_yield)

    # Report standard error of the mean (SEM) for a single measurement
    sem = max(0.5, 0.3 * noise_sd)

    return {yield_metric_name: (measured_yield, sem)}


# Set up Ax optimization client
ax_client = AxClient()
ax_client.create_experiment(
    name="fermentation_medium_optimization",
    parameters=[
        {
            "name": "carbon_gL",
            "type": "range",
            "bounds": [10.0, 80.0],
            "value_type": "float",
        },
        {
            "name": "nitrogen_gL",
            "type": "range",
            "bounds": [0.3, 8.0],
            "value_type": "float",
        },
        {
            "name": "phosphate_gL",
            "type": "range",
            "bounds": [0.05, 3.0],
            "value_type": "float",
        },
    ],
    objectives={yield_metric_name: ObjectiveProperties(minimize=False)},
)

# Optimization loop with a budget of 30 trials
BUDGET_TRIALS = 30
observed_yields = []

for _ in range(BUDGET_TRIALS):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters
    carbon_gL = float(parameterization["carbon_gL"])
    nitrogen_gL = float(parameterization["nitrogen_gL"])
    phosphate_gL = float(parameterization["phosphate_gL"])

    # Evaluate experiment
    results = evaluate_fermentation(carbon_gL, nitrogen_gL, phosphate_gL)

    # Record observed yield for plotting
    observed_yields.append(results[yield_metric_name][0])

    # Report result back to Ax (mean, sem) for the metric
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve best found parameters and corresponding yield
best_parameters, best_metrics = ax_client.get_best_parameters()
best_yield_mean = best_metrics[yield_metric_name]["mean"]
best_yield_sem = best_metrics[yield_metric_name]["sem"]

print("Best medium composition found:")
for k, v in best_parameters.items():
    print(f"  {k}: {v:.4f} g/L")
print(f"Best expected yield: {best_yield_mean:.2f} g/L (SEM: {best_yield_sem:.2f})")

# Plot observed yields over trials with cumulative best
trial_numbers = np.arange(1, len(observed_yields) + 1)
cum_best = np.maximum.accumulate(observed_yields)

fig, ax = plt.subplots(figsize=(7, 4.5), dpi=150)
ax.scatter(trial_numbers, observed_yields, ec="k", fc="none", label="Observed yield")
ax.plot(trial_numbers, cum_best, color="#0033FF", lw=2, label="Best so far")
ax.set_xlabel("Trial number")
ax.set_ylabel("Yield (g/L)")
ax.set_title("Fermentation Yield Optimization")
ax.grid(alpha=0.25)
ax.legend()
plt.tight_layout()
plt.show()