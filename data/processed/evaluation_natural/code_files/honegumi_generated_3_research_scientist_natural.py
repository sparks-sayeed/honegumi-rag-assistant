# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from typing import Dict, Tuple

from ax.service.ax_client import AxClient
from ax.service.utils.instantiation import ObjectiveProperties
from ax.modelbridge.factory import Models
from ax.modelbridge.generation_strategy import GenerationStep, GenerationStrategy


# Domain-specific metric names
MECH_STRENGTH = "mechanical_strength"  # MPa, to maximize, spec >= 70 MPa
BIODEG_RATE = "biodegradability_rate"  # 1/day, to maximize
STRENGTH_BELOW_SPEC = "strength_below_spec"  # auxiliary constraint metric (<= 0)


# Bounds and constants
SIMPLEX_TOTAL = 1.0
MIN_STRENGTH_SPEC = 70.0  # MPa, minimum requirement
EXTRUSION_RATE_RPM_BOUNDS = (20.0, 200.0)  # typical screw speed range
TEMPERATURE_C_BOUNDS = (140.0, 240.0)  # typical processing temperature range


def evaluate_polymer_formulation(parameterization: Dict[str, float]) -> Dict[str, Tuple[float, float]]:
    """
    Evaluate polymer formulation and processing on two objectives:
      - mechanical strength in MPa (maximize)
      - biodegradability rate in 1/day (maximize)
    Also computes an auxiliary constraint metric:
      - strength_below_spec = max(0, 70 - mechanical_strength) (should be <= 0)

    This is a realistic surrogate stub. Replace with actual experiment or simulator call.
    """
    # Extract parameters
    f1 = float(parameterization["monomer1_fraction"])
    f2 = float(parameterization["monomer2_fraction"])
    f3 = float(parameterization["monomer3_fraction"])
    f4 = float(parameterization["monomer4_fraction"])
    # Enforce composition constraint by computing the fifth monomer fraction
    f5 = max(0.0, SIMPLEX_TOTAL - (f1 + f2 + f3 + f4))

    rpm = float(parameterization["extrusion_rate_rpm"])
    temp_c = float(parameterization["temperature_celsius"])

    # Normalize process params to [0,1]
    r_lo, r_hi = EXTRUSION_RATE_RPM_BOUNDS
    t_lo, t_hi = TEMPERATURE_C_BOUNDS
    r_norm = (rpm - r_lo) / (r_hi - r_lo)
    t_norm = (temp_c - t_lo) / (t_hi - t_lo)

    # Per-monomer intrinsic contributions (domain-inspired)
    # Strength contributions in MPa (weighted by fraction)
    s_vec = np.array([88.0, 76.0, 100.0, 82.0, 70.0])
    # Biodegradation base rates (1/day)
    b_vec = np.array([0.12, 0.05, 0.18, 0.15, 0.07])

    f = np.array([f1, f2, f3, f4, f5])

    # Base properties as weighted sums
    base_strength = float(np.dot(f, s_vec))  # MPa
    base_biodeg = float(np.dot(f, b_vec))    # 1/day

    # Process effects:
    # - Strength tends to increase with shear/orientation up to an optimal rpm, and decrease at too high temp.
    # - Biodegradation tends to increase with temperature and slightly decrease with higher shear (denser packing).
    strength_proc = (
        14.0 * (1.0 - (r_norm - 0.65) ** 2)  # peak near ~65% of rpm range
        + 10.0 * (1.0 - (t_norm - 0.45) ** 2)  # peak near ~45% of temp range
        - 3.0 * max(0.0, t_norm - 0.8) * 10.0  # penalty if temperature is very high
    )

    biodeg_proc = (
        0.10 * t_norm  # higher temp accelerates degradation
        + 0.04 * (1.0 - r_norm)  # lower shear yields higher porosity -> faster degradation
    )

    # Composition-process interactions (illustrative):
    # Monomer3 fosters strength crystallinity at moderate temp; Monomer4 accelerates biodeg at high temp.
    strength_interact = 6.0 * f3 * np.exp(-8.0 * (t_norm - 0.5) ** 2) + 2.0 * f1 * r_norm
    biodeg_interact = 0.06 * f4 * np.clip((t_norm - 0.4), 0.0, 1.0) + 0.03 * f3 * (1.0 - r_norm)

    # Aggregate properties
    mechanical_strength = base_strength + strength_proc + strength_interact  # MPa
    biodegradability_rate = base_biodeg + biodeg_proc + biodeg_interact      # 1/day

    # Clamp biodeg to physically reasonable stub range
    biodegradability_rate = float(np.clip(biodegradability_rate, 0.01, 0.6))

    # Add experimental noise (since Noise model: True)
    rng = np.random.default_rng(12345)  # fixed seed per call for deterministic demo; remove for true randomness
    mech_noise_sd = 1.5  # MPa
    bio_noise_sd = 0.01  # 1/day
    mechanical_strength_obs = mechanical_strength + rng.normal(0.0, mech_noise_sd)
    biodegradability_rate_obs = biodegradability_rate + rng.normal(0.0, bio_noise_sd)

    # Auxiliary constraint metric: must be <= 0.0 to satisfy spec.
    strength_below_spec = max(0.0, MIN_STRENGTH_SPEC - mechanical_strength_obs)

    return {
        MECH_STRENGTH: (float(mechanical_strength_obs), mech_noise_sd),
        BIODEG_RATE: (float(biodegradability_rate_obs), bio_noise_sd),
        STRENGTH_BELOW_SPEC: (float(strength_below_spec), 0.0),
    }


# Historical literature priors (3 examples).
# Each dict contains monomer1..4 (monomer5 inferred), extrusion_rate_rpm, temperature_celsius.
# Values are illustrative and satisfy the simplex constraint (sum of all 5 = 1.0).
literature_priors = pd.DataFrame(
    [
        {
            "monomer1_fraction": 0.25,
            "monomer2_fraction": 0.15,
            "monomer3_fraction": 0.30,
            "monomer4_fraction": 0.20,
            "extrusion_rate_rpm": 120.0,
            "temperature_celsius": 185.0,
        },  # monomer5 = 0.10
        {
            "monomer1_fraction": 0.10,
            "monomer2_fraction": 0.20,
            "monomer3_fraction": 0.25,
            "monomer4_fraction": 0.25,
            "extrusion_rate_rpm": 90.0,
            "temperature_celsius": 200.0,
        },  # monomer5 = 0.20
        {
            "monomer1_fraction": 0.35,
            "monomer2_fraction": 0.10,
            "monomer3_fraction": 0.20,
            "monomer4_fraction": 0.25,
            "extrusion_rate_rpm": 150.0,
            "temperature_celsius": 175.0,
        },  # monomer5 = 0.10
    ]
)


# Compute training outcomes for priors
y_priors = [
    evaluate_polymer_formulation(row.to_dict()) for _, row in literature_priors.iterrows()
]
n_train = len(literature_priors)


# Generation strategy: SOBOL init, then fully Bayesian SAASBO with qNEHVI (for MOO)
gs = GenerationStrategy(
    steps=[
        GenerationStep(
            model=Models.SOBOL,
            num_trials=12,  # ~2 * number of effective params (4 monomers + 2 process)
            min_trials_observed=6,
            max_parallelism=6,
            model_kwargs={"seed": 2025},
        ),
        GenerationStep(
            model=Models.SAASBO,  # fully Bayesian with SAAS priors; supports MOO with qNEHVI
            num_trials=-1,
            max_parallelism=4,
        ),
    ]
)

ax_client = AxClient(generation_strategy=gs, random_seed=2025)

# Create MOO experiment with composition constraint via reparameterization (hide monomer5)
ax_client.create_experiment(
    name="biodegradable_polymer_pareto",
    parameters=[
        {"name": "monomer1_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "monomer2_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "monomer3_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "monomer4_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {
            "name": "extrusion_rate_rpm",
            "type": "range",
            "bounds": [EXTRUSION_RATE_RPM_BOUNDS[0], EXTRUSION_RATE_RPM_BOUNDS[1]],
        },
        {
            "name": "temperature_celsius",
            "type": "range",
            "bounds": [TEMPERATURE_C_BOUNDS[0], TEMPERATURE_C_BOUNDS[1]],
        },
    ],
    objectives={
        # Thresholds define the region of interest for EHVI.
        MECH_STRENGTH: ObjectiveProperties(minimize=False, threshold=MIN_STRENGTH_SPEC),
        BIODEG_RATE: ObjectiveProperties(minimize=False, threshold=0.12),
    },
    # Enforce that the total of 5 monomers equals 1.0 by searching in first 4 and inferring the 5th.
    parameter_constraints=[
        "monomer1_fraction + monomer2_fraction + monomer3_fraction + monomer4_fraction <= 1.0",
    ],
    # Hard minimum strength requirement via auxiliary metric (can't constrain the objective metric directly).
    outcome_constraints=[f"{STRENGTH_BELOW_SPEC} <= 0.0"],
)

# Attach prior (historical) data
for i in range(n_train):
    parameterization = literature_priors.iloc[i].to_dict()
    ax_client.attach_trial(parameterization)
    ax_client.complete_trial(trial_index=i, raw_data=y_priors[i])

# Optimization loop
N_TOTAL_SUGGESTIONS = 28
for _ in range(N_TOTAL_SUGGESTIONS):
    try:
        parameterization, trial_index = ax_client.get_next_trial()
    except Exception as e:
        # In case SAASBO requires more completed data before proceeding, break gracefully.
        # Users can increase N_TOTAL_SUGGESTIONS or wait for more trials to complete in real setups.
        print(f"Stopped early: {e}")
        break

    results = evaluate_polymer_formulation(parameterization)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve Pareto-optimal results (observed)
pareto_dict = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

# Convert Pareto set to DataFrame for plotting
objectives = ax_client.objective_names
pareto_records = []
for _, v in pareto_dict.items():
    # v is a tuple: (parameterization, (metrics dataframe? or values map?))
    # AxClient returns a nested structure; the skeleton extracts v[1][0].
    # We'll follow the skeleton approach for compatibility.
    try:
        metrics_values = v[1][0]  # dict of metric -> value
    except Exception:
        # Fallback: attempt to access by keys
        metrics_values = v[1]
    pareto_records.append({k: metrics_values.get(k) for k in objectives})

pareto_df = pd.DataFrame(pareto_records)
pareto_df = pareto_df.sort_values(objectives[0]) if not pareto_df.empty else pareto_df

# Fetch all observed trial data
df_all = ax_client.get_trials_data_frame()

# Plot observed outcomes and Pareto frontier
fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
if not df_all.empty:
    ax.scatter(
        df_all[MECH_STRENGTH],
        df_all[BIODEG_RATE],
        fc="None",
        ec="k",
        label="Observed",
    )

if not pareto_df.empty:
    ax.plot(
        pareto_df[MECH_STRENGTH],
        pareto_df[BIODEG_RATE],
        color="#0033FF",
        lw=2,
        label="Pareto Front (observed)",
    )

ax.axvline(MIN_STRENGTH_SPEC, color="red", linestyle="--", linewidth=1.0, label="Strength spec (70 MPa)")
ax.set_xlabel(f"{MECH_STRENGTH} (MPa)")
ax.set_ylabel(f"{BIODEG_RATE} (1/day)")
ax.legend()
plt.tight_layout()
plt.show()