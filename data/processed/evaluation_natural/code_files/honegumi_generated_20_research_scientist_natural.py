# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import math
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Problem: Thermal management for LED packaging
# Goal: Minimize LED junction temperature (°C) by tuning two design parameters:
#   - heat_spreader_thickness_mm: thickness of the copper heat spreader (0.5 to 5.0 mm)
#   - tim_thermal_conductivity_W_per_mK: thermal conductivity of the TIM (1.0 to 12.0 W/m-K)
# Budget: 28 trials (no constraints)
# Note: This implementation uses a simplified physics-inspired surrogate for junction temperature.
#       Replace evaluate_thermal_design() with actual experimental or simulation logic as needed.

rng = np.random.default_rng(12345)

objective_metric_name = "junction_temperature_celsius"


def evaluate_thermal_design(
    heat_spreader_thickness_mm: float,
    tim_thermal_conductivity_W_per_mK: float,
) -> tuple[float, float]:
    """
    Evaluate the LED junction temperature (°C) given design parameters.

    This is a simplified physics-inspired surrogate:
      Tj = T_ambient + P * (R_jc + R_tim + R_spreader + R_hs_a) + measurement_noise

    Where:
      - R_jc: junction-to-case thermal resistance (assumed constant)
      - R_tim: thermal interface material resistance (depends on k_TIM)
      - R_spreader: heat spreader resistance (vertical conduction + spreading effect)
      - R_hs_a: heatsink-to-ambient resistance (assumed constant)

    Returns:
      (mean_junction_temperature_celsius, sem_celsius)

    Replace this with actual experimental measurement or high-fidelity simulation
    for production use.
    """
    try:
        # Constants and assumptions (can be adjusted to match your setup)
        T_ambient_C = 25.0  # °C
        P_watts = 3.0       # LED electrical power, W
        R_jc_C_per_W = 3.0  # junction-to-case, °C/W (typical order)
        R_hs_a_C_per_W = 5.0  # heatsink-to-ambient, °C/W (natural convection order)

        # Geometry/Material assumptions
        led_footprint_side_m = 10e-3  # 10 mm x 10 mm footprint
        contact_area_m2 = led_footprint_side_m**2  # 1e-4 m^2
        tim_thickness_m = 100e-6  # 100 micrometers
        k_copper_W_per_mK = 400.0

        # Parameters
        t_spreader_m = max(heat_spreader_thickness_mm, 0.0) * 1e-3
        k_tim = max(tim_thermal_conductivity_W_per_mK, 1e-6)

        # TIM thermal resistance: R = t / (k*A)
        R_tim = tim_thickness_m / (k_tim * contact_area_m2)

        # Spreader resistance: vertical conduction + empirical spreading term (decreases with thickness)
        R_spreader_vertical = t_spreader_m / (k_copper_W_per_mK * contact_area_m2)
        # Empirical spreading resistance component: decreases with sqrt(thickness)
        # Tuned coefficient to give reasonable magnitude over [0.5, 5] mm
        R_spreader_spreading = 0.8 / math.sqrt(heat_spreader_thickness_mm + 0.1)
        R_spreader = R_spreader_vertical + R_spreader_spreading

        # Total resistance and junction temperature
        R_total = R_jc_C_per_W + R_tim + R_spreader + R_hs_a_C_per_W
        tj_celsius_mean = T_ambient_C + P_watts * R_total

        # Add measurement/process noise (noise model True)
        measurement_noise_sigma_C = 0.5
        observed_tj = tj_celsius_mean + rng.normal(0.0, measurement_noise_sigma_C)

        # Report SEM estimate (if you aggregate multiple measurements, reduce this accordingly)
        reported_sem_C = 0.3

        # Enforce a physical lower bound (can't be lower than ambient realistically)
        observed_tj = float(max(observed_tj, T_ambient_C))

        return observed_tj, reported_sem_C

    except Exception:
        # On any numerical or domain error, return a conservative large value with higher SEM
        return 200.0, 5.0


ax_client = AxClient()

ax_client.create_experiment(
    name="led_thermal_management_minimize_tj",
    parameters=[
        {
            "name": "heat_spreader_thickness_mm",
            "type": "range",
            "bounds": [0.5, 5.0],
        },
        {
            "name": "tim_thermal_conductivity_W_per_mK",
            "type": "range",
            "bounds": [1.0, 12.0],
        },
    ],
    objectives={
        objective_metric_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[],
    outcome_constraints=[],
    choose_generation_strategy=True,  # Use Ax default: Sobol + GPEI
)


num_trials = 28
for _ in range(num_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters
    heat_spreader_thickness_mm = float(parameterization["heat_spreader_thickness_mm"])
    tim_thermal_conductivity_W_per_mK = float(parameterization["tim_thermal_conductivity_W_per_mK"])

    # Evaluate design
    tj_value_c, tj_sem_c = evaluate_thermal_design(
        heat_spreader_thickness_mm=heat_spreader_thickness_mm,
        tim_thermal_conductivity_W_per_mK=tim_thermal_conductivity_W_per_mK,
    )

    ax_client.complete_trial(
        trial_index=trial_index,
        raw_data={objective_metric_name: (tj_value_c, tj_sem_c)},
    )

# Retrieve best found parameters and metrics
best_parameters, best_metrics = ax_client.get_best_parameters()
print("Best parameters found:")
print(best_parameters)
print("Best metrics (model-estimated):")
print(best_metrics)

# Plot results
objective_names = ax_client.objective_names
df = ax_client.get_trials_data_frame()

if len(objective_names) == 1:
    metric = objective_names[0]
    y = df[metric].astype(float).values
    x = np.arange(len(y))
    best_so_far = np.minimum.accumulate(y)

    fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
    ax.scatter(x, y, ec="k", fc="none", label="Observed")
    ax.plot(x, best_so_far, color="#0033FF", lw=2, label="Best to Trial")
    ax.set_xlabel("Trial Number")
    ax.set_ylabel(metric)
    ax.legend()
    plt.tight_layout()
    plt.show()
else:
    # Fallback simple table print if multi-objective (not expected in this problem)
    print(df)