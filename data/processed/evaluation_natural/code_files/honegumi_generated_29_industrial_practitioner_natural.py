# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from typing import Dict, Tuple

from ax.service.ax_client import AxClient, ObjectiveProperties


# Domain-specific objective names
TIME_METRIC = "charge_time_minutes"      # minimize
LIFE_METRIC = "cycle_life_cycles"        # maximize


# Random generator for noisy evaluations (simulating experimental noise)
_rng = np.random.default_rng(seed=42)


def evaluate_charging_protocol(parameters: Dict[str, float]) -> Dict[str, Tuple[float, float]]:
    """
    Simulated evaluation of a Li-ion fast charging protocol, given:
      - cc_c_rate: Constant-current stage current (C-rate), e.g., 0.5C to 3.0C
      - charge_voltage_v: Constant-voltage setpoint (V), e.g., 4.10V to 4.35V
      - cv_cutoff_c_rate: Termination current in CV stage (C-rate), e.g., 0.01C to 0.20C

    Returns a dict mapping objective names to (mean, SEM):
      - charge_time_minutes (minimize): Total charge time in minutes
      - cycle_life_cycles (maximize): Estimated cycle life (number of cycles to 80% capacity)

    NOTE:
      - This is a realistic stub capturing common trade-offs:
          * Higher cc_c_rate reduces charge time but accelerates aging.
          * Higher charge_voltage increases time in CV and accelerates aging.
          * Lower cv_cutoff_c_rate increases time spent at high voltage and accelerates aging.
      - Replace with actual experimental measurement integration (instrument API / lab pipeline).
    """

    cc_c_rate = float(parameters["cc_c_rate"])
    charge_voltage_v = float(parameters["charge_voltage_v"])
    cv_cutoff_c_rate = float(parameters["cv_cutoff_c_rate"])

    # Sanity clipping to search-space limits (defensive)
    cc_c_rate = float(np.clip(cc_c_rate, 0.5, 3.0))
    charge_voltage_v = float(np.clip(charge_voltage_v, 4.10, 4.35))
    cv_cutoff_c_rate = float(np.clip(cv_cutoff_c_rate, 0.01, 0.20))

    # Charge time model (minutes):
    # - CC portion approx 80% SOC: 48 minutes at 1C, scales inversely with C-rate.
    t_cc = 48.0 / cc_c_rate

    # - CV base time increases with higher voltage setpoint due to more Li insertion near end of charge.
    #   Map 4.10V -> ~20 min, 4.35V -> ~60 min
    base_cv = np.interp(charge_voltage_v, [4.10, 4.35], [20.0, 60.0])

    # - CV tail multiplier: lower termination current -> longer tail (log relationship).
    #   Normalize using bounds [0.01C, 0.20C].
    cv_tail_factor = np.log(0.20 / cv_cutoff_c_rate) / np.log(0.20 / 0.01)  # in [0, 1]
    t_cv = base_cv * cv_tail_factor

    # Total time with some process overhead
    nominal_time = t_cc + t_cv + 2.0  # minutes

    # Measurement/process noise (simulate)
    time_noise_sd = 0.7  # minutes
    charge_time_minutes = float(nominal_time + _rng.normal(0.0, time_noise_sd))

    # Cycle life model (higher is better):
    # Baseline (gentle charging) around ~1000 cycles; penalize stressors:
    # - High C-rate (quadratic penalty)
    current_stress = (cc_c_rate - 1.0) ** 2

    # - High voltage (quadratic penalty vs 4.2V nominal)
    voltage_stress = ((charge_voltage_v - 4.20) / 0.10) ** 2

    # - Long CV tail at high voltage (penalize stronger when cv_cutoff is very low)
    cv_stress = cv_tail_factor  # in [0,1]

    nominal_cycles = 1000.0 - 220.0 * current_stress - 320.0 * voltage_stress - 100.0 * cv_stress
    nominal_cycles = max(50.0, nominal_cycles)  # floor

    life_noise_sd = 30.0  # cycles
    cycle_life_cycles = float(nominal_cycles + _rng.normal(0.0, life_noise_sd))

    # Return means with SEMs (noise model: True)
    return {
        TIME_METRIC: (charge_time_minutes, time_noise_sd),
        LIFE_METRIC: (cycle_life_cycles, life_noise_sd),
    }


def is_dominated(a_time: float, a_life: float, b_time: float, b_life: float) -> bool:
    """
    Return True if point A is dominated by point B for:
      - minimize charge_time
      - maximize cycle_life
    """
    return (b_time <= a_time and b_life >= a_life) and (b_time < a_time or b_life > a_life)


def compute_empirical_pareto(df: pd.DataFrame, time_col: str, life_col: str) -> pd.DataFrame:
    """
    Compute the empirical Pareto frontier from observed data in df for:
      - minimize time_col
      - maximize life_col

    Returns a DataFrame of Pareto-optimal points.
    """
    df_valid = df[[time_col, life_col]].dropna().copy()
    if df_valid.empty:
        return df_valid

    mask = np.ones(len(df_valid), dtype=bool)
    times = df_valid[time_col].to_numpy()
    lifes = df_valid[life_col].to_numpy()

    for i in range(len(df_valid)):
        if not mask[i]:
            continue
        for j in range(len(df_valid)):
            if i == j or not mask[j]:
                continue
            if is_dominated(times[i], lifes[i], times[j], lifes[j]):
                mask[i] = False
                break

    pareto_df = df_valid[mask].copy().sort_values(by=time_col, ascending=True)
    return pareto_df


def main():
    # Initialize Ax client
    ax_client = AxClient()

    # Define the experiment: 3 charging parameters, 2 objectives (multi-objective)
    ax_client.create_experiment(
        name="fast_charging_protocol_optimization",
        parameters=[
            {
                "name": "cc_c_rate",
                "type": "range",
                "bounds": [0.5, 3.0],  # C
                "value_type": "float",
            },
            {
                "name": "charge_voltage_v",
                "type": "range",
                "bounds": [4.10, 4.35],  # V
                "value_type": "float",
            },
            {
                "name": "cv_cutoff_c_rate",
                "type": "range",
                "bounds": [0.01, 0.20],  # C
                "value_type": "float",
            },
        ],
        objectives={
            TIME_METRIC: ObjectiveProperties(minimize=True),
            LIFE_METRIC: ObjectiveProperties(minimize=False),
        },
    )

    # Budget: 35 trials (cells)
    for _ in range(35):
        parameterization, trial_index = ax_client.get_next_trial()
        results = evaluate_charging_protocol(parameterization)
        ax_client.complete_trial(trial_index=trial_index, raw_data=results)

    # Fetch results
    df = ax_client.get_trials_data_frame()

    # Compute empirical Pareto front from observed data
    pareto_df = compute_empirical_pareto(df, TIME_METRIC, LIFE_METRIC)

    # Plot results
    fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
    ax.scatter(df[TIME_METRIC], df[LIFE_METRIC], fc="None", ec="k", label="Observed")
    if not pareto_df.empty:
        ax.plot(
            pareto_df[TIME_METRIC].to_numpy(),
            pareto_df[LIFE_METRIC].to_numpy(),
            color="#0033FF",
            lw=2,
            label="Empirical Pareto Front",
        )
    ax.set_xlabel("Charge time (minutes)")
    ax.set_ylabel("Cycle life (cycles)")
    ax.legend()
    plt.tight_layout()
    plt.show()

    # Print Pareto-optimal parameterizations and outcomes
    if not pareto_df.empty:
        print("Empirical Pareto-optimal points (observed):")
        # Merge back to include parameterizations
        merged = df.merge(
            pareto_df[[TIME_METRIC, LIFE_METRIC]],
            on=[TIME_METRIC, LIFE_METRIC],
            how="inner",
        )
        cols_to_show = [
            "cc_c_rate",
            "charge_voltage_v",
            "cv_cutoff_c_rate",
            TIME_METRIC,
            LIFE_METRIC,
        ]
        available = [c for c in cols_to_show if c in merged.columns]
        print(merged[available].sort_values(by=TIME_METRIC).to_string(index=False))


if __name__ == "__main__":
    main()