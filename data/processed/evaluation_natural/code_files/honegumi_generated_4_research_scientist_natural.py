# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


objective_name = "ionic_conductivity"


def evaluate_electrolyte(
    salt1_concentration: float,
    salt2_concentration: float,
    salt3_concentration: float,
    salt4_concentration: float,
) -> dict:
    """
    Simulated evaluation of ionic conductivity (mS/cm) for a four-salt lithium electrolyte.

    Notes:
    - This function provides a realistic synthetic model to allow the script to run end-to-end.
    - In a real experiment, replace the computation below with an actual measurement of ionic conductivity.
    - Output includes a small SEM to reflect measurement noise, enabling a noisy Bayesian optimization setup.

    Model details (heuristic, for simulation only):
    - Baseline linear contribution from each salt, scaled by anion-dependent mobility factors.
    - Kohlrausch-like decrease in molar conductivity with sqrt(total concentration).
    - Synergy term that rewards diverse salt mixtures at fixed total concentration.
    - Viscosity penalty that reduces conductivity at higher total concentration.
    """
    c = np.array(
        [
            salt1_concentration,
            salt2_concentration,
            salt3_concentration,
            salt4_concentration,
        ],
        dtype=float,
    )
    total_c = float(np.sum(c))

    # Safety clamp for any minor numeric violations (should be enforced by Ax constraint)
    total_c = max(0.0, min(2.0, total_c))

    # Anion-dependent baseline mobilities (arbitrary, for simulation only; units: mS/cm per M)
    mobilities = np.array([10.5, 9.2, 12.8, 8.7], dtype=float)

    # Baseline linear contribution
    baseline = float(np.dot(mobilities, c))

    # Kohlrausch-like decrease with sqrt(total concentration) at higher ionic strengths
    # Factor in [~0.5, 1] over the range [0, 2] M
    alpha = 0.35
    kohlrausch_factor = 1.0 - alpha * np.sqrt(total_c / 2.0)
    kohlrausch_factor = float(np.clip(kohlrausch_factor, 0.2, 1.0))

    # Synergy term: favors compositional diversity at fixed total concentration
    if total_c > 1e-12:
        fractions = c / total_c
        diversity = 1.0 - float(np.sum(fractions**2))  # Gini-Simpson index
    else:
        diversity = 0.0
    gamma = 3.0  # scaling for synergy
    synergy = gamma * total_c * diversity

    # Viscosity penalty: suppress conductivity at higher concentrations
    beta = 0.5
    viscosity_factor = float(np.exp(-beta * total_c**1.5))

    # Combine effects
    conductivity = (baseline * kohlrausch_factor + synergy) * viscosity_factor

    # Add measurement noise (simulate noisy observation)
    rng = np.random.default_rng()
    noise_sigma = 0.05 * max(1.0, conductivity)  # relative noise ~5%
    observed = float(max(0.0, rng.normal(conductivity, noise_sigma)))

    # Provide SEM (standard error of the mean) for Ax to use a known-noise model
    sem = float(0.1 * noise_sigma + 0.005)  # small positive SEM

    return {objective_name: (observed, sem)}


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {
            "name": "salt1_concentration",
            "type": "range",
            "bounds": [0.0, 2.0],
        },
        {
            "name": "salt2_concentration",
            "type": "range",
            "bounds": [0.0, 2.0],
        },
        {
            "name": "salt3_concentration",
            "type": "range",
            "bounds": [0.0, 2.0],
        },
        {
            "name": "salt4_concentration",
            "type": "range",
            "bounds": [0.0, 2.0],
        },
    ],
    objectives={
        objective_name: ObjectiveProperties(minimize=False),
    },
    parameter_constraints=[
        "salt1_concentration + salt2_concentration + salt3_concentration + salt4_concentration <= 2.0",
    ],
)

num_trials = 40
observed_conductivities = []

for _ in range(num_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    s1 = parameterization["salt1_concentration"]
    s2 = parameterization["salt2_concentration"]
    s3 = parameterization["salt3_concentration"]
    s4 = parameterization["salt4_concentration"]

    results = evaluate_electrolyte(s1, s2, s3, s4)
    observed_conductivities.append(results[objective_name][0])

    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, best_metrics = ax_client.get_best_parameters()

print("Best parameterization found:")
for k, v in best_parameters.items():
    print(f"  {k}: {v:.4f}")
print(f"Best observed {objective_name}: {best_metrics[objective_name][0]:.4f} (SEM={best_metrics[objective_name][1]:.4f})")

# Plot results
trial_indices = np.arange(1, len(observed_conductivities) + 1)
best_so_far = np.maximum.accumulate(observed_conductivities)

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(trial_indices, observed_conductivities, ec="k", fc="none", label="Observed")
ax.plot(trial_indices, best_so_far, color="#0033FF", lw=2, label="Best to Trial")
ax.set_xlabel("Trial Number")
ax.set_ylabel(objective_name)
ax.legend()
plt.tight_layout()
plt.show()