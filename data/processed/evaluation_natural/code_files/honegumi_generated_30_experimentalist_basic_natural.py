# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    return y


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Generated by adapting a Honegumi skeleton to the packaging film optimization problem
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Problem: Optimize packaging film design to minimize oxygen permeability
# Parameters:
#   - thickness_microns: film thickness in micrometers [10, 80]
#   - coating_weight_g_m2: barrier coating weight in g/m^2 [0, 8]
# Objective:
#   - oxygen_permeability: lower is better (e.g., cc/m^2/day)
# Budget:
#   - 24 trials total
# Noise:
#   - True (we simulate measurement noise in the evaluation function)


metric_name = "oxygen_permeability"
rng = np.random.default_rng(12345)


def evaluate_packaging_film(thickness_microns: float, coating_weight_g_m2: float) -> dict:
    """Evaluate oxygen permeability for a given film thickness and coating weight.

    This is a physically inspired simulation stub to make the script executable.
    Replace with actual measurement or simulation code as needed.

    Model assumptions:
    - Base polymer oxygen transmission rate (OTR) ~ inversely proportional to thickness.
    - Coating adds barrier multiplicatively: exp(-k * coating_weight).
    - Diminishing returns at high thickness/coating captured via a mild interaction.
    - Add Gaussian measurement noise to reflect experimental uncertainty.

    Returns:
        dict: {"oxygen_permeability": float}
    """
    # Base parameters (tunable to match your material system)
    base_otr_at_20um = 150.0  # cc/m^2/day at 20 um with no coating (example)
    k_coating = 0.28          # barrier effectiveness per g/m^2 (example)
    interaction_scale = 0.02  # small interaction term for diminishing returns

    # Polymer contribution: inverse thickness scaling
    otr_polymer = base_otr_at_20um * (20.0 / thickness_microns)

    # Coating contribution: multiplicative barrier factor
    coating_factor = np.exp(-k_coating * max(coating_weight_g_m2, 0.0))

    # Interaction: diminishing returns when both thickness and coating are high
    interaction_term = 1.0 + interaction_scale * (thickness_microns / 80.0) * (coating_weight_g_m2 / 8.0)

    # Predicted oxygen permeability (lower is better)
    oxygen_permeability_pred = otr_polymer * coating_factor * interaction_term

    # Measurement noise: 2% relative + small absolute floor
    noise_std = 0.02 * oxygen_permeability_pred + 0.5
    noisy_measurement = max(oxygen_permeability_pred + rng.normal(0.0, noise_std), 0.0)

    return {metric_name: float(noisy_measurement)}


ax_client = AxClient()

# Define the optimization experiment
ax_client.create_experiment(
    parameters=[
        {
            "name": "thickness_microns",
            "type": "range",
            "bounds": [10.0, 80.0],  # typical packaging film thickness range
        },
        {
            "name": "coating_weight_g_m2",
            "type": "range",
            "bounds": [0.0, 8.0],  # realistic coating weight range
        },
    ],
    objectives={
        metric_name: ObjectiveProperties(minimize=True),
    },
)

# Optimization loop for 24 trials (budget)
for _ in range(24):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters
    thickness = float(parameterization["thickness_microns"])
    coating_weight = float(parameterization["coating_weight_g_m2"])

    # Evaluate experiment
    results = evaluate_packaging_film(thickness_microns=thickness, coating_weight_g_m2=coating_weight)

    # Report result back to Ax (dict of metric -> value)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve best parameters
best_parameters, best_metrics = ax_client.get_best_parameters()

print("Best parameters found:")
for k, v in best_parameters.items():
    print(f"  {k}: {v:.4f}")
print("Best objective value estimate(s):")
for metric, val in best_metrics.items():
    # val is typically a dict with "mean" and "sem", but depending on Ax version it may vary
    try:
        mean = val.get("mean", None)
        sem = val.get("sem", None)
        if mean is not None:
            if sem is not None:
                print(f"  {metric}: mean={mean:.4f}, sem={sem:.4f}")
            else:
                print(f"  {metric}: mean={mean:.4f}")
        else:
            # fallback if structure differs
            print(f"  {metric}: {val}")
    except AttributeError:
        # fallback if value is a plain float
        print(f"  {metric}: {val}")

# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

if metric_name in df.columns:
    y = df[metric_name].astype(float).values
    x = np.arange(len(y))
    fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
    ax.scatter(x, y, ec="k", fc="none", label="Observed")
    ax.plot(x, np.minimum.accumulate(y), color="#0033FF", lw=2, label="Best to Trial")
    ax.set_xlabel("Trial Number")
    ax.set_ylabel(metric_name)
    ax.legend()
    plt.tight_layout()
    plt.show()
else:
    print("Warning: Metric column not found in trials DataFrame; skipping plot.")