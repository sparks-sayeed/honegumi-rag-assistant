# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"
obj2_name = "branin_swapped"


def branin_moo(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # second objective has x1 and x2 swapped
    y2 = float(
        (x1 - 5.1 / (4 * np.pi**2) * x2**2 + 5.0 / np.pi * x2 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x2)
        + 10
    )

    return {obj1_name: y, obj2_name: y2}


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
        obj2_name: ObjectiveProperties(minimize=True),
    },
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin_moo(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)
pareto_results = ax_client.get_pareto_optimal_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto[objectives[0]],
    pareto[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])

ax.legend()
plt.show()

# Generated from Honegumi skeleton and adapted to universal ceramic binder optimization
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from typing import Dict, Tuple

from ax.service.ax_client import AxClient
from ax.service.utils.instantiation import ObjectiveProperties


# Objective metric names (maximize all)
OBJ_ALUMINA = "green_strength_alumina_mpa"
OBJ_ZIRCONIA = "green_strength_zirconia_mpa"
OBJ_SIC = "green_strength_sic_mpa"


def evaluate_binder_formulation(parameters: Dict[str, float]) -> Dict[str, Tuple[float, float]]:
    """
    Evaluate green strength for alumina, zirconia, and SiC for a given binder formulation.

    This is a realistic surrogate function meant to be replaced by actual lab measurements.
    Replace the calculations below with measurements from your experimental workflow:
      - Prepare batch for each ceramic powder using provided parameters
      - Measure green strength (e.g., 3-point bend) for each material
      - Return means and SEMs for each material

    Returned values are in MPa. SEM is set to 0.5 MPa by default to indicate moderate noise.
    """

    # Extract parameters
    binder_wt_pct = float(parameters["binder_wt_pct"])  # wt% binder in solids
    plasticizer_wt_pct = float(parameters["plasticizer_wt_pct"])  # wt% plasticizer in solids
    dispersant_wt_pct = float(parameters["dispersant_wt_pct"])  # wt% dispersant in solids
    solvent_to_solid_ratio = float(parameters["solvent_to_solid_ratio"])  # mass ratio
    mixing_time_min = float(parameters["mixing_time_min"])  # minutes
    drying_temperature_c = float(parameters["drying_temperature_c"])  # Celsius
    slurry_pH = float(parameters["slurry_pH"])  # pH

    # Helper to compute green strength from a "center" with quadratic penalties plus mild interactions
    def material_strength(center, weights, base_strength):
        # Normalize deviations
        x = np.array(
            [
                binder_wt_pct,
                plasticizer_wt_pct,
                dispersant_wt_pct,
                solvent_to_solid_ratio,
                mixing_time_min,
                drying_temperature_c,
                slurry_pH,
            ],
            dtype=float,
        )
        c = np.array(center, dtype=float)
        s = np.array(
            [
                3.0,   # binder scale
                1.2,   # plasticizer scale
                0.4,   # dispersant scale
                0.1,   # solvent ratio scale
                30.0,  # mixing time scale
                20.0,  # drying temperature scale
                1.2,   # pH scale
            ],
            dtype=float,
        )
        w = np.array(weights, dtype=float)
        z = (x - c) / s

        # Quadratic penalty around the center
        quad_penalty = np.sum(w * z**2)

        # Soft interactions capturing known effects:
        # - Too much plasticizer reduces strength (quartic penalty)
        plasticizer_penalty = 0.15 * max(0.0, (plasticizer_wt_pct - 2.5) / 1.5) ** 4
        # - Excess binder beyond 8 wt% can cause brittleness on drying
        binder_penalty = 0.1 * max(0.0, (binder_wt_pct - 8.0) / 2.5) ** 2
        # - Very high solvent ratio increases porosity after drying
        solvent_penalty = 0.2 * max(0.0, (solvent_to_solid_ratio - 0.45) / 0.1) ** 2
        # - Too low solvent ratio yields poor dispersion and voids
        low_solvent_penalty = 0.15 * max(0.0, (0.22 - solvent_to_solid_ratio) / 0.08) ** 2
        # - Mismatch between pH and center degrades dispersant performance (captured by quadratic, but add mild cosine for local roughness)
        ph_ripple = 0.15 * (1.0 - np.cos((slurry_pH - c[6]) * np.pi / 1.2))

        interaction_penalties = plasticizer_penalty + binder_penalty + solvent_penalty + low_solvent_penalty + ph_ripple

        # Combine
        strength = base_strength - 6.5 * quad_penalty - 4.0 * interaction_penalties

        return max(0.1, float(strength))

    # Material-specific centers and weights reflecting different optima
    # Center vector order: [binder, plasticizer, dispersant, solvent_ratio, mixing_time, drying_temp, pH]
    center_al = [4.2, 1.0, 0.45, 0.30, 60.0, 60.0, 9.0]
    weight_al = [1.2, 1.0, 1.4, 1.2, 0.6, 0.6, 0.8]
    base_al = 25.0

    center_zr = [5.0, 0.9, 0.80, 0.26, 70.0, 55.0, 10.0]
    weight_zr = [1.0, 1.0, 1.8, 1.4, 0.7, 0.6, 1.2]
    base_zr = 22.0

    center_sic = [6.5, 1.5, 0.30, 0.34, 90.0, 70.0, 8.5]
    weight_sic = [1.4, 0.9, 1.2, 1.0, 0.8, 0.7, 0.8]
    base_sic = 18.0

    # Compute strengths
    strength_al = material_strength(center_al, weight_al, base_al)
    strength_zr = material_strength(center_zr, weight_zr, base_zr)
    strength_sic = material_strength(center_sic, weight_sic, base_sic)

    # Add stochastic measurement noise; SEM fixed at 0.5 MPa
    rng = np.random.default_rng()
    noise_std = 0.6
    measured_al = max(0.1, strength_al + rng.normal(0.0, noise_std))
    measured_zr = max(0.1, strength_zr + rng.normal(0.0, noise_std))
    measured_sic = max(0.1, strength_sic + rng.normal(0.0, noise_std))

    sem = 0.5
    return {
        OBJ_ALUMINA: (measured_al, sem),
        OBJ_ZIRCONIA: (measured_zr, sem),
        OBJ_SIC: (measured_sic, sem),
    }


# Initialize Ax client and experiment
ax_client = AxClient()
ax_client.create_experiment(
    name="universal_ceramic_binder_moo",
    parameters=[
        {"name": "binder_wt_pct", "type": "range", "bounds": [1.0, 10.0]},
        {"name": "plasticizer_wt_pct", "type": "range", "bounds": [0.0, 5.0]},
        {"name": "dispersant_wt_pct", "type": "range", "bounds": [0.0, 2.0]},
        {"name": "solvent_to_solid_ratio", "type": "range", "bounds": [0.18, 0.55]},
        {"name": "mixing_time_min", "type": "range", "bounds": [10.0, 120.0]},
        {"name": "drying_temperature_c", "type": "range", "bounds": [25.0, 90.0]},
        {"name": "slurry_pH", "type": "range", "bounds": [7.0, 11.0]},
    ],
    objectives={
        OBJ_ALUMINA: ObjectiveProperties(minimize=False),
        OBJ_ZIRCONIA: ObjectiveProperties(minimize=False),
        OBJ_SIC: ObjectiveProperties(minimize=False),
    },
)


# Run optimization for the available budget: 120 trials (40 per material target)
N_TRIALS = 120
for i in range(N_TRIALS):
    parameters, trial_index = ax_client.get_next_trial()
    results = evaluate_binder_formulation(parameters)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)


# Retrieve all observed data
df = ax_client.get_trials_data_frame()

# Keep only the completed trials with all objective columns
objective_cols = [OBJ_ALUMINA, OBJ_ZIRCONIA, OBJ_SIC]
df = df.dropna(subset=objective_cols)

# Compute Pareto-optimal set via nondominated sorting (maximize all)
def nondominated_mask(values: np.ndarray) -> np.ndarray:
    n = values.shape[0]
    mask = np.ones(n, dtype=bool)
    for i in range(n):
        if not mask[i]:
            continue
        # Point i is dominated if there exists j != i such that values[j] >= values[i] for all and > for at least one
        dominates = np.all(values >= values[i], axis=1) & np.any(values > values[i], axis=1)
        dominates[i] = False
        if np.any(dominates):
            mask[i] = False
    return mask

vals = df[objective_cols].to_numpy(dtype=float)
pareto_mask = nondominated_mask(vals)
pareto_df = df.loc[pareto_mask].copy()

# Print top 5 Pareto points by min-strength across materials (robust "universal" candidates)
df["min_across_materials"] = df[objective_cols].min(axis=1)
top_universal = df.sort_values("min_across_materials", ascending=False).head(5)
print("Top 5 universal binder candidates by worst-case (min) green strength [MPa]:")
print(top_universal[["trial_index", "arm_name"] + objective_cols + ["min_across_materials"]])

# Plot pairwise scatter with Pareto highlight
fig, axes = plt.subplots(1, 3, figsize=(13, 4), dpi=140)

pairs = [
    (OBJ_ALUMINA, OBJ_ZIRCONIA, "Alumina vs Zirconia"),
    (OBJ_ALUMINA, OBJ_SIC, "Alumina vs SiC"),
    (OBJ_ZIRCONIA, OBJ_SIC, "Zirconia vs SiC"),
]
for ax, (x_name, y_name, title) in zip(axes, pairs):
    ax.scatter(df[x_name], df[y_name], fc="None", ec="gray", alpha=0.6, label="Observed")
    ax.scatter(
        pareto_df[x_name],
        pareto_df[y_name],
        c="#0033FF",
        s=28,
        label="Pareto-optimal",
    )
    ax.set_xlabel(x_name.replace("_", " "))
    ax.set_ylabel(y_name.replace("_", " "))
    ax.set_title(title)
    ax.grid(alpha=0.2)
    ax.legend()

plt.tight_layout()
plt.show()