# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Seed for reproducibility of the noise in the synthetic evaluator
rng = np.random.default_rng(12345)


# Objective metric name
objective_metric_name = "compressive_strength_MPa"
# Constraint metric name for enforcing cement_content >= water_content
constraint_metric_name = "cement_ge_water_violation"


def simulate_compressive_strength(aggregate_content: float, cement_content: float, water_content: float) -> float:
    """
    Synthetic, physically-inspired surrogate for 28-day compressive strength (MPa) of a high-performance concrete (HPC).
    Key drivers:
      - Water-to-cement ratio (w/c): lower is stronger up to a point; optimum around ~0.30-0.35 for HPC.
      - Aggregate fraction: too little reduces skeleton; too much reduces paste for bonding; optimum around ~0.65-0.70.
      - Cement fraction: very low cement limits strength (binder deficiency).
    This surrogate returns a plausible strength in MPa in the range roughly 20-120 MPa for reasonable mixes.
    """
    # Guard against division by zero in w/c
    w_over_c = water_content / max(cement_content, 1e-6)

    # Peak strengths and optima (tunable)
    strength_max = 120.0  # MPa, representative upper bound for HPC
    w_c_opt = 0.32
    w_c_width = 0.10

    agg_opt = 0.68
    agg_width = 0.10

    # Penalize very low cement contents (< 0.18-0.20)
    cement_floor = 0.20
    cement_penalty = 1.0
    if cement_content < cement_floor:
        cement_penalty = max(0.6, 1.0 - 1.2 * (cement_floor - cement_content) / cement_floor)

    # Gaussian penalties around optima
    w_c_factor = np.exp(-((w_over_c - w_c_opt) / w_c_width) ** 2)
    agg_factor = np.exp(-((aggregate_content - agg_opt) / agg_width) ** 2)

    # Mild penalty if water fraction is extremely small (workability)
    workability_floor = 0.05
    water_penalty = 1.0
    if water_content < workability_floor:
        water_penalty = max(0.8, 1.0 - 1.5 * (workability_floor - water_content) / workability_floor)

    # Combine effects
    strength = strength_max * w_c_factor * agg_factor * cement_penalty * water_penalty

    # Keep in a reasonable range
    strength = float(np.clip(strength, 5.0, 140.0))
    return strength


# Define total for compositional constraint, where aggregate + cement + water == total_fraction
total_fraction = 1.0


ax_client = AxClient()

ax_client.create_experiment(
    name="hpc_mix_design_optimization",
    parameters=[
        # We reparameterize the composition by optimizing only aggregate and cement.
        # Water is computed as the residual: water = 1 - (aggregate + cement).
        {"name": "aggregate_content", "type": "range", "bounds": [0.0, total_fraction]},
        {"name": "cement_content", "type": "range", "bounds": [0.0, total_fraction]},
    ],
    objectives={
        objective_metric_name: ObjectiveProperties(minimize=False),
    },
    # Parameter constraints:
    # 1) Compositional: aggregate + cement <= 1.0  (implies water >= 0)
    # 2) Ordering: aggregate_content >= cement_content
    parameter_constraints=[
        f"aggregate_content + cement_content <= {total_fraction}",
        "cement_content <= aggregate_content",
    ],
    # Outcome constraint to enforce cement_content >= water_content (which is nonlinear in the reparameterization).
    # We model constraint metric as: cement_ge_water_violation = max(0, water - cement) <= 0.0
    outcome_constraints=[f"{constraint_metric_name} <= 0.0"],
)


# Number of trials
n_trials = 40

# For plotting / logging
observed_strengths = []  # store objective values (NaN if constraint violated)
violations = []  # store violation values


for _ in range(n_trials):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    aggregate = float(parameterization["aggregate_content"])
    cement = float(parameterization["cement_content"])
    water = float(total_fraction - (aggregate + cement))  # composition constraint: aggregate + cement + water == 1.0

    # Compute violation: cement_content >= water_content  -> violation = max(0, water - cement)
    cement_vs_water_violation = max(0.0, water - cement)

    if cement_vs_water_violation > 0.0:
        # Skip expensive objective computation if constraint is violated
        ax_client.complete_trial(
            trial_index=trial_index,
            raw_data={constraint_metric_name: (cement_vs_water_violation, 0.0)},
        )
        observed_strengths.append(np.nan)
        violations.append(cement_vs_water_violation)
        continue

    # Compute objective when feasible
    strength = simulate_compressive_strength(aggregate_content=aggregate, cement_content=cement, water_content=water)

    # Add measurement noise (SEM reflects observational noise level)
    sem_strength = 2.0  # MPa
    noisy_strength = strength + rng.normal(0.0, sem_strength)

    ax_client.complete_trial(
        trial_index=trial_index,
        raw_data={
            objective_metric_name: (float(noisy_strength), float(sem_strength)),
            constraint_metric_name: (0.0, 0.0),
        },
    )
    observed_strengths.append(float(noisy_strength))
    violations.append(0.0)


best_parameters, best_metrics = ax_client.get_best_parameters()


# Plot results (objective over trials and best-so-far trace)
y = np.array(observed_strengths, dtype=float)
x = np.arange(1, len(y) + 1)
best_so_far = []
current_best = -np.inf
for val in y:
    if np.isfinite(val):
        current_best = max(current_best, val)
    best_so_far.append(current_best if np.isfinite(current_best) else np.nan)

fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
ax.scatter(x, y, ec="k", fc="none", label="Observed compressive strength")
ax.plot(x, best_so_far, color="#0033FF", lw=2, label="Best so far")
ax.set_xlabel("Trial Number")
ax.set_ylabel("Compressive Strength (MPa)")
ax.set_title("High-Performance Concrete Mix Optimization")
ax.legend()
plt.tight_layout()
plt.show()