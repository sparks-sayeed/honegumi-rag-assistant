# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


np.random.seed(42)


yield_metric_name = "product_yield_percent"


def evaluate_reactor_yield(
    temperature_c: float, pressure_bar: float, residence_time_min: float
) -> dict:
    """
    Evaluate reactor performance (product yield in percent) for given operating conditions.

    NOTE: Replace the surrogate model below with actual experimental measurement logic.
    For real use:
      - Run the reaction at (temperature_c, pressure_bar, residence_time_min)
      - Measure the product yield (0-100%)
      - Return: {"product_yield_percent": measured_yield}

    The surrogate here is a smooth, physically inspired response surface with stochastic noise,
    to allow executable demonstration without lab hardware.
    """

    # Gaussian-like peaks with interaction shifts to emulate realistic optima/compromises.
    # Temperature effect
    t_opt = 185.0  # optimal temperature [C]
    t_width = 28.0
    t_comp = np.exp(-0.5 * ((temperature_c - t_opt) / t_width) ** 2)

    # Pressure optimum depends mildly on temperature (e.g., higher T -> higher optimal P)
    p_opt = 12.0 + 0.06 * (temperature_c - 150.0)  # [bar]
    p_width = 6.0
    p_comp = np.exp(-0.5 * ((pressure_bar - p_opt) / p_width) ** 2)

    # Residence time optimum decreases slightly as temperature increases
    tau_opt = 4.2 - 0.008 * (temperature_c - 150.0)  # [min]
    tau_width = 1.2
    tau_comp = np.exp(-0.5 * ((residence_time_min - tau_opt) / tau_width) ** 2)

    # Weighted combination with mild interactions
    base_response = 0.15 + 0.85 * (0.5 * t_comp + 0.3 * p_comp + 0.2 * tau_comp)
    interaction = 0.5 + 0.5 * (t_comp * p_comp * tau_comp) ** (1.0 / 3.0)

    clean_yield = 100.0 * base_response * interaction

    # Add small heteroscedastic noise to emulate experimental variability
    noise_scale = 1.0 + 0.5 * (1.0 - t_comp * p_comp * tau_comp)
    noisy_yield = clean_yield + np.random.normal(loc=0.0, scale=1.5 * noise_scale)

    # Clamp to physical bounds
    y = float(np.clip(noisy_yield, 0.0, 100.0))

    return {yield_metric_name: y}


ax_client = AxClient(enforce_sequential_optimization=True, random_seed=123)

ax_client.create_experiment(
    name="reactor_yield_optimization",
    parameters=[
        {
            "name": "temperature_c",
            "type": "range",
            "bounds": [80.0, 260.0],
            "value_type": "float",
        },
        {
            "name": "pressure_bar",
            "type": "range",
            "bounds": [1.0, 40.0],
            "value_type": "float",
        },
        {
            "name": "residence_time_min",
            "type": "range",
            "bounds": [0.5, 8.0],
            "value_type": "float",
        },
    ],
    objectives={
        yield_metric_name: ObjectiveProperties(minimize=False),
    },
    # Observation noise is assumed present by default when passing raw float data.
)


total_trials = 35

for _ in range(total_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters for this trial
    temperature_c = parameterization["temperature_c"]
    pressure_bar = parameterization["pressure_bar"]
    residence_time_min = parameterization["residence_time_min"]

    # Run evaluation (replace with real experiment or simulation)
    results = evaluate_reactor_yield(temperature_c, pressure_bar, residence_time_min)

    # Report result back to Ax (as noisy observation without known SEM)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results[yield_metric_name])


best_parameters, best_values = ax_client.get_best_parameters()

print("Best operating conditions found:")
for k, v in best_parameters.items():
    print(f"  {k}: {v}")

print("\nBest observed yield (model-predicted mean):")
try:
    if isinstance(best_values, dict) and yield_metric_name in best_values:
        metric_info = best_values[yield_metric_name]
        if isinstance(metric_info, dict) and "mean" in metric_info:
            print(f"  {yield_metric_name}: {metric_info['mean']:.2f} % (SEM ~ {metric_info.get('sem', float('nan')):.2f})")
        else:
            print(f"  {yield_metric_name}: {metric_info}")
    else:
        print(best_values)
except Exception as e:
    print(f"  Unable to parse best value: {e}")


# Plot results
df = ax_client.get_trials_data_frame()
metric = yield_metric_name
y_series = pd.to_numeric(df[metric], errors="coerce")

fig, ax = plt.subplots(figsize=(7, 4.5), dpi=150)
ax.scatter(df.index, y_series, ec="k", fc="none", label="Observed yield")
ax.plot(df.index, np.maximum.accumulate(y_series.fillna(-np.inf)), color="#0033FF", lw=2, label="Best to Trial")
ax.set_xlabel("Trial Number")
ax.set_ylabel("Product Yield (%)")
ax.set_title("Reactor Yield Optimization with Bayesian Optimization (Ax)")
ax.legend()
plt.tight_layout()
plt.show()