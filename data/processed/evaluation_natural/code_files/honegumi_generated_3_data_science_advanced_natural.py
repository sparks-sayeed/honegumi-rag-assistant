# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Objective (metric) names
STRENGTH_METRIC = "tensile_strength_mpa"
BIODEG_METRIC = "biodegradability_index"

# Composition total for monomer fractions
COMPOSITION_TOTAL = 1.0

# Random seed for reproducibility of the synthetic evaluator
np.random.seed(42)


# Synthetic evaluator for polymer formulation properties.
# This simulates how monomer composition, extrusion rate, and temperature impact
# tensile strength (MPa) and biodegradability (0-1). Replace with real measurement code.
def evaluate_polymer_formulation(parameterization: dict) -> dict:
    # Unpack parameters from Ax
    a = float(parameterization["monomer_A_fraction"])
    b = float(parameterization["monomer_B_fraction"])
    c = float(parameterization["monomer_C_fraction"])
    d = float(parameterization["monomer_D_fraction"])
    extrusion_rate = float(parameterization["extrusion_rate_mm_per_s"])
    temperature = float(parameterization["temperature_celsius"])

    # Hidden variable from the composition constraint: compute monomer_E fraction
    e = COMPOSITION_TOTAL - (a + b + c + d)
    # Numerical safety: clip small negatives to zero
    if e < 0.0:
        e = 0.0
    if e > 1.0:
        e = 1.0

    fractions = np.array([a, b, c, d, e])

    # Intrinsic monomer contributions (domain-inspired placeholders)
    # Approximate per-monomer contributions to strength (MPa) and biodegradability (0-1)
    strength_coeffs = np.array([85.0, 60.0, 40.0, 105.0, 30.0])
    biodeg_coeffs = np.array([0.20, 0.55, 0.85, 0.10, 0.90])

    # Monomer-specific optimal processing temperatures (C) for strength
    monomer_temp_opt = np.array([185.0, 165.0, 145.0, 215.0, 135.0])

    # Base linear contributions
    base_strength = float(np.dot(fractions, strength_coeffs))
    base_biodeg = float(np.dot(fractions, biodeg_coeffs))

    # Effective optimal temperature as composition-weighted
    temp_opt = float(np.dot(fractions, monomer_temp_opt))
    # Temperature influence: Gaussian around temp_opt
    temp_sigma_strength = 25.0
    temp_factor_strength = np.exp(-((temperature - temp_opt) / temp_sigma_strength) ** 2)

    # Biodegradability typically prefers gentler processing (lower T); penalize high T
    temp_sigma_biodeg = 35.0
    temp_factor_biodeg = np.exp(-((temperature - (temp_opt - 15.0)) / temp_sigma_biodeg) ** 2)

    # Extrusion rate influences:
    # Strength best around moderate rate (shear aligns chains, too high causes defects)
    rate_opt_strength = 3.0
    rate_sigma_strength = 2.0
    rate_factor_strength = np.exp(-((extrusion_rate - rate_opt_strength) / rate_sigma_strength) ** 2)

    # Biodegradability might increase with more porosity at lower rates
    rate_pref_biodeg = 1.8
    rate_sigma_biodeg = 1.6
    rate_factor_biodeg = np.exp(-((extrusion_rate - rate_pref_biodeg) / rate_sigma_biodeg) ** 2)

    # Synergy / antagonism terms
    # A-D synergy boosts strength; C-E synergy boosts biodegradability
    strength_synergy = 18.0 * min(a, d) + 6.0 * a * c - 5.0 * e * d
    biodeg_synergy = 0.20 * c * e + 0.05 * b * c - 0.10 * a * d

    # Assemble final metrics
    strength = base_strength * (0.6 + 0.4 * temp_factor_strength) * (0.6 + 0.4 * rate_factor_strength) + strength_synergy
    # Slight degradation of strength if e is very high
    strength *= (1.0 - 0.10 * e)

    biodeg = base_biodeg * (0.7 + 0.3 * temp_factor_biodeg) * (0.7 + 0.3 * rate_factor_biodeg) + biodeg_synergy
    # Normalize biodegradability to [0, 1]
    biodeg = max(0.0, min(1.0, biodeg))

    # Add measurement noise and provide SEMs to Ax (noisy experiment)
    strength_sem = 2.0
    biodeg_sem = 0.03

    strength_obs = float(np.random.normal(loc=strength, scale=strength_sem))
    biodeg_obs = float(np.random.normal(loc=biodeg, scale=biodeg_sem))

    # Clip to realistic ranges
    strength_obs = max(0.0, min(150.0, strength_obs))
    biodeg_obs = max(0.0, min(1.0, biodeg_obs))

    return {
        STRENGTH_METRIC: (strength_obs, strength_sem),
        BIODEG_METRIC: (biodeg_obs, biodeg_sem),
    }


# Historical data (3 points) from literature or prior runs.
# NOTE: Replace the below with your actual historical measurements.
# Parameterizations only include monomer_A..D; monomer_E is implied by the composition constraint.
historical_params = pd.DataFrame(
    [
        {
            "monomer_A_fraction": 0.30,
            "monomer_B_fraction": 0.20,
            "monomer_C_fraction": 0.10,
            "monomer_D_fraction": 0.25,
            "extrusion_rate_mm_per_s": 3.0,
            "temperature_celsius": 190.0,
        },
        {
            "monomer_A_fraction": 0.10,
            "monomer_B_fraction": 0.10,
            "monomer_C_fraction": 0.50,
            "monomer_D_fraction": 0.20,
            "extrusion_rate_mm_per_s": 2.0,
            "temperature_celsius": 160.0,
        },
        {
            "monomer_A_fraction": 0.40,
            "monomer_B_fraction": 0.10,
            "monomer_C_fraction": 0.05,
            "monomer_D_fraction": 0.25,
            "extrusion_rate_mm_per_s": 4.0,
            "temperature_celsius": 205.0,
        },
    ]
)

# Compute historical outcomes (replace with your actual measured outcomes if available)
historical_outcomes = [
    evaluate_polymer_formulation(row.to_dict()) for _, row in historical_params.iterrows()
]


# Create the Ax client and experiment
ax_client = AxClient()

ax_client.create_experiment(
    name="polymer_formulation_multiobjective",
    parameters=[
        # Only 4 monomer fractions are explicit; the 5th is computed to satisfy the composition constraint
        {"name": "monomer_A_fraction", "type": "range", "bounds": [0.0, 1.0], "value_type": "float"},
        {"name": "monomer_B_fraction", "type": "range", "bounds": [0.0, 1.0], "value_type": "float"},
        {"name": "monomer_C_fraction", "type": "range", "bounds": [0.0, 1.0], "value_type": "float"},
        {"name": "monomer_D_fraction", "type": "range", "bounds": [0.0, 1.0], "value_type": "float"},
        # Process parameters
        {"name": "extrusion_rate_mm_per_s", "type": "range", "bounds": [0.5, 10.0], "value_type": "float"},
        {"name": "temperature_celsius", "type": "range", "bounds": [120.0, 240.0], "value_type": "float"},
    ],
    objectives={
        # Maximize strength with a minimum desired threshold of 70 MPa
        STRENGTH_METRIC: ObjectiveProperties(minimize=False, threshold=70.0),
        # Maximize biodegradability; threshold optional (Ax will infer if omitted)
        BIODEG_METRIC: ObjectiveProperties(minimize=False),
    },
    parameter_constraints=[
        # Composition constraint: monomer_E_fraction = 1 - (A+B+C+D) >= 0  => A+B+C+D <= 1
        "monomer_A_fraction + monomer_B_fraction + monomer_C_fraction + monomer_D_fraction <= 1.0",
    ],
)

# Attach existing historical data to bootstrap the model
for i in range(len(historical_params)):
    params = historical_params.iloc[i].to_dict()
    ax_client.attach_trial(params)
    ax_client.complete_trial(trial_index=i, raw_data=historical_outcomes[i])

# Optimization loop
n_trials = 25
for _ in range(n_trials):
    try:
        parameterization, trial_index = ax_client.get_next_trial()
    except Exception as e:
        # In case Ax requests more data before proceeding (DataRequiredError), break and proceed with what we have
        # Users can also set AxClient(enforce_sequential_optimization=False) if needed.
        print(f"Stopped generating more trials due to: {e}")
        break

    # Evaluate with the simulator/measurement function
    results = evaluate_polymer_formulation(parameterization)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Fetch observed Pareto-optimal points
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
# Scatter all observed points
ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")

# Build Pareto frontier from observed Pareto-optimal points
try:
    pareto_data = [p[1][0] for p in pareto.values()]  # Extract metric means dicts
    pareto_df = pd.DataFrame(pareto_data).sort_values(objectives[0])
    ax.plot(
        pareto_df[objectives[0]],
        pareto_df[objectives[1]],
        color="#0033FF",
        lw=2,
        label="Pareto Front",
    )
except Exception:
    # Fallback if structure differs
    pass

ax.set_xlabel(f"{objectives[0]}")
ax.set_ylabel(f"{objectives[1]}")
ax.legend()
plt.tight_layout()
plt.show()