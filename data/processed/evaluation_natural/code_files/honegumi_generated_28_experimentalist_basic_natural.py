# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Optimization goal: Maximize extraction efficiency (%) by tuning temperature (C)
# and solvent-to-solid ratio (mL solvent per g solid). Budget: 26 experiments.

objective_name = "extraction_efficiency"


def evaluate_extraction_process(temperature_celsius: float, solvent_to_solid_ratio_ml_per_g: float) -> dict:
    """
    Evaluate the extraction efficiency for the given process settings.

    NOTE: This is a realistic simulation stub to make the script runnable.
    Replace the simulated calculation with actual experimental measurement or
    a validated process model that returns the measured extraction efficiency (%).

    How to integrate with real experiments:
    - Run the extraction at `temperature_celsius` and `solvent_to_solid_ratio_ml_per_g`.
    - Measure the extraction efficiency as a percentage (0 to 100).
    - Optionally estimate and return the standard error of the mean (SEM) from replicates.

    Returns:
        dict: {
            "extraction_efficiency": (measured_mean_percent, sem_percent)
        }
    """
    # Simulated "true" response surface (domain-inspired but arbitrary):
    # - Temperature effect: peaked around 65 C with moderate width
    temp_opt = 65.0
    temp_width = 12.0
    temp_effect = np.exp(-0.5 * ((temperature_celsius - temp_opt) / temp_width) ** 2)

    # - Solvent ratio effect: saturating response with diminishing returns
    #   at higher solvent-to-solid ratio.
    k_sat = 0.17
    ratio_effect = 1.0 - np.exp(-k_sat * solvent_to_solid_ratio_ml_per_g)

    # Combined effect scaled to a plausible max efficiency
    max_eff = 95.0  # %
    baseline = 5.0  # %
    true_eff = baseline + max_eff * (0.15 + 0.85 * temp_effect) * ratio_effect

    # Add measurement noise (simulate a noisy lab measurement)
    measurement_noise_sd = 2.0  # percentage points
    measured_eff = float(true_eff + np.random.normal(0.0, measurement_noise_sd))

    # Clip to [0, 100] since efficiencies are percentages
    measured_eff = float(np.clip(measured_eff, 0.0, 100.0))

    # Provide SEM to inform the model about observation noise
    sem_percent = float(measurement_noise_sd)

    return {objective_name: (measured_eff, sem_percent)}


# For reproducibility of the simulation stub
np.random.seed(1234)

ax_client = AxClient()

# Define the search space:
# - temperature_celsius: 25 to 90 C
# - solvent_to_solid_ratio_ml_per_g: 1 to 20 mL/g
ax_client.create_experiment(
    parameters=[
        {
            "name": "temperature_celsius",
            "type": "range",
            "bounds": [25.0, 90.0],
        },
        {
            "name": "solvent_to_solid_ratio_ml_per_g",
            "type": "range",
            "bounds": [1.0, 20.0],
        },
    ],
    objectives={
        objective_name: ObjectiveProperties(minimize=False),
    },
)

# Run 26 sequential trials (default GPEI with Sobol initialization inside Ax)
num_trials = 26
for _ in range(num_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters
    T = float(parameterization["temperature_celsius"])
    R = float(parameterization["solvent_to_solid_ratio_ml_per_g"])

    # Evaluate (replace with actual lab/plant measurement in production)
    results = evaluate_extraction_process(T, R)

    # Report results back to Ax (include SEM to model noise)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve best found parameters and corresponding objective value
best_parameters, best_values = ax_client.get_best_parameters()
print("Best parameters found:")
for k, v in best_parameters.items():
    print(f"  {k}: {v}")
print("Best objective values (model-estimated):")
for metric_name, val_dict in best_values.items():
    # val_dict contains "mean" and "sem"
    print(f"  {metric_name}: mean={val_dict.get('mean'):.3f}, sem={val_dict.get('sem'):.3f}")

# Plot results
objective_names = ax_client.objective_names
df = ax_client.get_trials_data_frame()

# Extract the metric series (observed means)
y = df[objective_names[0]].astype(float).to_numpy()
x = np.arange(len(y))

best_so_far = np.maximum.accumulate(y)

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(x, y, ec="k", fc="none", label="Observed")
ax.plot(x, best_so_far, color="#0033FF", lw=2, label="Best to Trial")
ax.set_xlabel("Trial Number")
ax.set_ylabel(f"{objective_names[0]} (%)")
ax.set_title("Extraction Efficiency Optimization")
ax.legend()
plt.tight_layout()
plt.show()