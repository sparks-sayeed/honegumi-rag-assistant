# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain-specific objective names
refractive_index_metric = "refractive_index"
absorption_metric = "absorption_coefficient_cm_inv"


def simulate_glass_optics(
    silica_fraction: float,
    boron_oxide_fraction: float,
    lead_oxide_fraction: float,
    rng: np.random.Generator | None = None,
) -> dict[str, float]:
    """
    Simulate two competing optical properties for a ternary glass system:
    - refractive_index (to maximize)
    - absorption_coefficient_cm_inv (to minimize)

    This is a realistic stub using mixture rules and simple phenomenology:
    - Refractive index is computed via Lorentz–Lorenz mixing rule.
    - Absorption is modeled as a convex combination with non-linear penalties.

    TODO: Replace with actual experimental/simulation logic when available.
    """

    if rng is None:
        rng = np.random.default_rng()

    # Validate fractions
    if silica_fraction < 0 or boron_oxide_fraction < 0 or lead_oxide_fraction < 0:
        raise ValueError("All oxide fractions must be non-negative.")
    total = silica_fraction + boron_oxide_fraction + lead_oxide_fraction
    if not np.isclose(total, 1.0, atol=1e-6):
        raise ValueError(f"Fractions must sum to 1.0, got {total:.6f}")

    # Component properties at ~589 nm (illustrative values)
    n_silica = 1.458
    n_boron = 1.61
    n_lead = 2.50

    # Lorentz–Lorenz mixing rule for refractive index
    def L(n: float) -> float:
        return (n**2 - 1.0) / (n**2 + 2.0)

    L_mix = (
        silica_fraction * L(n_silica)
        + boron_oxide_fraction * L(n_boron)
        + lead_oxide_fraction * L(n_lead)
    )
    # Guard against numerical issues
    L_mix = np.clip(L_mix, -0.99, 0.99)
    n_eff = np.sqrt((1.0 + 2.0 * L_mix) / (1.0 - L_mix))

    # Absorption coefficient model (1/cm)
    # Baseline component absorptions (illustrative)
    alpha_silica = 0.010
    alpha_boron = 0.030
    alpha_lead = 0.250

    absorption = (
        silica_fraction * alpha_silica
        + boron_oxide_fraction * alpha_boron
        + lead_oxide_fraction * alpha_lead
    )

    # Non-linear composition effects:
    # - Lead increases absorption super-linearly
    # - Lead-Boron synergy slightly increases absorption
    # - Silica-Boron network formation slightly reduces absorption
    absorption += 0.60 * (lead_oxide_fraction ** 2)
    absorption += 0.10 * lead_oxide_fraction * boron_oxide_fraction
    absorption -= 0.02 * silica_fraction * boron_oxide_fraction

    # Add measurement noise (to reflect experimental noise model)
    n_noise = rng.normal(0.0, 0.001)  # refractive index noise
    a_noise = rng.normal(0.0, 0.005)  # absorption noise (1/cm)

    refractive_index_value = float(n_eff + n_noise)
    absorption_value = float(max(0.0, absorption + a_noise))

    return {
        refractive_index_metric: refractive_index_value,
        absorption_metric: absorption_value,
    }


# Composition total (fractions must sum to 1.0)
total_fraction = 1.0

# Initialize Ax client
ax_client = AxClient()

# We reparameterize the compositional constraint by optimizing two variables
# and computing the third as the remainder to ensure the sum equals 1.0.
ax_client.create_experiment(
    parameters=[
        {"name": "silica_fraction", "type": "range", "bounds": [0.0, total_fraction]},
        {"name": "boron_oxide_fraction", "type": "range", "bounds": [0.0, total_fraction]},
    ],
    objectives={
        refractive_index_metric: ObjectiveProperties(minimize=False),
        absorption_metric: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"silica_fraction + boron_oxide_fraction <= {total_fraction}",
    ],
)

# Optimization loop
num_trials = 36
rng = np.random.default_rng(2025)

for _ in range(num_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters and compute the third fraction to satisfy the composition constraint
    silica = float(parameterization["silica_fraction"])
    boron = float(parameterization["boron_oxide_fraction"])
    lead = total_fraction - (silica + boron)  # enforce silica + boron + lead == 1.0

    # Safety clamp for potential floating-point drift (should be ~0 anyway due to constraint)
    lead = float(np.clip(lead, 0.0, 1.0))

    results = simulate_glass_optics(silica, boron, lead, rng=rng)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve Pareto-optimal parameterizations
pareto_results = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

# Prepare data for plotting
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
# pareto.values() contains tuples; we extract the observed means dict
pareto_means = [p[1][0] for p in pareto.values()]
pareto_df = pd.DataFrame(pareto_means).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto_df[objectives[0]],
    pareto_df[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.set_xlabel(objectives[0].replace("_", " "))
ax.set_ylabel(objectives[1].replace("_", " "))
ax.set_title("Multi-objective Optimization of Glass Composition")
ax.legend()
plt.tight_layout()
plt.show()