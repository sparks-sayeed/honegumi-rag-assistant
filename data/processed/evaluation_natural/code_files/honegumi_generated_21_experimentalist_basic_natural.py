# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from typing import Dict

from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Metric names (objectives)
CONTAMINANT_METRIC = "contaminant_level"  # effluent contaminant concentration (e.g., mg/L)
COST_METRIC = "cost"  # chemical cost per unit water treated (e.g., USD/m^3)


def evaluate_water_treatment(
    coagulant_mg_per_L: float,
    oxidant_mg_per_L: float,
    adsorbent_mg_per_L: float,
    rng: np.random.Generator,
) -> Dict[str, float]:
    """
    Simulated evaluation of a water treatment process with three chemicals.

    Parameters (doses in mg/L):
      - coagulant_mg_per_L: dose of coagulant (e.g., alum or PAC)
      - oxidant_mg_per_L: dose of oxidant (e.g., chlorine, ozone)
      - adsorbent_mg_per_L: dose of adsorbent (e.g., powdered activated carbon)

    Returns:
      - contaminant_level: effluent contaminant concentration (lower is better)
      - cost: chemical cost per m^3 treated water (lower is better)

    This function is a realistic simulation stub with nonlinear dose-response, synergy,
    diminishing returns, and injected noise to mimic experimental variability.
    Replace with actual measurements if available.
    """
    # Base influent contaminant concentration (mg/L)
    influent_conc = 120.0

    # Effective treatment intensity capturing individual effects and synergies
    # Coagulant: effective for particle-associated contaminants
    # Oxidant: strong effect for oxidizable contaminants
    # Adsorbent: useful for organic micropollutants
    coag = max(0.0, coagulant_mg_per_L)
    ox = max(0.0, oxidant_mg_per_L)
    ads = max(0.0, adsorbent_mg_per_L)

    # Individual contributions (scaled)
    intensity = 0.040 * coag + 0.350 * ox + 0.012 * ads

    # Mild pairwise synergies
    intensity += 0.004 * np.sqrt(coag * ads + 1e-12)
    intensity += 0.010 * (coag * ox) / 100.0

    # Diminishing returns saturation
    contaminant_out = influent_conc * np.exp(-intensity / 10.0)

    # Floor due to irreducible residuals
    contaminant_out = max(0.5, contaminant_out)

    # Add measurement/process noise (heteroscedastic)
    contaminant_noise = rng.normal(loc=0.0, scale=0.03 * contaminant_out + 0.2)
    contaminant_measured = max(0.0, contaminant_out + contaminant_noise)

    # Cost model (USD per m^3): weighted sum of doses plus small fixed overhead
    # Costs chosen to reflect that oxidants tend to be pricier per mg/L.
    cost = 0.0020 * coag + 0.0100 * ox + 0.0040 * ads + 0.015
    cost_noise = rng.normal(loc=0.0, scale=0.02 * cost + 0.001)
    cost_measured = max(0.0, cost + cost_noise)

    return {
        CONTAMINANT_METRIC: float(contaminant_measured),
        COST_METRIC: float(cost_measured),
    }


# Initialize Ax client
ax_client = AxClient()

# Define the optimization experiment
# Assumed safe/practical dose ranges (mg/L). Adjust to your plant's operating ranges if known.
ax_client.create_experiment(
    name="water_treatment_3chem_moo",
    parameters=[
        {
            "name": "coagulant_mg_per_L",
            "type": "range",
            "bounds": [0.0, 100.0],
        },
        {
            "name": "oxidant_mg_per_L",
            "type": "range",
            "bounds": [0.0, 10.0],
        },
        {
            "name": "adsorbent_mg_per_L",
            "type": "range",
            "bounds": [0.0, 200.0],
        },
    ],
    objectives={
        CONTAMINANT_METRIC: ObjectiveProperties(minimize=True),
        COST_METRIC: ObjectiveProperties(minimize=True),
    },
)

# Budget: 32 trials
NUM_TRIALS = 32
rng = np.random.default_rng(seed=12345)

for _ in range(NUM_TRIALS):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract doses
    coag = float(parameterization["coagulant_mg_per_L"])
    ox = float(parameterization["oxidant_mg_per_L"])
    ads = float(parameterization["adsorbent_mg_per_L"])

    # Evaluate and report results back to Ax
    results = evaluate_water_treatment(coag, ox, ads, rng)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve Pareto-optimal trials based on observed data
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

# Prepare data for plotting
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

pareto_dicts = [p[1][0] for p in pareto.values()]  # extract observed means per metric
pareto_df = pd.DataFrame(pareto_dicts).sort_values(objectives[0])

# Plot observed points and the empirical Pareto front
fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(
    df[objectives[0]],
    df[objectives[1]],
    fc="None",
    ec="k",
    label="Observed",
)

ax.plot(
    pareto_df[objectives[0]],
    pareto_df[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)

ax.set_xlabel(f"{objectives[0]}")
ax.set_ylabel(f"{objectives[1]}")
ax.set_title("Water Treatment Optimization: Contaminant vs Cost")
ax.legend()
plt.tight_layout()
plt.show()