# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain-specific metric names
WATER_QUALITY = "water_quality"
TREATMENT_COST = "treatment_cost_per_m3_usd"


def evaluate_water_treatment(
    coagulant_mg_per_L: float,
    polymer_mg_per_L: float,
    chlorine_mg_per_L: float,
    rng: np.random.Generator,
) -> dict:
    """
    Simulated evaluation of a water treatment plant run.

    Parameters
    - coagulant_mg_per_L: Alum or similar coagulant dose in mg/L
    - polymer_mg_per_L: Polymer aid dose in mg/L
    - chlorine_mg_per_L: Free chlorine dose in mg/L
    - rng: numpy random generator for noise

    Returns
    - dict mapping objective names to (mean, SEM)
      WATER_QUALITY is a score [0, 100] to maximize
      TREATMENT_COST is USD per m^3 to minimize
    """
    # Prices per kg
    price_alum_per_kg = 0.40
    price_polymer_per_kg = 4.00
    price_chlorine_per_kg = 1.50

    # Cost computation: mg/L equals g/m^3; kg/m^3 = dose/1000
    cost_alum = price_alum_per_kg * (coagulant_mg_per_L / 1000.0)
    cost_polymer = price_polymer_per_kg * (polymer_mg_per_L / 1000.0)
    cost_chlorine = price_chlorine_per_kg * (chlorine_mg_per_L / 1000.0)
    base_cost = cost_alum + cost_polymer + cost_chlorine

    # Small operational overhead tied to higher doses (mixing/handling complexity)
    overhead = 0.0002 * (
        (coagulant_mg_per_L / 60.0) ** 1.3
        + (polymer_mg_per_L / 1.0) ** 1.5
        + (chlorine_mg_per_L / 5.0) ** 1.2
    )
    true_cost = base_cost + overhead

    # Quality model (higher is better):
    # - Coagulant drives turbidity removal with saturation
    # - Polymer synergizes with coagulant
    # - Chlorine drives pathogen inactivation with saturation
    # - Overdosing penalties (taste/odor or residuals)
    coagulant_sat = 1.0 - np.exp(-0.06 * coagulant_mg_per_L)
    polymer_synergy = (1.0 - np.exp(-4.0 * polymer_mg_per_L)) * (coagulant_mg_per_L / 60.0)
    chlorine_sat = 1.0 - np.exp(-1.0 * chlorine_mg_per_L)

    # Normalize and weight components
    removal_component = 0.65 * np.clip(coagulant_sat + 0.4 * polymer_synergy, 0.0, 1.5)
    disinfection_component = 0.35 * np.clip(chlorine_sat, 0.0, 1.0)

    # Overdose penalties
    penalty = 0.0
    if coagulant_mg_per_L > 45.0:
        penalty += 0.15 * ((coagulant_mg_per_L - 45.0) / 15.0) ** 1.5
    if polymer_mg_per_L > 0.6:
        penalty += 0.20 * ((polymer_mg_per_L - 0.6) / 0.4) ** 1.7
    if chlorine_mg_per_L > 3.0:
        penalty += 0.25 * ((chlorine_mg_per_L - 3.0) / 2.0) ** 1.4

    true_quality = 100.0 * np.clip(removal_component + disinfection_component - penalty, 0.0, 1.0)

    # Measurement noise (noise model True)
    quality_noise_sd = 1.5
    cost_noise_sd = 0.0005

    measured_quality = float(true_quality + rng.normal(0.0, quality_noise_sd))
    measured_cost = float(true_cost + rng.normal(0.0, cost_noise_sd))

    # Standard errors (unknown true SEM; using noise sd as a proxy)
    return {
        WATER_QUALITY: (measured_quality, quality_noise_sd),
        TREATMENT_COST: (measured_cost, cost_noise_sd),
    }


def compute_pareto_front(df: pd.DataFrame, quality_col: str, cost_col: str) -> pd.DataFrame:
    """
    Compute the Pareto frontier for two objectives: maximize quality, minimize cost.
    Returns a dataframe of non-dominated points.
    """
    df = df[[quality_col, cost_col]].dropna().copy()
    if df.empty:
        return df

    # Sort by quality descending; track best (lowest) cost so far.
    df_sorted = df.sort_values(quality_col, ascending=False)
    best_cost = np.inf
    pareto_rows = []
    for _, row in df_sorted.iterrows():
        c = row[cost_col]
        if c <= best_cost:
            pareto_rows.append(row)
            best_cost = c

    pareto_df = pd.DataFrame(pareto_rows)
    return pareto_df.sort_values(quality_col, ascending=True)


def main():
    rng = np.random.default_rng(12345)

    ax_client = AxClient()
    ax_client.create_experiment(
        name="water_treatment_optimization",
        parameters=[
            {
                "name": "coagulant_mg_per_L",
                "type": "range",
                "bounds": [5.0, 60.0],
                "value_type": "float",
            },
            {
                "name": "polymer_mg_per_L",
                "type": "range",
                "bounds": [0.0, 1.0],
                "value_type": "float",
            },
            {
                "name": "chlorine_mg_per_L",
                "type": "range",
                "bounds": [0.2, 5.0],
                "value_type": "float",
            },
        ],
        objectives={
            WATER_QUALITY: ObjectiveProperties(minimize=False),
            TREATMENT_COST: ObjectiveProperties(minimize=True),
        },
    )

    # Run up to 32 trials (ask/tell loop)
    for _ in range(32):
        parameters, trial_index = ax_client.get_next_trial()

        coagulant = float(parameters["coagulant_mg_per_L"])
        polymer = float(parameters["polymer_mg_per_L"])
        chlorine = float(parameters["chlorine_mg_per_L"])

        results = evaluate_water_treatment(
            coagulant_mg_per_L=coagulant,
            polymer_mg_per_L=polymer,
            chlorine_mg_per_L=chlorine,
            rng=rng,
        )
        ax_client.complete_trial(trial_index=trial_index, raw_data=results)

    # Retrieve results and Pareto front
    df = ax_client.get_trials_data_frame()
    pareto_df = compute_pareto_front(df, WATER_QUALITY, TREATMENT_COST)

    # Plot observed points and Pareto front
    fig, ax = plt.subplots(figsize=(7, 5), dpi=150)
    ax.scatter(
        df[WATER_QUALITY],
        df[TREATMENT_COST],
        fc="None",
        ec="k",
        label="Observed",
    )
    if not pareto_df.empty:
        ax.plot(
            pareto_df[WATER_QUALITY],
            pareto_df[TREATMENT_COST],
            color="#0033FF",
            lw=2,
            label="Pareto Front",
        )
    ax.set_xlabel("Water quality score (higher is better)")
    ax.set_ylabel("Treatment cost ($/m^3, lower is better)")
    ax.set_title("Water Treatment: Cost-Quality Tradeoff")
    ax.legend()
    plt.tight_layout()
    plt.show()

    # Print a few Pareto-optimal parameterizations
    print("\nSample Pareto-optimal runs (quality, cost, doses):")
    merged = pareto_df.merge(
        df[["trial_index", WATER_QUALITY, TREATMENT_COST, "coagulant_mg_per_L", "polymer_mg_per_L", "chlorine_mg_per_L"]],
        on=[WATER_QUALITY, TREATMENT_COST],
        how="left",
    ).drop_duplicates(subset=[WATER_QUALITY, TREATMENT_COST])
    for _, row in merged.sort_values(WATER_QUALITY, ascending=False).head(5).iterrows():
        print(
            f"Quality={row[WATER_QUALITY]:.1f}, Cost=${row[TREATMENT_COST]:.4f}/m^3 | "
            f"Coagulant={row['coagulant_mg_per_L']:.2f} mg/L, "
            f"Polymer={row['polymer_mg_per_L']:.3f} mg/L, "
            f"Chlorine={row['chlorine_mg_per_L']:.2f} mg/L"
        )


if __name__ == "__main__":
    main()