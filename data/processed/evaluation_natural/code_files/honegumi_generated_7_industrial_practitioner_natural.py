# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"
obj2_name = "branin_swapped"


def branin3_moo(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    # second objective has x1 and x2 swapped
    y2 = float(
        (x1 - 5.1 / (4 * np.pi**2) * x2**2 + 5.0 / np.pi * x2 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x2)
        + 10
    )

    # Contrived way to incorporate x3 into the second objective
    y2 = y2 * (1 - 0.1 * x1 * x2 * x3)

    return {obj1_name: y, obj2_name: y2}


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
        obj2_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
        "1.0*x1 + 0.5*x2 <= 15.0",  # example of a linear constraint. Note the lack of space around the asterisks
    ],
)


for i in range(21):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]
    x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

    results = branin3_moo(x1, x2, x3)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)
pareto_results = ax_client.get_pareto_optimal_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto[objectives[0]],
    pareto[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])

ax.legend()
plt.show()

# Generated for steel alloy design optimization with Ax Platform
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain-specific objective names
strength_metric = "strength"  # MPa, ultimate tensile strength proxy
corrosion_metric = "corrosion_resistance"  # arbitrary resistance index (higher is better)

# Elemental upper limits (mass fraction, 0-1). Adjust if your metallurgical limits differ.
CR_MAX = 0.25  # Chromium upper bound (e.g., 25 wt%)
NI_MAX = 0.25  # Nickel upper bound (e.g., 25 wt%)
MO_MAX = 0.10  # Molybdenum upper bound (e.g., 10 wt%)

# Composition total (fractions sum to 1.0)
TOTAL_FRACTION = 1.0

# Experimental budget
N_TRIALS = 40

# Reproducible noise
rng = np.random.default_rng(2025)


def evaluate_steel_alloy(Cr: float, Ni: float, Mo: float) -> dict:
    """
    Evaluate alloy performance from composition.
    Returns a mapping: metric_name -> (mean, sem)
    - Strength (MPa): proxy from solid solution strengthening and simple penalties.
    - Corrosion resistance (arb. units): proxy inspired by PREN-like contributions.

    NOTE: Replace with actual measurements or simulation hooks when available.
    """
    # Enforce composition closure
    Fe = TOTAL_FRACTION - (Cr + Ni + Mo)
    if Fe < -1e-8:
        # Invalid composition due to numerical error or constraint violation
        # Return strongly penalized values to discourage this region.
        return {
            strength_metric: (0.0, 50.0),
            corrosion_metric: (0.0, 5.0),
        }

    Fe = max(Fe, 0.0)  # guard small negative due to float error

    # Strength model (MPa) - simplistic proxy:
    # - Baseline ferritic matrix strength
    # - Solid solution strengthening: Mo > Ni > Cr
    # - Synergy between Cr and Mo
    # - Penalty for excessive total alloying (processing/phase issues)
    # - Mild penalty for very high Fe (very lean alloy)
    total_alloy = Cr + Ni + Mo
    base_strength = 400.0
    ss_strength = 900.0 * Mo + 600.0 * Ni + 300.0 * Cr
    synergy = 2000.0 * Mo * Cr
    over_alloy_penalty = 3000.0 * max(0.0, total_alloy - 0.35) ** 2
    lean_penalty = 500.0 * max(0.0, Fe - 0.95) ** 2
    strength_mean = base_strength + ss_strength + synergy - over_alloy_penalty - lean_penalty
    strength_mean = max(0.0, strength_mean)

    # Corrosion resistance proxy (arb. units):
    # - Cr and Mo major contributors (PREN-like), Ni modest helper
    # - Penalty if Cr too low (passivity threshold)
    # - Penalty for very lean alloy (high Fe)
    pren_like = 100.0 * Cr + 300.0 * Mo + 50.0 * Ni
    low_cr_penalty = 800.0 * max(0.0, 0.12 - Cr) ** 2
    lean_corrosion_penalty = 80.0 * max(0.0, Fe - 0.92) ** 2
    corrosion_mean = pren_like - low_cr_penalty - lean_corrosion_penalty
    corrosion_mean = max(0.0, corrosion_mean)

    # Add measurement noise (simulate) and report SEM
    # Here we return means without injecting noise into the mean, but provide SEM to Ax.
    # If you have replicate measurements, set SEM as std/sqrt(n).
    strength_sem = 0.02 * max(1.0, strength_mean) + 5.0  # ~2% + 5 MPa baseline
    corrosion_sem = 0.03 * max(1.0, corrosion_mean) + 0.5  # ~3% + 0.5 baseline

    return {
        strength_metric: (float(strength_mean), float(strength_sem)),
        corrosion_metric: (float(corrosion_mean), float(corrosion_sem)),
    }


ax_client = AxClient()

ax_client.create_experiment(
    name="steel_alloy_design_moo",
    parameters=[
        {"name": "Cr", "type": "range", "bounds": [0.0, CR_MAX]},
        {"name": "Ni", "type": "range", "bounds": [0.0, NI_MAX]},
        {"name": "Mo", "type": "range", "bounds": [0.0, MO_MAX]},
    ],
    objectives={
        strength_metric: ObjectiveProperties(minimize=False),
        corrosion_metric: ObjectiveProperties(minimize=False),
    },
    parameter_constraints=[
        f"Cr + Ni + Mo <= {TOTAL_FRACTION}",  # compositional closure enforced via reparameterization (Fe derived)
    ],
    overwrite_existing_experiment=True,
)


for i in range(N_TRIALS):
    try:
        parameterization, trial_index = ax_client.get_next_trial()

        Cr = float(parameterization["Cr"])
        Ni = float(parameterization["Ni"])
        Mo = float(parameterization["Mo"])
        Fe = TOTAL_FRACTION - (Cr + Ni + Mo)

        # Safety check (should be ensured by constraints)
        if Fe < -1e-6:
            ax_client.log_trial_failure(trial_index=trial_index)
            continue

        results = evaluate_steel_alloy(Cr=Cr, Ni=Ni, Mo=Mo)
        ax_client.complete_trial(trial_index=trial_index, raw_data=results)

    except Exception as e:
        # Log trial failure and continue
        try:
            ax_client.log_trial_failure(trial_index=trial_index)
        except Exception:
            pass


# Retrieve Pareto-optimal observed points
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

# Build dataframe of Pareto means for plotting
objectives = ax_client.objective_names
pareto_means = []
for _, (_, metric_values) in pareto.items():
    # metric_values: dict of metric -> (mean, sem)
    means_row = {metric: float(val[0]) for metric, val in metric_values.items()}
    pareto_means.append(means_row)
pareto_df = pd.DataFrame(pareto_means)
if not pareto_df.empty:
    pareto_df = pareto_df.sort_values(objectives[0])

# Plot results
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
if objectives[0] in df.columns and objectives[1] in df.columns:
    ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
if not pareto_df.empty:
    ax.plot(
        pareto_df[objectives[0]],
        pareto_df[objectives[1]],
        color="#0033FF",
        lw=2,
        label="Pareto Front",
    )

ax.set_xlabel(f"{objectives[0]}")
ax.set_ylabel(f"{objectives[1]}")
ax.set_title("Steel Alloy Design: Strength vs. Corrosion Resistance")
ax.legend()
plt.tight_layout()
plt.show()