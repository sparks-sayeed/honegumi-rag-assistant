# Generated by adapting Honegumi skeleton for microbial fermentation optimization
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Problem: Optimize nutrient concentrations (A, B, C) to maximize biomass production (g/L)
# Budget: 30 cultures (trials)
# Model: Default GP (AxClient default generation strategy)
# Noise: True (we simulate measurement noise in the evaluation function)


OBJECTIVE_NAME = "biomass_production"  # units: g/L
N_TRIALS = 30

rng = np.random.default_rng(seed=42)  # for reproducibility of the simulated measurements


def evaluate_biomass_production(
    nutrient_A_concentration: float,
    nutrient_B_concentration: float,
    nutrient_C_concentration: float,
) -> dict[str, float]:
    """
    Simulated evaluation of microbial biomass production (g/L) given nutrient concentrations.

    Parameters
    - nutrient_A_concentration: carbon source concentration (g/L), typical effective range ~ 0–20
    - nutrient_B_concentration: nitrogen source concentration (g/L), typical effective range ~ 0–10
    - nutrient_C_concentration: phosphate/mineral concentration (g/L), typical effective range ~ 0–5

    This function represents a plausible, smooth, noisy response surface with:
      - saturating benefits at moderate concentrations,
      - an optimal carbon:nitrogen ratio,
      - toxicity penalties at high concentrations,
      - additive measurement/process noise.

    TODO: Replace this simulation with actual experimental measurement or a validated process model.
    Return format must be a dict mapping metric name(s) to observed value(s).
    """
    A = float(nutrient_A_concentration)
    B = float(nutrient_B_concentration)
    C = float(nutrient_C_concentration)

    # Saturation terms (Michaelis–Menten-like)
    def sat(x: float, K: float) -> float:
        return x / (x + K + 1e-9)

    fA = sat(A, K=8.0)   # carbon saturation
    fB = sat(B, K=3.0)   # nitrogen saturation
    fC = sat(C, K=0.8)   # phosphate/mineral saturation

    # Ratio synergy: prefer A:B around ~2.5:1
    ratio = A / (B + 1e-6)
    synergy = np.exp(-0.5 * ((ratio - 2.5) / 1.0) ** 2)  # Gaussian peak at 2.5

    # Toxicity/overfeeding penalties beyond soft thresholds
    overA = max(0.0, A - 12.0) / 4.0
    overB = max(0.0, B - 6.0) / 2.0
    overC = max(0.0, C - 2.0) / 1.5
    toxicity = np.exp(-0.5 * (overA**2 + overB**2 + overC**2))

    # Combine effects into expected biomass (g/L)
    Y_MAX = 15.0  # plausible upper bound for biomass concentration (g/L)
    baseline = 0.2  # small baseline growth
    expected_biomass = Y_MAX * fA * fB * fC * synergy * toxicity + baseline

    # Add measurement/process noise (heteroscedastic)
    noise_std = 0.05 * expected_biomass + 0.15  # 5% relative + 0.15 g/L absolute
    observed_biomass = float(rng.normal(loc=expected_biomass, scale=noise_std))
    observed_biomass = max(0.0, observed_biomass)  # biomass cannot be negative

    return {OBJECTIVE_NAME: observed_biomass}


# Configure Ax optimization
ax_client = AxClient()

ax_client.create_experiment(
    name="fermentation_nutrient_optimization",
    parameters=[
        # Units for all bounds are g/L
        {"name": "nutrient_A_concentration", "type": "range", "bounds": [0.0, 20.0]},
        {"name": "nutrient_B_concentration", "type": "range", "bounds": [0.0, 10.0]},
        {"name": "nutrient_C_concentration", "type": "range", "bounds": [0.0, 5.0]},
    ],
    objectives={
        OBJECTIVE_NAME: ObjectiveProperties(minimize=False),
    },
)

# Optimization loop for the 30-culture study
for _ in range(N_TRIALS):
    parameterization, trial_index = ax_client.get_next_trial()

    A = parameterization["nutrient_A_concentration"]
    B = parameterization["nutrient_B_concentration"]
    C = parameterization["nutrient_C_concentration"]

    try:
        results = evaluate_biomass_production(A, B, C)
    except Exception as e:
        # In case evaluation fails, mark trial as failed and continue
        ax_client.log_trial_failure(trial_index=trial_index)
        print(f"Trial {trial_index} failed with error: {e}")
        continue

    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve best parameters and metric
best_parameters, best_metrics = ax_client.get_best_parameters()

print("Best nutrient concentrations found:")
for k, v in best_parameters.items():
    print(f"  {k}: {v:.4f} g/L")

best_obj = best_metrics[OBJECTIVE_NAME]
if isinstance(best_obj, dict) and "mean" in best_obj:
    print(f"Best observed {OBJECTIVE_NAME}: {best_obj['mean']:.4f} g/L")
else:
    # AxClient may return a float in some versions/configurations
    try:
        print(f"Best observed {OBJECTIVE_NAME}: {float(best_obj):.4f} g/L")
    except Exception:
        print(f"Best observed {OBJECTIVE_NAME}: {best_obj}")

# Plot results
objective_name = ax_client.objective_names[0]
df = ax_client.get_trials_data_frame()

y = df[objective_name]
fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, y, ec="k", fc="none", label="Observed")
ax.plot(df.index, np.maximum.accumulate(y.values), color="#0033FF", lw=2, label="Best to Trial")
ax.set_xlabel("Trial Number")
ax.set_ylabel(f"{objective_name} (g/L)")
ax.set_title("Biomass production over trials")
ax.legend()
plt.tight_layout()
plt.show()