# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    return y


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Generated for optimizing microbial fermentation nutrient composition using Ax Platform
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain-specific metric name
objective_name = "biomass_production_g_per_l"


def evaluate_fermentation(
    carbon_source_g_per_l: float,
    nitrogen_source_g_per_l: float,
    phosphate_g_per_l: float,
) -> dict:
    """Simulate biomass production (g/L) for a microbial fermentation given nutrient concentrations.

    This is a realistic stub intended to be replaced by actual experimental measurement.
    It models:
    - Saturation kinetics for each nutrient (Liebig's law of the minimum)
    - Inhibition at excessively high concentrations
    - Balance effects for C:N:P ratios
    - Additive experimental noise (SEM reported to Ax to inform noise model)

    Replace with actual lab measurement by:
    - Running a culture with the provided concentrations
    - Measuring biomass concentration at harvest (e.g., dry cell weight g/L)
    - Returning {"biomass_production_g_per_l": (measured_value, measurement_sem)}

    Args:
        carbon_source_g_per_l: Concentration of carbon source (e.g., glucose), g/L
        nitrogen_source_g_per_l: Concentration of nitrogen source (e.g., ammonium sulfate), g/L
        phosphate_g_per_l: Concentration of phosphate (e.g., KH2PO4), g/L

    Returns:
        dict mapping metric name to (mean, sem)
    """
    c = float(carbon_source_g_per_l)
    n = float(nitrogen_source_g_per_l)
    p = float(phosphate_g_per_l)

    # Saturation (Michaelis-Menten-like)
    c_sat = c / (c + 10.0)
    n_sat = n / (n + 2.0)
    p_sat = p / (p + 0.5)
    limitation = min(c_sat, n_sat, p_sat)  # Liebig's law

    # Inhibition beyond toxicity thresholds (monotonic decay past threshold)
    def inhibition(x, tox_threshold, decay):
        excess = max(0.0, x - tox_threshold)
        return float(np.exp(-excess / decay))

    inh_c = inhibition(c, tox_threshold=40.0, decay=15.0)
    inh_n = inhibition(n, tox_threshold=10.0, decay=5.0)
    inh_p = inhibition(p, tox_threshold=3.0, decay=1.5)
    high_conc_penalty = inh_c * inh_n * inh_p

    # Ratio balance around practical target ratios (C:N ~ 6, C:P ~ 25)
    eps = 1e-8
    ratio_c_n = c / max(n, eps)
    ratio_c_p = c / max(p, eps)
    balance_cn = np.exp(-((ratio_c_n - 6.0) ** 2) / (2.0 * 2.0**2))
    balance_cp = np.exp(-((ratio_c_p - 25.0) ** 2) / (2.0 * 10.0**2))
    balance_penalty = float(balance_cn * balance_cp)

    # Max achievable biomass for this strain/process (domain-adjustable)
    base_max_biomass = 15.0  # g/L

    # Combine effects
    biomass_mean = base_max_biomass * limitation * high_conc_penalty * balance_penalty

    # Add realistic experimental noise; report SEM to Ax
    rng = np.random.default_rng()
    measurement_noise_sd = 0.3  # g/L standard deviation of measurement
    observed_biomass = max(0.0, float(biomass_mean + rng.normal(0.0, measurement_noise_sd)))
    sem = measurement_noise_sd  # report SEM; adjust if averaging replicates

    return {objective_name: (observed_biomass, sem)}


# Configure Ax client
ax_client = AxClient()

# Define the experiment with domain-specific parameters and single objective (maximize biomass)
ax_client.create_experiment(
    parameters=[
        {
            "name": "carbon_source_g_per_l",  # e.g., glucose
            "type": "range",
            "bounds": [5.0, 50.0],
        },
        {
            "name": "nitrogen_source_g_per_l",  # e.g., ammonium sulfate
            "type": "range",
            "bounds": [0.5, 15.0],
        },
        {
            "name": "phosphate_g_per_l",  # e.g., KH2PO4
            "type": "range",
            "bounds": [0.1, 5.0],
        },
    ],
    objectives={
        objective_name: ObjectiveProperties(minimize=False),
    },
)

# Run optimization for the planned budget of 30 cultures (trials)
total_trials = 30
for _ in range(total_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract concentrations
    c = parameterization["carbon_source_g_per_l"]
    n = parameterization["nitrogen_source_g_per_l"]
    p = parameterization["phosphate_g_per_l"]

    # Evaluate
    results = evaluate_fermentation(c, n, p)

    # Complete trial with noisy observation
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve best parameters and corresponding metric
best_parameters, best_metrics = ax_client.get_best_parameters()

# Display summary
print("Best nutrient composition found:")
for k, v in best_parameters.items():
    print(f"  {k}: {v:.4f}")
print("Estimated best biomass production (mean ± SEM):")
print(
    f"  {objective_name}: {best_metrics[objective_name][0]:.3f} ± {best_metrics[objective_name][1]:.3f} g/L"
)

# Plot results
metric = ax_client.objective_names[0]
df = ax_client.get_trials_data_frame()

# Ensure we have the metric column as a 1D series
y = df[metric].astype(float)
x = df.index.values
best_so_far = np.maximum.accumulate(y.values)

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(x, y, ec="k", fc="none", label="Observed biomass")
ax.plot(x, best_so_far, color="#0033FF", lw=2, label="Best so far")
ax.set_xlabel("Trial number")
ax.set_ylabel("Biomass (g/L)")
ax.set_title("Optimization of nutrient composition for biomass production")
ax.legend()
plt.tight_layout()
plt.show()