# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"
obj2_name = "branin_swapped"


def branin3_moo(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    # second objective has x1 and x2 swapped
    y2 = float(
        (x1 - 5.1 / (4 * np.pi**2) * x2**2 + 5.0 / np.pi * x2 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x2)
        + 10
    )

    # Contrived way to incorporate x3 into the second objective
    y2 = y2 * (1 - 0.1 * x1 * x2 * x3)

    return {obj1_name: y, obj2_name: y2}


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
        obj2_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
    ],
)


for i in range(21):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]
    x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

    results = branin3_moo(x1, x2, x3)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)
pareto_results = ax_client.get_pareto_optimal_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto[objectives[0]],
    pareto[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])

ax.legend()
plt.show()

# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain: Ink formulation optimization
# Parameters are ingredient fractions that must sum to 1.0 (compositional constraint).
# We model three independent fractions and derive the fourth to enforce the equality.
TOTAL_FRACTION = 1.0

# Two objectives to maximize:
# - conductivity: proxy for electrical performance (higher is better)
# - printability: proxy for jetting/line quality (higher is better)


def evaluate_ink_formulation(parameterization: dict) -> dict:
    """
    Simulate evaluation of an ink formulation. Replace with real measurements.

    Inputs:
      parameterization: dict with three free fractions. The fourth is derived to satisfy the sum-to-1 constraint.

    Returns:
      Dict mapping objective names to (mean, SEM) tuples.
    """
    # Extract free parameters
    conductive_filler_fraction = float(parameterization["conductive_filler_fraction"])
    polymer_binder_fraction = float(parameterization["polymer_binder_fraction"])
    solvent_fraction = float(parameterization["solvent_fraction"])

    # Enforce composition equality by deriving the fourth fraction
    rheology_modifier_fraction = TOTAL_FRACTION - (
        conductive_filler_fraction + polymer_binder_fraction + solvent_fraction
    )

    # Guard against tiny numerical issues
    rheology_modifier_fraction = max(0.0, rheology_modifier_fraction)

    # Effective solids (non-volatile)
    solids = max(1e-9, 1.0 - solvent_fraction)

    # Fractions within solids
    phi_cond = np.clip(conductive_filler_fraction / solids, 0.0, 1.0)
    phi_binder = np.clip(polymer_binder_fraction / solids, 0.0, 1.0)
    phi_rheo = np.clip(rheology_modifier_fraction / solids, 0.0, 1.0)

    # Conductivity model (percolation-like behavior)
    percolation_threshold = 0.12  # conductive volume fraction threshold in solids
    beta = 1.5
    base_cond = np.maximum(0.0, phi_cond - percolation_threshold) ** beta
    # Penalize excessive binder and rheology content for conductivity
    cond_penalty = np.exp(-2.0 * phi_binder) * np.exp(-1.0 * phi_rheo)
    # Higher solvent reduces conduction network connectivity slightly
    solvent_penalty = np.exp(-0.5 * (solvent_fraction / 0.4) ** 2)
    conductivity = base_cond * cond_penalty * solvent_penalty

    # Printability model (peaks near balanced formulation)
    # Target region (heuristic): solvent ~ 0.35, binder ~ 0.25 of solids, rheology ~ 0.05 of solids
    solvent_opt = 0.35
    binder_opt = 0.25
    rheo_opt = 0.05

    solvent_score = np.exp(-((solvent_fraction - solvent_opt) ** 2) / (2 * 0.10**2))
    binder_score = np.exp(-((phi_binder - binder_opt) ** 2) / (2 * 0.10**2))
    rheo_score = np.exp(-((phi_rheo - rheo_opt) ** 2) / (2 * 0.03**2))
    # Penalize extremely low solids for print fidelity
    solids_score = 1.0 - np.exp(-5.0 * solids)

    printability = solvent_score * binder_score * rheo_score * solids_score

    # Add small, heteroscedastic noise and provide SEM as a rough estimate
    rng = np.random.default_rng()
    cond_noise_sd = 0.02
    print_noise_sd = 0.02

    conductivity_meas = float(np.clip(conductivity + rng.normal(0.0, cond_noise_sd), 0.0, None))
    printability_meas = float(np.clip(printability + rng.normal(0.0, print_noise_sd), 0.0, None))

    return {
        "conductivity": (conductivity_meas, cond_noise_sd),
        "printability": (printability_meas, print_noise_sd),
    }


ax_client = AxClient()
ax_client.create_experiment(
    name="ink_formulation_moo",
    parameters=[
        {
            "name": "conductive_filler_fraction",
            "type": "range",
            "bounds": [0.0, TOTAL_FRACTION],
            "value_type": "float",
        },
        {
            "name": "polymer_binder_fraction",
            "type": "range",
            "bounds": [0.0, TOTAL_FRACTION],
            "value_type": "float",
        },
        {
            "name": "solvent_fraction",
            "type": "range",
            "bounds": [0.0, TOTAL_FRACTION],
            "value_type": "float",
        },
        # The rheology_modifier_fraction is derived to enforce the sum-to-1 constraint.
    ],
    objectives={
        "conductivity": ObjectiveProperties(minimize=False),
        "printability": ObjectiveProperties(minimize=False),
    },
    parameter_constraints=[
        # Reparameterized compositional equality: sum of free vars <= 1; the remainder is rheology_modifier_fraction
        "conductive_filler_fraction + polymer_binder_fraction + solvent_fraction <= 1.0"
    ],
)

# Run 45 sequential trials (budget)
for i in range(45):
    parameterization, trial_index = ax_client.get_next_trial()

    # Derive the fourth fraction to satisfy the composition equality
    parameterization = dict(parameterization)  # shallow copy to augment
    parameterization["rheology_modifier_fraction"] = TOTAL_FRACTION - (
        parameterization["conductive_filler_fraction"]
        + parameterization["polymer_binder_fraction"]
        + parameterization["solvent_fraction"]
    )

    results = evaluate_ink_formulation(parameterization)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Prepare data for plotting and Pareto extraction from observations
df = ax_client.get_trials_data_frame()
df = df.dropna(subset=["conductivity", "printability"])

# Compute observed Pareto frontier (maximization on both metrics)
def is_dominated(row, others):
    return np.any(
        (others["conductivity"] >= row["conductivity"])
        & (others["printability"] >= row["printability"])
        & (
            (others["conductivity"] > row["conductivity"])
            | (others["printability"] > row["printability"])
        )
    )


mask = []
for idx, row in df.iterrows():
    others = df.drop(index=idx)
    mask.append(not is_dominated(row, others))
pareto_df = df[mask].copy()
pareto_df = pareto_df.sort_values(by="conductivity")

# Plot results
fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df["conductivity"], df["printability"], fc="None", ec="k", label="Observed")
if len(pareto_df) > 0:
    ax.plot(
        pareto_df["conductivity"],
        pareto_df["printability"],
        color="#0033FF",
        lw=2,
        label="Observed Pareto Front",
    )
ax.set_xlabel("conductivity")
ax.set_ylabel("printability")
ax.legend()
plt.tight_layout()
plt.show()