# Generated by Honegumi (adapted to pharmaceutical formulation MOO)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from ax.service.ax_client import AxClient, ObjectiveProperties


# Domain-specific objective names
BIOAVAILABILITY = "bioavailability"
STABILITY = "stability"


def evaluate_formulation(parameterization):
    """
    Simulated evaluation of a pharmaceutical formulation with two competing objectives:
    - bioavailability (maximize, 0-100)
    - stability (maximize, 0-100)

    Parameters include 4 explicit excipient fractions (the 5th is computed to satisfy the simplex),
    pH, and process temperature (Celsius). Noise is added to emulate experimental variability.

    The model encodes plausible but simplified pharmacotechnical trade-offs:
      - Certain excipients improve bioavailability but harm stability and vice versa.
      - Bioavailability peaks near physiological pH and moderate temperatures.
      - Stability peaks at slightly acidic pH and lower temperatures.
    """
    # Extract parameters
    f1 = float(parameterization["excipient_1_fraction"])
    f2 = float(parameterization["excipient_2_fraction"])
    f3 = float(parameterization["excipient_3_fraction"])
    f4 = float(parameterization["excipient_4_fraction"])
    # Reparameterize simplex: compute the 5th fraction to enforce sum to 1.0
    f5 = max(0.0, 1.0 - (f1 + f2 + f3 + f4))

    ph = float(parameterization["pH"])
    temp_c = float(parameterization["temperature_celsius"])

    # Excipient property profiles (dimensionless contributions)
    # e1: solubilizer; e2: binder; e3: disintegrant; e4: lubricant; e5: coating
    bio_coeffs = np.array([0.90, -0.10, 0.50, -0.20, -0.30])
    stab_coeffs = np.array([-0.20, 0.40, -0.10, 0.20, 0.70])
    fracs = np.array([f1, f2, f3, f4, f5])

    # Base contributions from composition
    base_bio = float(np.dot(fracs, bio_coeffs))
    base_stab = float(np.dot(fracs, stab_coeffs))

    # Simple interaction/synergy and penalties
    bio_synergy = 0.3 * (f1 * f3)            # solubilizer x disintegrant synergy
    bio_lube_penalty = 0.2 * f4              # lubricant can impede dissolution
    stab_solubilizer_penalty = 0.25 * f1     # solubilizers can reduce stability
    stab_disintegrant_penalty = 0.15 * f3    # faster disintegration may reduce stability margin

    # Environmental effects (pH and temperature)
    def gaussian(x, mu, sigma):
        return float(np.exp(-0.5 * ((x - mu) / sigma) ** 2))

    ph_effect_bio = gaussian(ph, mu=6.5, sigma=1.2)   # peak near physiological pH
    ph_effect_stab = gaussian(ph, mu=4.5, sigma=1.0)  # slightly acidic best for stability

    temp_effect_bio = gaussian(temp_c, mu=37.0, sigma=12.0)  # moderate temps best for bioavailability
    temp_effect_stab = gaussian(temp_c, mu=25.0, sigma=10.0) # cooler temps best for stability

    # Combine into raw scores in [0, 1] roughly, then scale to [0, 100]
    raw_bio = 0.5 + 0.8 * base_bio + bio_synergy - bio_lube_penalty
    raw_stab = 0.55 + 0.9 * base_stab - stab_solubilizer_penalty - stab_disintegrant_penalty

    bio_score = np.clip(raw_bio * ph_effect_bio * temp_effect_bio, 0.0, 1.0) * 100.0
    stab_score = np.clip(raw_stab * ph_effect_stab * temp_effect_stab, 0.0, 1.0) * 100.0

    # Add experimental noise
    noise_sd = 2.5
    bio_obs = float(bio_score + np.random.normal(0.0, noise_sd))
    stab_obs = float(stab_score + np.random.normal(0.0, noise_sd))

    # Return mean and SEM (SEM set to known noise_sd here; set to None if unknown)
    return {BIOAVAILABILITY: (bio_obs, noise_sd), STABILITY: (stab_obs, noise_sd)}


# Initialize Ax client
np.random.seed(123)
ax_client = AxClient()

# Create multi-objective experiment
# Note: We reparameterize the 5-component simplex by optimizing 4 fractions and computing the 5th.
ax_client.create_experiment(
    name="pharmaceutical_formulation_moo",
    parameters=[
        {"name": "excipient_1_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "excipient_2_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "excipient_3_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "excipient_4_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "pH", "type": "range", "bounds": [2.0, 8.0]},
        {"name": "temperature_celsius", "type": "range", "bounds": [15.0, 60.0]},
    ],
    objectives={
        BIOAVAILABILITY: ObjectiveProperties(minimize=False),
        STABILITY: ObjectiveProperties(minimize=False),
    },
    parameter_constraints=[
        # Enforce that excipient_5_fraction = 1 - (f1 + f2 + f3 + f4) is nonnegative
        "excipient_1_fraction + excipient_2_fraction + excipient_3_fraction + excipient_4_fraction <= 1.0",
    ],
)

# Run optimization loop
NUM_TRIALS = 60
for _ in range(NUM_TRIALS):
    params, trial_index = ax_client.get_next_trial()
    results = evaluate_formulation(params)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve observed data
df = ax_client.get_trials_data_frame()

# Prepare data for Pareto analysis (pivot to wide format)
wide = (
    df.pivot_table(
        index="trial_index", columns="metric_name", values="mean", aggfunc="mean"
    )
    .rename_axis(None, axis=1)
    .reset_index()
)
wide = wide.dropna(subset=[BIOAVAILABILITY, STABILITY])

# Compute observed Pareto frontier (maximization for both objectives)
vals = wide[[BIOAVAILABILITY, STABILITY]].to_numpy()


def pareto_mask_max(values):
    n = values.shape[0]
    mask = np.ones(n, dtype=bool)
    for i in range(n):
        if not mask[i]:
            continue
        # A point i is dominated if there exists j != i such that values[j] >= values[i] for all metrics
        # and strictly > for at least one metric.
        dominates = (values >= values[i]).all(axis=1) & (values > values[i]).any(axis=1)
        dominates[i] = False
        if dominates.any():
            mask[i] = False
    return mask


mask = pareto_mask_max(vals)
pareto_pts = wide.loc[mask, [BIOAVAILABILITY, STABILITY]].sort_values(BIOAVAILABILITY)

# Plot observed points and Pareto frontier
fig, ax = plt.subplots(figsize=(7, 5), dpi=140)
ax.scatter(
    wide[BIOAVAILABILITY],
    wide[STABILITY],
    fc="None",
    ec="k",
    label="Observed",
)

if len(pareto_pts) > 1:
    ax.plot(
        pareto_pts[BIOAVAILABILITY],
        pareto_pts[STABILITY],
        color="#0033FF",
        lw=2,
        label="Observed Pareto Front",
    )
else:
    ax.scatter(
        pareto_pts[BIOAVAILABILITY],
        pareto_pts[STABILITY],
        color="#0033FF",
        label="Pareto Point",
    )

ax.set_xlabel("Bioavailability (%)")
ax.set_ylabel("Stability (%)")
ax.set_title("Pareto Frontier: Bioavailability vs Stability")
ax.legend()
plt.tight_layout()
plt.show()