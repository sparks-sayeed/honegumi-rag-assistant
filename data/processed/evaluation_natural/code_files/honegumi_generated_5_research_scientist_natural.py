# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"
obj2_name = "branin_swapped"


def branin3_moo(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    # second objective has x1 and x2 swapped
    y2 = float(
        (x1 - 5.1 / (4 * np.pi**2) * x2**2 + 5.0 / np.pi * x2 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x2)
        + 10
    )

    # Contrived way to incorporate x3 into the second objective
    y2 = y2 * (1 - 0.1 * x1 * x2 * x3)

    return {obj1_name: y, obj2_name: y2}


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
        obj2_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
    ],
)


for i in range(21):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]
    x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

    results = branin3_moo(x1, x2, x3)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)
pareto_results = ax_client.get_pareto_optimal_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto[objectives[0]],
    pareto[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])

ax.legend()
plt.show()

# Investigating pharmaceutical formulation space using multi-objective Bayesian optimization (Ax)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from typing import Dict, Tuple

from ax.service.ax_client import AxClient
from ax.service.utils.instantiation import ObjectiveProperties


# Domain-specific names for metrics (maximize both).
BIOAVAILABILITY = "bioavailability"
STABILITY = "stability"

# Fixed total for compositional constraint: fractions must sum to 1.0.
COMPOSITION_TOTAL = 1.0

# Noise model: observations are noisy with specified SEM.
OBSERVATION_SEM = 2.5

rng = np.random.default_rng(1234)


def clamp(x: float, lo: float, hi: float) -> float:
    return float(max(lo, min(hi, x)))


def compute_formulation_objectives(
    surfactant_fraction: float,
    polymer_fraction: float,
    buffer_fraction: float,
    antioxidant_fraction: float,
    filler_fraction: float,
    pH: float,
    process_temperature_c: float,
) -> Tuple[float, float]:
    """
    Simulated domain logic for pharmaceutical formulation:
    - Five excipient fractions sum to 1.0: surfactant, polymer, buffer, antioxidant, filler.
    - Process conditions: pH and temperature (Celsius).
    - Objectives:
        bioavailability: proxy for in vitro dissolution / in vivo exposure
        stability: proxy for chemical/physical stability
    All values are scaled to 0-100 and clipped.
    """
    # Helpers
    def gauss(x, mu, sigma):
        return np.exp(-((x - mu) / sigma) ** 2)

    def sigmoid(x):
        return 1.0 / (1.0 + np.exp(-x))

    T = process_temperature_c

    # Bioavailability model (higher is better)
    ba = 50.0
    ba += 25.0 * (1.0 - np.exp(-5.0 * surfactant_fraction))  # surfactant improves BA
    ba -= 10.0 * (polymer_fraction ** 1.2)  # polymer can hinder BA via viscosity
    pH_opt_ba = 6.5
    ba += 15.0 * buffer_fraction * gauss(pH, pH_opt_ba, 1.2)  # buffer tunes pH near BA optimum
    ba += 2.0 * antioxidant_fraction  # minor positive effect
    ba -= 5.0 * filler_fraction  # inert filler dilutes actives
    ba += 15.0 * gauss(T, 37.0, 12.0)  # temp near body temp aids dissolution; too high/low worse

    # Stability model (higher is better)
    stab = 60.0
    temp_risk = sigmoid((T - 25.0) / 6.0)  # higher T increases degradation risk
    stab -= 35.0 * temp_risk
    pH_opt_stab = 5.5
    stab += 15.0 * gauss(pH, pH_opt_stab, 1.0)  # stability optimum at mildly acidic pH
    stab -= 8.0 * surfactant_fraction  # surfactant can destabilize
    stab += 20.0 * (1.0 - np.exp(-4.0 * polymer_fraction))  # polymer improves stability
    stab += 18.0 * (1.0 - np.exp(-3.0 * antioxidant_fraction))  # antioxidant protects
    stab += 5.0 * buffer_fraction * gauss(pH, pH_opt_stab, 1.0)
    stab -= 10.0 * surfactant_fraction * temp_risk  # high T + surfactant synergistic risk

    # Clip to [0, 100]
    ba = clamp(ba, 0.0, 100.0)
    stab = clamp(stab, 0.0, 100.0)

    return ba, stab


def evaluate_formulation(parameterization: Dict[str, float]) -> Dict[str, Tuple[float, float]]:
    """
    Evaluate a given formulation with noise.
    Returns dict of metric -> (observed value, SEM).
    """
    surf = float(parameterization["surfactant_fraction"])
    poly = float(parameterization["polymer_fraction"])
    buff = float(parameterization["buffer_fraction"])
    anti = float(parameterization["antioxidant_fraction"])
    pH = float(parameterization["pH"])
    temp_c = float(parameterization["process_temperature_c"])

    # Reconstruct filler to satisfy the simplex constraint.
    filler = COMPOSITION_TOTAL - (surf + poly + buff + anti)
    filler = clamp(filler, 0.0, 1.0)

    true_ba, true_stab = compute_formulation_objectives(
        surfactant_fraction=surf,
        polymer_fraction=poly,
        buffer_fraction=buff,
        antioxidant_fraction=anti,
        filler_fraction=filler,
        pH=pH,
        process_temperature_c=temp_c,
    )

    # Add observation noise to the reported mean; provide SEM to Ax.
    noisy_ba = float(true_ba + rng.normal(0.0, OBSERVATION_SEM))
    noisy_stab = float(true_stab + rng.normal(0.0, OBSERVATION_SEM))

    return {
        BIOAVAILABILITY: (noisy_ba, OBSERVATION_SEM),
        STABILITY: (noisy_stab, OBSERVATION_SEM),
    }


# Create Ax experiment
ax_client = AxClient()
ax_client.create_experiment(
    name="formulation_moo_experiment",
    parameters=[
        # 4 free excipient fractions; the 5th (filler) is computed to satisfy simplex.
        {"name": "surfactant_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "polymer_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "buffer_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "antioxidant_fraction", "type": "range", "bounds": [0.0, 1.0]},
        # Process parameters
        {"name": "pH", "type": "range", "bounds": [2.0, 9.0]},
        {"name": "process_temperature_c", "type": "range", "bounds": [4.0, 60.0]},
    ],
    objectives={
        BIOAVAILABILITY: ObjectiveProperties(minimize=False),
        STABILITY: ObjectiveProperties(minimize=False),
    },
    parameter_constraints=[
        "surfactant_fraction + polymer_fraction + buffer_fraction + antioxidant_fraction <= 1.0",
    ],
)

# Run optimization loop
NUM_TRIALS = 60
for i in range(NUM_TRIALS):
    parameterization, trial_index = ax_client.get_next_trial()
    results = evaluate_formulation(parameterization)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve Pareto-optimal arms based on observed data
pareto_params = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

# Build a dataframe of observed metrics
df = ax_client.get_trials_data_frame()

# Compute empirical Pareto frontier (non-dominated) in maximization sense
metrics = [BIOAVAILABILITY, STABILITY]
obs = df[metrics].to_numpy(dtype=float)

def nondominated_mask(points: np.ndarray) -> np.ndarray:
    n = points.shape[0]
    mask = np.ones(n, dtype=bool)
    for i in range(n):
        if not mask[i]:
            continue
        for j in range(n):
            if i == j:
                continue
            # j dominates i if j >= i for all metrics and > for at least one
            if np.all(points[j] >= points[i]) and np.any(points[j] > points[i]):
                mask[i] = False
                break
    return mask

nd_mask = nondominated_mask(obs)
pareto_df = df.loc[nd_mask, metrics].dropna().drop_duplicates()
pareto_df = pareto_df.sort_values(by=BIOAVAILABILITY)

# Plot observed points and empirical Pareto frontier
fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df[BIOAVAILABILITY], df[STABILITY], fc="None", ec="k", label="Observed")
if len(pareto_df) > 1:
    ax.plot(pareto_df[BIOAVAILABILITY], pareto_df[STABILITY], color="#0033FF", lw=2, label="Pareto Front")
elif len(pareto_df) == 1:
    ax.scatter(pareto_df[BIOAVAILABILITY], pareto_df[STABILITY], color="#0033FF", label="Pareto Point")

ax.set_xlabel("Bioavailability (a.u.)")
ax.set_ylabel("Stability (a.u.)")
ax.set_title("Observed outcomes and empirical Pareto front")
ax.legend()
plt.tight_layout()
plt.show()