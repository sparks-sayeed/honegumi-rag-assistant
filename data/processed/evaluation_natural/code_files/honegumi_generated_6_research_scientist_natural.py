# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


np.random.seed(42)

objective_name = "catalytic_activity"


def evaluate_calcination(calcination_temperature_c: float, calcination_duration_h: float) -> dict:
    """
    Evaluate catalytic activity as a function of calcination temperature and duration.

    This is a realistic stub mimicking common phenomena:
    - Activity exhibits a 'volcano' (Gaussian-like) response vs temperature (under/over calcination).
    - Duration has an optimal window (too short: incomplete decomposition; too long: sintering).
    - Some interaction between temperature and duration.
    - Measurement noise included; we also report an estimated SEM.

    Replace the computation below with actual experimental measurement or a trusted simulator.
    """
    T = calcination_temperature_c
    t = calcination_duration_h

    # Temperature effect: peak around ~600 C with width ~90 C
    temp_term = np.exp(-0.5 * ((T - 600.0) / 90.0) ** 2)

    # Duration effect: peak around ~3.5 h with width ~1.2 h
    time_term = np.exp(-0.5 * ((t - 3.5) / 1.2) ** 2)

    # Interaction: slightly shifts optimal T upward with longer duration
    interaction_center = 520.0 + 25.0 * t
    interaction_term = 0.15 * np.exp(-0.5 * ((T - interaction_center) / 120.0) ** 2)

    # Combine effects and scale to an activity range (0-100 arbitrary units)
    baseline = 5.0
    true_activity = baseline + 95.0 * (0.7 * temp_term * time_term + 0.3 * interaction_term)

    # Add heteroscedastic noise (more noise away from optimum is common)
    noise_sd = 2.0 + 0.02 * (100.0 - true_activity)  # between ~2 and ~4 units
    observed_activity = float(np.random.normal(loc=true_activity, scale=noise_sd))

    # Ensure non-negative reported activity
    observed_activity = max(0.0, observed_activity)

    # Report estimated standard error of the mean (SEM)
    # If a single measurement per run, SEM ~= SD; adjust if averaging replicates.
    sem_estimate = float(noise_sd)

    return {objective_name: (observed_activity, sem_estimate)}


ax_client = AxClient()

ax_client.create_experiment(
    name="calcination_optimization",
    parameters=[
        {
            "name": "calcination_temperature_c",
            "type": "range",
            "bounds": [350.0, 800.0],
        },
        {
            "name": "calcination_duration_h",
            "type": "range",
            "bounds": [0.5, 8.0],
        },
    ],
    objectives={
        objective_name: ObjectiveProperties(minimize=False),
    },
)

# Optimization budget: 25 trials
num_trials = 25
for _ in range(num_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    temperature_c = parameterization["calcination_temperature_c"]
    duration_h = parameterization["calcination_duration_h"]

    results = evaluate_calcination(temperature_c, duration_h)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, best_metrics = ax_client.get_best_parameters()
print("Best parameters found:")
print(best_parameters)
print("\nBest observed metrics:")
print(best_metrics)

# Visualization
df = ax_client.get_trials_data_frame().sort_values("trial_index").reset_index(drop=True)

metric_col = objective_name
metric_sem_col = f"{objective_name}_sem"  # ax-client uses underscore in the column name

trial_numbers = df["trial_index"].to_numpy()
y = df[metric_col].to_numpy()
sem = df[metric_sem_col].to_numpy() if metric_sem_col in df.columns else np.zeros_like(y)

best_so_far = np.maximum.accumulate(y)

fig, axes = plt.subplots(1, 2, figsize=(12, 4), dpi=150)

# Left: Activity vs Trial with best-so-far
ax = axes[0]
ax.errorbar(trial_numbers, y, yerr=sem, fmt="o", mfc="none", mec="k", ecolor="#888888", label="Observed")
ax.plot(trial_numbers, best_so_far, color="#0033FF", lw=2, label="Best to Trial")
ax.set_xlabel("Trial Number")
ax.set_ylabel("Catalytic Activity (a.u.)")
ax.set_title("Optimization Progress")
ax.legend()

# Right: Parameter scatter colored by activity
temps = [p["calcination_temperature_c"] for p in df["arm_parameters"]]
times = [p["calcination_duration_h"] for p in df["arm_parameters"]]
sc = axes[1].scatter(temps, times, c=y, cmap="viridis", ec="k")
axes[1].set_xlabel("Calcination Temperature (Â°C)")
axes[1].set_ylabel("Calcination Duration (h)")
axes[1].set_title("Explored Conditions")
cbar = fig.colorbar(sc, ax=axes[1])
cbar.set_label("Catalytic Activity (a.u.)")

plt.tight_layout()
plt.show()