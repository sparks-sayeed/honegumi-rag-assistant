# Generated by adapting a Honegumi skeleton for steel alloy composition optimization
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt
from typing import Dict


# Problem-specific objective names
STRENGTH_OBJ = "strength"
CORROSION_OBJ = "corrosion_resistance"

# Total for compositional constraint: Cr + Ni + Mo + Fe == 1.0
TOTAL_FRACTION = 1.0


def evaluate_steel_alloy(cr: float, ni: float, mo: float, fe: float) -> Dict[str, float]:
    """
    Evaluate steel alloy performance metrics: tensile strength (MPa) and corrosion resistance (index).
    This function implements a realistic, domain-inspired surrogate model for demo purposes.

    Notes:
    - All inputs are mass fractions and must sum to 1.0 (fe = balance).
    - The model captures typical qualitative effects:
        * Cr and Mo significantly improve corrosion resistance (Mo more for pitting resistance).
        * Mo and Cr provide solid-solution/precipitation strengthening; Ni modestly strengthens but can
          reduce strength if too high (austenite stabilization).
        * Very high alloying contents can introduce brittleness/carbides, reducing net strength.

    TODO: Replace this surrogate with actual lab measurements or a physics-based simulation.
    """
    # Numerical safety
    cr = float(cr)
    ni = float(ni)
    mo = float(mo)
    fe = float(fe)

    # Strength model (MPa)
    base_strength = 250.0  # base ferritic steel
    # Solid solution strengthening contributions (per fraction)
    ss_cr = 650.0 * cr
    ss_ni = 300.0 * ni
    ss_mo = 1200.0 * mo
    # Synergies (precipitation/carbide effects)
    synergy_cr_mo = 700.0 * cr * mo
    synergy_ni_mo = 200.0 * ni * mo
    # Penalties for over-alloying regimes (brittleness, intermetallics, sigma phase, etc.)
    total_alloying = cr + ni + mo
    penalty_overalloy = 0.0
    if total_alloying > 0.35:
        penalty_overalloy -= 500.0 * (total_alloying - 0.35)  # increasing penalty
    penalty_hi_ni = -350.0 * max(0.0, ni - 0.32)  # too much Ni softens
    penalty_hi_cr = -250.0 * max(0.0, cr - 0.30)  # sigma-phase risk at high Cr
    penalty_hi_mo = -300.0 * max(0.0, mo - 0.12)  # embrittlement risk at high Mo

    strength_mean = (
        base_strength
        + ss_cr
        + ss_ni
        + ss_mo
        + synergy_cr_mo
        + synergy_ni_mo
        + penalty_overalloy
        + penalty_hi_ni
        + penalty_hi_cr
        + penalty_hi_mo
    )

    # Add measurement noise to reflect experimental uncertainty (MPa)
    strength_noise = np.random.normal(loc=0.0, scale=10.0)
    strength = max(0.0, strength_mean + strength_noise)

    # Corrosion resistance model (dimensionless index ~[0, 1.2])
    # Inspired by PREN-like concepts; scaled for fractions rather than wt%
    # Higher Cr and Mo strongly help; Ni helps passivation modestly.
    pren_like = 22.0 * cr + 60.0 * mo + 6.0 * ni
    synergy_cr_mo_corr = 3.0 * cr * mo
    # Penalties for very low Cr or Mo (poor passivation)
    penalty_low_cr = -2.0 * max(0.0, 0.14 - cr)  # severe penalty when Cr < ~14%
    penalty_low_mo = -1.0 * max(0.0, 0.02 - mo)  # penalty when Mo < ~2%
    # Aggregate and squash into [0, ~1.2] via smooth saturation
    raw_corr = pren_like + synergy_cr_mo_corr + penalty_low_cr + penalty_low_mo
    corr_index_mean = 1.2 / (1.0 + np.exp(-(raw_corr - 4.5)))  # shift-sigmoid
    corr_noise = np.random.normal(loc=0.0, scale=0.02)
    corrosion_resistance = max(0.0, corr_index_mean + corr_noise)

    return {STRENGTH_OBJ: strength, CORROSION_OBJ: corrosion_resistance}


def compute_fe_balance(cr: float, ni: float, mo: float, total: float = TOTAL_FRACTION) -> float:
    """Compute Fe as balance to satisfy composition sum to total."""
    fe = total - (cr + ni + mo)
    # Numerical clamp to avoid tiny negatives due to floating point
    if fe < 0 and abs(fe) < 1e-9:
        fe = 0.0
    return fe


def compute_pareto_front(df: pd.DataFrame, obj_x: str, obj_y: str) -> pd.DataFrame:
    """
    Compute Pareto front for two objectives to maximize.
    Returns a DataFrame of Pareto-optimal rows.
    """
    # Keep only rows with finite metrics
    df = df[[obj_x, obj_y]].dropna().copy()

    # Convert to numpy for speed
    points = df[[obj_x, obj_y]].values
    n = points.shape[0]
    is_dominated = np.zeros(n, dtype=bool)

    for i in range(n):
        if is_dominated[i]:
            continue
        for j in range(n):
            if i == j:
                continue
            # j dominates i if j is >= in both and > in at least one (maximize)
            if (points[j, 0] >= points[i, 0]) and (points[j, 1] >= points[i, 1]) and (
                (points[j, 0] > points[i, 0]) or (points[j, 1] > points[i, 1])
            ):
                is_dominated[i] = True
                break

    pareto_df = df.loc[~is_dominated].copy()
    pareto_df.sort_values(by=obj_x, inplace=True)
    return pareto_df


# Initialize Ax client
ax_client = AxClient()


# Create multi-objective experiment with composition constraint
ax_client.create_experiment(
    name="steel_alloy_optimization",
    parameters=[
        # Fe is balance; we explicitly optimize Cr, Ni, Mo and enforce Cr + Ni + Mo <= 1
        {"name": "Cr", "type": "range", "bounds": [0.0, TOTAL_FRACTION]},
        {"name": "Ni", "type": "range", "bounds": [0.0, TOTAL_FRACTION]},
        {"name": "Mo", "type": "range", "bounds": [0.0, TOTAL_FRACTION]},
    ],
    objectives={
        STRENGTH_OBJ: ObjectiveProperties(minimize=False),  # maximize
        CORROSION_OBJ: ObjectiveProperties(minimize=False),  # maximize
    },
    parameter_constraints=[
        f"Cr + Ni + Mo <= {TOTAL_FRACTION}",  # compositional constraint (Fe is balance)
    ],
)


# Optimization loop with budget of 40 trials
N_TRIALS = 40
for i in range(N_TRIALS):
    parameterization, trial_index = ax_client.get_next_trial()

    cr = float(parameterization["Cr"])
    ni = float(parameterization["Ni"])
    mo = float(parameterization["Mo"])
    fe = compute_fe_balance(cr, ni, mo, TOTAL_FRACTION)

    # Evaluate objectives for this composition
    results = evaluate_steel_alloy(cr=cr, ni=ni, mo=mo, fe=fe)

    # Report results back to Ax
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)


# Retrieve results and visualize Pareto front
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

# Compute Pareto front from observed data
pareto_df = compute_pareto_front(df, obj_x=objectives[0], obj_y=objectives[1])

# Plot observed points and Pareto front
fig, ax = plt.subplots(figsize=(7, 5), dpi=150)
ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto_df[objectives[0]],
    pareto_df[objectives[1]],
    color="#0033FF",
    lw=2,
    marker="o",
    label="Pareto Front",
)
ax.set_xlabel(f"{objectives[0]} (MPa)" if objectives[0] == STRENGTH_OBJ else objectives[0])
ax.set_ylabel(objectives[1])
ax.set_title("Steel Alloy Optimization: Strength vs. Corrosion Resistance")
ax.legend()
plt.tight_layout()
plt.show()