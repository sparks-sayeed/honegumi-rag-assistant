# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"
obj2_name = "branin_swapped"


def branin3_moo(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    # second objective has x1 and x2 swapped
    y2 = float(
        (x1 - 5.1 / (4 * np.pi**2) * x2**2 + 5.0 / np.pi * x2 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x2)
        + 10
    )

    # Contrived way to incorporate x3 into the second objective
    y2 = y2 * (1 - 0.1 * x1 * x2 * x3)

    return {obj1_name: y, obj2_name: y2}


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
        obj2_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
    ],
)


for i in range(21):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]
    x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

    results = branin3_moo(x1, x2, x3)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)
pareto_results = ax_client.get_pareto_optimal_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto[objectives[0]],
    pareto[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])

ax.legend()
plt.show()

# Steel alloy composition optimization with Ax (Multi-objective: maximize strength and corrosion resistance)
# %pip install ax-platform==0.4.3 matplotlib pandas numpy
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from typing import Dict, Tuple

from ax.service.ax_client import AxClient, ObjectiveProperties


# -----------------------------
# Problem-specific configuration
# -----------------------------
EXPERIMENT_NAME = "steel_alloy_strength_corrosion_optimization"
BUDGET_TRIALS = 40
TOTAL_FRACTION = 1.0  # Composition fractions must sum to 1.0

# Objective (metric) names
STRENGTH_METRIC = "strength"  # approximate ultimate tensile strength in MPa
CORROSION_METRIC = "corrosion_resistance"  # dimensionless index (higher is better)

# Random seed for reproducibility of synthetic measurement noise
RNG = np.random.default_rng(42)


def evaluate_alloy_performance(cr_fraction: float, ni_fraction: float, mo_fraction: float) -> Dict[str, Tuple[float, float]]:
    """
    Domain-inspired surrogate to evaluate mechanical strength and corrosion resistance
    for a Fe-Cr-Ni-Mo alloy, given the alloying fractions of Cr, Ni, and Mo.
    Fe fraction is the remainder to satisfy composition closure.

    NOTE: Replace this surrogate with actual laboratory measurements or a high-fidelity
    simulation. Ensure returned values keep the same dictionary and key names.

    Returns:
        {
            "strength": (value_in_MPa, sem_in_MPa),
            "corrosion_resistance": (dimensionless_index, sem)
        }
    """
    # Compute Fe as remainder to satisfy composition constraint
    fe_fraction = TOTAL_FRACTION - (cr_fraction + ni_fraction + mo_fraction)

    # Guard against tiny numerical negatives due to floating point
    fe_fraction = max(0.0, fe_fraction)

    # ---------------------------
    # Synthetic strength surrogate
    # ---------------------------
    # Baseline ferritic steel strength ~350â€“450 MPa; alloying increases strength via solid solution and synergy.
    baseline_strength = 380.0

    # Solid solution strengthening contributions (heuristic weights)
    ss_contrib = 1200.0 * (0.50 * cr_fraction + 0.25 * ni_fraction + 0.80 * mo_fraction)

    # Synergy of Cr-Mo for carbide and intermetallic formation (beneficial at moderate levels)
    synergy_contrib = 600.0 * (cr_fraction * mo_fraction)

    # Penalize over-alloying away from austenitic stainless "sweet spot" (e.g., ~18Cr-8Ni-2-3Mo)
    # Fractions are given in 0..1, so centers are 0.18, 0.08, 0.03.
    balance_penalty = -2500.0 * ((cr_fraction - 0.18) ** 2) \
                      -1200.0 * ((ni_fraction - 0.08) ** 2) \
                      -3000.0 * ((mo_fraction - 0.03) ** 2)

    # Slight benefit from Fe balance (ductility contribution)
    fe_benefit = 60.0 * fe_fraction

    strength_mpa = baseline_strength + ss_contrib + synergy_contrib + balance_penalty + fe_benefit

    # -------------------------------
    # Synthetic corrosion resistance surrogate
    # -------------------------------
    # Passivation predominantly controlled by Cr; Mo increases pitting resistance; Ni generally helps in chlorides.
    # Use a logistic function to capture passivation onset near ~12 wt% Cr (0.12 fraction).
    passivation = 1.0 / (1.0 + np.exp(-80.0 * (cr_fraction - 0.12)))

    # Pitting/corrosion resistance-like index (heuristic): weights inspired by PREN trends (Cr and Mo dominant)
    base_corrosion_index = (30.0 * cr_fraction + 90.0 * mo_fraction + 10.0 * ni_fraction)

    # Apply passivation factor; ensure diminishing returns at extreme alloying
    corrosion_index = 100.0 * passivation * np.tanh(base_corrosion_index / 2.5)

    # ---------------------------------
    # Measurement noise (SEM estimates)
    # ---------------------------------
    strength_sem = 12.0  # MPa; standard error of mean for strength measurement
    corrosion_sem = 1.0  # dimensionless index SEM

    # Add synthetic measurement noise to the reported mean values
    strength_obs = strength_mpa + RNG.normal(0.0, strength_sem)
    corrosion_obs = corrosion_index + RNG.normal(0.0, corrosion_sem)

    # Ensure non-negative observations
    strength_obs = float(max(0.0, strength_obs))
    corrosion_obs = float(max(0.0, corrosion_obs))

    return {
        STRENGTH_METRIC: (strength_obs, strength_sem),
        CORROSION_METRIC: (corrosion_obs, corrosion_sem),
    }


# -----------------------------
# Initialize Ax experiment
# -----------------------------
ax_client = AxClient()
ax_client.create_experiment(
    name=EXPERIMENT_NAME,
    parameters=[
        # Reparameterized composition: Optimize Cr, Ni, Mo; Fe is computed as 1 - (Cr + Ni + Mo)
        {"name": "Cr_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "Ni_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "Mo_fraction", "type": "range", "bounds": [0.0, 1.0]},
    ],
    # Multi-objective: maximize both strength and corrosion resistance
    objectives={
        STRENGTH_METRIC: ObjectiveProperties(minimize=False),
        CORROSION_METRIC: ObjectiveProperties(minimize=False),
    },
    # Composition closure via linear inequality on free variables: Cr + Ni + Mo <= 1.0; Fe is remainder
    parameter_constraints=[
        "Cr_fraction + Ni_fraction + Mo_fraction <= 1.0",
    ],
)


# -----------------------------
# Optimization loop
# -----------------------------
for i in range(BUDGET_TRIALS):
    parameters, trial_index = ax_client.get_next_trial()

    cr = float(parameters["Cr_fraction"])
    ni = float(parameters["Ni_fraction"])
    mo = float(parameters["Mo_fraction"])

    # Evaluate synthetic metrics (replace with lab or simulation measurements as needed)
    results = evaluate_alloy_performance(cr_fraction=cr, ni_fraction=ni, mo_fraction=mo)

    ax_client.complete_trial(trial_index=trial_index, raw_data=results)


# -----------------------------
# Retrieve results and visualize
# -----------------------------
# Prepare wide-form DataFrame of observed means
df_long = ax_client.get_trials_data_frame()
if df_long.empty:
    print("No data collected.")
else:
    df_wide = (
        df_long.pivot_table(
            index=["trial_index", "arm_name"],
            columns="metric_name",
            values="mean",
            aggfunc="mean",
        )
        .reset_index()
        .rename_axis(None, axis=1)
    )

    # Drop any incomplete rows
    df_wide = df_wide.dropna(subset=[STRENGTH_METRIC, CORROSION_METRIC])

    # Compute Pareto-efficient set (maximization for both)
    def pareto_mask(points: np.ndarray) -> np.ndarray:
        # points: N x 2 array for [strength, corrosion]
        n = points.shape[0]
        is_efficient = np.ones(n, dtype=bool)
        for i in range(n):
            if is_efficient[i]:
                # Any point that is strictly dominated by point i is not efficient
                dominates = np.all(points[i] >= points, axis=1) & np.any(points[i] > points, axis=1)
                dominates[i] = False
                is_efficient[dominates] = False
        return is_efficient

    points = df_wide[[STRENGTH_METRIC, CORROSION_METRIC]].to_numpy()
    mask = pareto_mask(points)

    pareto_df = df_wide[mask].copy()
    pareto_df = pareto_df.sort_values(by=STRENGTH_METRIC)

    # Scatter plot of observed points and Pareto frontier
    plt.figure(figsize=(7, 5), dpi=140)
    plt.scatter(
        df_wide[STRENGTH_METRIC],
        df_wide[CORROSION_METRIC],
        facecolors="none",
        edgecolors="k",
        label="Observed",
    )
    if len(pareto_df) > 1:
        plt.plot(
            pareto_df[STRENGTH_METRIC],
            pareto_df[CORROSION_METRIC],
            color="#0066FF",
            lw=2,
            label="Pareto Front (observed)",
        )
    else:
        plt.scatter(
            pareto_df[STRENGTH_METRIC],
            pareto_df[CORROSION_METRIC],
            color="#0066FF",
            label="Pareto Point",
        )
    plt.xlabel(f"{STRENGTH_METRIC} (MPa)")
    plt.ylabel(f"{CORROSION_METRIC} (index)")
    plt.title("Steel Alloy Optimization: Strength vs. Corrosion Resistance")
    plt.legend()
    plt.tight_layout()
    plt.show()

    # Print top Pareto alloys with compositions (including Fe fraction)
    print("\nTop Pareto-optimal alloys (observed):")
    # Recover compositions for Pareto arms from the experiment
    exp = ax_client.experiment
    # Build a map arm_name -> params
    arm_params = {t.arm.name: t.arm.parameters for t in exp.trials.values() if t.arm is not None}
    # Merge params into pareto_df
    comp_cols = ["Cr_fraction", "Ni_fraction", "Mo_fraction", "Fe_fraction"]
    rows = []
    for _, row in pareto_df.iterrows():
        arm_name = row["arm_name"]
        p = arm_params.get(arm_name, {})
        cr = float(p.get("Cr_fraction", np.nan))
        ni = float(p.get("Ni_fraction", np.nan))
        mo = float(p.get("Mo_fraction", np.nan))
        fe = float(max(0.0, TOTAL_FRACTION - (cr + ni + mo)))
        rows.append(
            {
                "arm_name": arm_name,
                STRENGTH_METRIC: row[STRENGTH_METRIC],
                CORROSION_METRIC: row[CORROSION_METRIC],
                "Cr_fraction": cr,
                "Ni_fraction": ni,
                "Mo_fraction": mo,
                "Fe_fraction": fe,
            }
        )
    pareto_with_comp = pd.DataFrame(rows)
    print(pareto_with_comp.sort_values(by=STRENGTH_METRIC, ascending=False).head(10).to_string(index=False))