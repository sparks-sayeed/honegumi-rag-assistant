# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"
obj2_name = "branin_swapped"


def branin3_moo(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    # second objective has x1 and x2 swapped
    y2 = float(
        (x1 - 5.1 / (4 * np.pi**2) * x2**2 + 5.0 / np.pi * x2 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x2)
        + 10
    )

    # Contrived way to incorporate x3 into the second objective
    y2 = y2 * (1 - 0.1 * x1 * x2 * x3)

    return {obj1_name: y, obj2_name: y2}


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
        obj2_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
    ],
)


for i in range(21):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]
    x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

    results = branin3_moo(x1, x2, x3)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)
pareto_results = ax_client.get_pareto_optimal_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto[objectives[0]],
    pareto[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])

ax.legend()
plt.show()

# Generated by adapting Honegumi skeleton to a conductive ink MOO study
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from ax.service.ax_client import AxClient, ObjectiveProperties


# Domain-specific metric names
ELECTRICAL_METRIC = "electrical_conductivity"  # S/m, maximize
VISCOSITY_METRIC = "viscosity"  # Pa·s, minimize

# Total fraction for compositional constraint
TOTAL_FRACTION = 1.0

# Random seed for reproducibility of the noisy evaluation
rng = np.random.default_rng(42)


def evaluate_conductive_ink(
    silver_fraction: float,
    carbon_black_fraction: float,
    binder_fraction: float,
    solvent_fraction: float,
    noise: bool = True,
) -> dict:
    """
    Evaluate a 4-component conductive ink formulation on electrical conductivity and viscosity.

    Components (fractions sum to 1.0):
    - silver_fraction: primary conductive filler
    - carbon_black_fraction: conductive additive for percolation and rheology tuning
    - binder_fraction: polymer binder (insulating, increases viscosity)
    - solvent_fraction: solvent (reduces viscosity, evaporates in processing)

    Returns a dict mapping metric names to (mean, SEM) tuples.
    """

    # Safety: numerical clipping to avoid tiny negative values from floating error
    silver = max(0.0, silver_fraction)
    cb = max(0.0, carbon_black_fraction)
    binder = max(0.0, binder_fraction)
    solvent = max(0.0, solvent_fraction)
    total = silver + cb + binder + solvent
    if abs(total - TOTAL_FRACTION) > 1e-6:
        # Normalize very small drift due to numerical error
        silver /= total
        cb /= total
        binder /= total
        solvent = max(0.0, 1.0 - silver - cb - binder)

    # Conductivity model (percolation-based; heuristic but physically motivated)
    # Effective conductive phase: silver + alpha * carbon black
    alpha_cb = 0.35  # carbon black effectiveness factor for conductivity
    phi_cond = silver + alpha_cb * cb
    phi_c = 0.12  # percolation threshold
    t_exp = 2.0  # critical exponent
    sigma_max = 1.0e6  # S/m, target upper scale for printed silver inks

    if phi_cond <= phi_c:
        sigma = 1.0e-4  # S/m, effectively insulating below threshold
    else:
        rel = (phi_cond - phi_c) / (1.0 - phi_c)
        sigma = sigma_max * (rel**t_exp)

    # Viscosity model (Krieger-Dougherty-like + base solvent/binder mixing)
    # Base mixture viscosity (Pa·s)
    eta_solvent = 0.002  # Pa·s
    eta_binder = 1.0  # Pa·s
    eta_solid_liquid = 0.01  # small base contribution for solids wetting

    eta_base = (
        solvent * eta_solvent
        + binder * eta_binder
        + (silver + cb) * eta_solid_liquid
    )

    phi_solid = silver + cb
    phi_m = 0.60  # max packing for flake/filler mixture
    intrinsic = 2.5 * phi_m
    if phi_solid >= phi_m:
        rel_visc = 1e3  # extremely high if exceeding packing (unlikely given constraint)
    else:
        rel_visc = (1.0 - phi_solid / phi_m) ** (-intrinsic)

    viscosity = eta_base * rel_visc

    # Additive noise to simulate experimental uncertainty
    if noise:
        # Conductivity noise: multiplicative relative + small additive floor
        sigma_rel_sd = 0.10
        sigma_add_sd = 50.0
        sigma_noise = rng.normal(0.0, sigma_rel_sd * max(sigma, 1.0)) + rng.normal(0.0, sigma_add_sd)
        measured_sigma = max(0.0, sigma + sigma_noise)
        sigma_sem = max(1.0, 0.5 * sigma_rel_sd * max(sigma, 1.0))
        # Viscosity noise: log-normal-like spread, model as additive on log-scale
        visc_rel_sd = 0.10
        log_visc = np.log(max(viscosity, 1e-6))
        log_visc_meas = log_visc + rng.normal(0.0, visc_rel_sd)
        measured_visc = np.exp(log_visc_meas)
        visc_sem = max(1e-4, 0.2 * visc_rel_sd * measured_visc)
    else:
        measured_sigma = sigma
        measured_visc = viscosity
        sigma_sem = 0.0
        visc_sem = 0.0

    return {
        ELECTRICAL_METRIC: (float(measured_sigma), float(sigma_sem)),
        VISCOSITY_METRIC: (float(measured_visc), float(visc_sem)),
    }


# Create Ax optimization client
ax_client = AxClient()

# We reparameterize the compositional equality by optimizing 3 variables and deriving the 4th:
# silver_fraction + carbon_black_fraction + binder_fraction + solvent_fraction == 1.0
# Enforce via: silver + carbon_black + binder <= 1.0, then solvent = 1.0 - (silver + carbon_black + binder)
ax_client.create_experiment(
    name="conductive_ink_formulation_moo",
    parameters=[
        {"name": "silver_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "carbon_black_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "binder_fraction", "type": "range", "bounds": [0.0, 1.0]},
    ],
    objectives={
        ELECTRICAL_METRIC: ObjectiveProperties(minimize=False),  # maximize conductivity
        VISCOSITY_METRIC: ObjectiveProperties(minimize=True),  # minimize viscosity
    },
    parameter_constraints=[
        "silver_fraction + carbon_black_fraction + binder_fraction <= 1.0",
    ],
    overwrite_existing_experiment=True,
    is_test=True,
)

# Run optimization
N_TRIALS = 40
for i in range(N_TRIALS):
    params, trial_index = ax_client.get_next_trial()

    silver = params["silver_fraction"]
    cb = params["carbon_black_fraction"]
    binder = params["binder_fraction"]
    solvent = max(0.0, TOTAL_FRACTION - (silver + cb + binder))  # composition closure

    results = evaluate_conductive_ink(
        silver_fraction=silver,
        carbon_black_fraction=cb,
        binder_fraction=binder,
        solvent_fraction=solvent,
        noise=True,
    )
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve Pareto-optimal points based on observed data
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

# Plot observed points and Pareto front
objectives = [ELECTRICAL_METRIC, VISCOSITY_METRIC]
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)

# Scatter observed means
if ELECTRICAL_METRIC in df.columns and VISCOSITY_METRIC in df.columns:
    ax.scatter(
        df[ELECTRICAL_METRIC],
        df[VISCOSITY_METRIC],
        fc="None",
        ec="k",
        label="Observed",
    )

# Extract Pareto points (means)
pareto_points = []
for (_params, (means, _cov)) in pareto.items():
    # means is a dict mapping metric name to mean
    try:
        pareto_points.append(
            {ELECTRICAL_METRIC: float(means[ELECTRICAL_METRIC]), VISCOSITY_METRIC: float(means[VISCOSITY_METRIC])}
        )
    except Exception:
        # Fallback if structure differs
        pass

if len(pareto_points) > 0:
    pareto_df = pd.DataFrame(pareto_points).sort_values(ELECTRICAL_METRIC)
    ax.plot(
        pareto_df[ELECTRICAL_METRIC],
        pareto_df[VISCOSITY_METRIC],
        color="#0033FF",
        lw=2,
        label="Pareto Front",
    )

ax.set_xlabel(f"{ELECTRICAL_METRIC} (S/m)")
ax.set_ylabel(f"{VISCOSITY_METRIC} (Pa·s)")
ax.set_title("Conductive Ink: Conductivity vs. Viscosity")
ax.legend()
plt.tight_layout()
plt.show()