# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin(x1, x2, c1):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # add a made-up penalty based on category
    penalty_lookup = {"A": 1.0, "B": 0.0, "C": 2.0}
    y += penalty_lookup[c1]

    return y


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
        {
            "name": "c1",
            "type": "choice",
            "is_ordered": False,
            "values": ["A", "B", "C"],
        },
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
)


for i in range(21):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    c1 = parameterization["c1"]

    results = branin(x1, x2, c1)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Generated from Honegumi skeleton and adapted for MAX phase conductivity optimization
# %pip install ax-platform==0.4.3 matplotlib
import os
import random
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from typing import Dict, Tuple, List
from ax.service.ax_client import AxClient, ObjectiveProperties


# Domain-specific configuration
objective_name = "electrical_conductivity_S_per_m"  # maximize
trial_budget = 30
rng_seed = 42


# Minimal element property tables for feature generation
ATOMIC_NUMBER = {
    "Ti": 22,
    "V": 23,
    "Cr": 24,
    "Nb": 41,
    "Ta": 73,
    "Mo": 42,
    "Al": 13,
    "Si": 14,
    "Ge": 32,
    "Sn": 50,
    "C": 6,
    "N": 7,
}
PAULING_EN = {
    "Ti": 1.54,
    "V": 1.63,
    "Cr": 1.66,
    "Nb": 1.6,
    "Ta": 1.5,
    "Mo": 2.16,
    "Al": 1.61,
    "Si": 1.90,
    "Ge": 2.01,
    "Sn": 1.96,
    "C": 2.55,
    "N": 3.04,
}
# Rough "base" conductivity scale for early transition metals in MAX phases (synthetic)
BASE_M_CONDUCTIVITY = {
    "Ti": 1.6e6,
    "V": 1.8e6,
    "Cr": 1.3e6,
    "Nb": 2.5e6,
    "Ta": 2.2e6,
    "Mo": 2.4e6,
}


def format_max_formula(m: str, a: str, x: str, n: int) -> str:
    """Return canonical MAX phase composition string M{n+1}AX{n}."""
    def fmt(elem: str, count: int) -> str:
        return f"{elem}{count}" if count > 1 else elem

    return f"{fmt(m, n+1)}{a}{fmt(x, n)}"


def compute_true_conductivity_s_per_m(m: str, a: str, x: str, n: int) -> float:
    """
    Synthetic 'ground truth' conductivity model (S/m) based on simple physicochemical heuristics.
    This is used to simulate measurements in this example. Replace with actual measurements in production.
    """
    # Base from transition metal choice
    base = BASE_M_CONDUCTIVITY[m]

    # Layering effect with n: thicker metal layers (larger n) tend to improve in-plane conduction
    layer_term = 0.45e6 * (n - 2)  # centered at n=2

    # X species: carbides are usually more conductive than nitrides in MAX phases
    x_term = 0.35e6 if x == "C" else -0.15e6

    # Electronegativity mismatch between M and A/X may modulate band structure and scattering
    en_m_a = PAULING_EN[m] - PAULING_EN[a]
    en_m_x = PAULING_EN[m] - PAULING_EN[x]
    en_term = 0.25e6 * en_m_a + 0.20e6 * en_m_x

    # Heavier A elements (higher Z) add scattering; penalize very heavy A
    a_mass_penalty = -0.25e6 * (ATOMIC_NUMBER[a] / 50.0)

    # Mild interaction term to introduce diversity
    interaction = 0.1e6 * np.sin(0.4 * ATOMIC_NUMBER[m] + 0.6 * n)

    sigma = base + layer_term + x_term + en_term + a_mass_penalty + interaction

    # Keep within a reasonable range for MAX phases (about 0.8e6 to 6e6 for this toy model)
    return float(np.clip(sigma, 0.5e6, 8.0e6))


def generate_max_phase_candidates(random_state: int = 0) -> pd.DataFrame:
    """
    Generate a candidate pool of MAX-phase compositions with simple descriptors
    and synthetic 'true' conductivities. If a CSV named 'max_phase_candidates.csv'
    exists in the working directory, it will be loaded instead.
    """
    csv_path = "max_phase_candidates.csv"
    if os.path.isfile(csv_path):
        df = pd.read_csv(csv_path)
        required_cols = {"composition", "M", "A", "X", "n", objective_name}
        if not required_cols.issubset(df.columns):
            raise ValueError(
                f"{csv_path} must contain columns: {required_cols}. Found: {set(df.columns)}"
            )
        return df.copy()

    rng = np.random.RandomState(random_state)
    random.seed(random_state)

    M_elements = ["Ti", "V", "Cr", "Nb", "Ta", "Mo"]
    A_elements = ["Al", "Si", "Ge", "Sn"]
    X_elements = ["C", "N"]
    n_values = [1, 2, 3]

    rows: List[Dict] = []
    for m in M_elements:
        for a in A_elements:
            for x in X_elements:
                for n in n_values:
                    comp = format_max_formula(m, a, x, n)
                    # Compute synthetic ground truth conductivity
                    sigma_true = compute_true_conductivity_s_per_m(m, a, x, n)

                    # Simple descriptors
                    total_atoms = (n + 1) + 1 + n
                    z_avg = (
                        (n + 1) * ATOMIC_NUMBER[m]
                        + ATOMIC_NUMBER[a]
                        + n * ATOMIC_NUMBER[x]
                    ) / total_atoms
                    en_avg = (
                        (n + 1) * PAULING_EN[m]
                        + PAULING_EN[a]
                        + n * PAULING_EN[x]
                    ) / total_atoms

                    rows.append(
                        {
                            "composition": comp,
                            "M": m,
                            "A": a,
                            "X": x,
                            "n": n,
                            "avg_atomic_number": z_avg,
                            "avg_electronegativity": en_avg,
                            objective_name: sigma_true,
                        }
                    )

    df = pd.DataFrame(rows)
    # Optional: persist to CSV for transparency; comment out if not needed
    # df.to_csv(csv_path, index=False)
    return df


class MaxPhaseSynthesisSimulator:
    """
    Simulates synthesis + measurement of electrical conductivity for MAX-phase compositions.
    In production, replace 'measure' to call lab instrumentation and return measured values.
    """

    def __init__(self, candidate_df: pd.DataFrame, meas_noise_fraction: float = 0.05, seed: int = 0):
        self.df = candidate_df.set_index("composition")
        self.meas_noise_fraction = meas_noise_fraction
        self.rng = np.random.RandomState(seed)

    def measure(self, composition: str) -> Tuple[float, float]:
        """
        Return a noisy measurement and an estimated standard error (SEM).
        """
        if composition not in self.df.index:
            raise KeyError(f"Unknown composition requested: {composition}")
        true_val = float(self.df.loc[composition, objective_name])

        # Add multiplicative Gaussian noise; clamp to non-negative
        noise_sd = self.meas_noise_fraction * true_val
        noisy_val = max(0.0, self.rng.normal(loc=true_val, scale=noise_sd))

        # Report a SEM consistent with noise level (user can plug actual SEM from instrument)
        sem = max(1e4, 0.5 * noise_sd)
        return noisy_val, sem


def evaluate_max_phase(composition: str, simulator: MaxPhaseSynthesisSimulator) -> Dict[str, Tuple[float, float]]:
    """
    Evaluate a proposed MAX phase by synthesizing and measuring its electrical conductivity.

    In production:
    - Trigger synthesis pipeline for `composition`
    - Measure electrical conductivity (S/m)
    - Replace the simulated measurement with actual values
    """
    measured, sem = simulator.measure(composition)
    return {objective_name: (measured, sem)}


def main():
    np.random.seed(rng_seed)
    random.seed(rng_seed)

    # Build candidate pool (or load from CSV if provided by user)
    candidates_df = generate_max_phase_candidates(random_state=rng_seed)
    compositions = candidates_df["composition"].tolist()

    # Initialize simulator (replace with real lab integration to use actual measurements)
    simulator = MaxPhaseSynthesisSimulator(candidates_df, meas_noise_fraction=0.07, seed=rng_seed)

    # Create Ax experiment for categorical search over compositions
    ax_client = AxClient()

    ax_client.create_experiment(
        parameters=[
            {
                "name": "composition",
                "type": "choice",
                "is_ordered": False,
                "values": compositions,
            }
        ],
        objectives={
            objective_name: ObjectiveProperties(minimize=False)
        },
    )

    # Run Bayesian optimization for the configured budget
    for _ in range(trial_budget):
        params, trial_index = ax_client.get_next_trial()
        comp = params["composition"]
        try:
            result = evaluate_max_phase(comp, simulator)
            ax_client.complete_trial(trial_index=trial_index, raw_data=result)
        except Exception as e:
            # If evaluation fails (e.g., synthesis failure), mark as failed so it won't be re-suggested
            ax_client.log_trial_failure(trial_index=trial_index)
            print(f"Synthesis or measurement failed for {comp}: {e}")

    # Report best found composition and observed performance
    best_parameters, best_metrics = ax_client.get_best_parameters()
    best_comp = best_parameters["composition"]
    best_mean = best_metrics[objective_name][0]
    print(f"Best composition: {best_comp}")
    print(f"Best observed {objective_name}: {best_mean:,.0f} S/m")

    # Plot optimization trace (best-so-far observed values)
    df_trials = ax_client.get_trials_data_frame()
    df_obj = df_trials[df_trials["metric_name"] == objective_name].copy()
    df_obj = df_obj.sort_values("trial_index")
    y = df_obj["mean"].to_numpy()
    cum_best = np.maximum.accumulate(y)
    x = np.arange(1, len(cum_best) + 1)

    fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
    ax.plot(x, y, "o", mfc="none", mec="gray", label="Observed")
    ax.plot(x, cum_best, "-", color="#0033FF", lw=2, label="Best so far")
    ax.set_xlabel("Trial number")
    ax.set_ylabel("Electrical conductivity (S/m)")
    ax.set_title("MAX phase conductivity optimization")
    ax.legend()
    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    main()