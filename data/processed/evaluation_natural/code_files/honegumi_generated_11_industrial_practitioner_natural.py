# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin(x1, x2, c1):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # add a made-up penalty based on category
    penalty_lookup = {"A": 1.0, "B": 0.0, "C": 2.0}
    y += penalty_lookup[c1]

    return y


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
        {
            "name": "c1",
            "type": "choice",
            "is_ordered": False,
            "values": ["A", "B", "C"],
        },
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
)


for i in range(21):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    c1 = parameterization["c1"]

    results = branin(x1, x2, c1)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Reproducible randomness for the simulator; remove or change seed when using real measurements.
RNG = np.random.default_rng(2025)


def simulate_electrical_conductivity(M_element: str, A_element: str, X_element: str, n_layer: str) -> float:
    """
    Domain-specific simulator for electrical conductivity (S/m) of MAX phases.

    This function provides a physics-informed heuristic to produce plausible
    conductivity values given the selected elements and stacking parameter.
    Replace this with actual lab measurement, DFT/simulation call, or a
    surrogate trained on your historical dataset when available.

    Parameters
    ----------
    M_element : str
        Early transition metal (e.g., Ti, V, Cr, Nb, Mo, Hf, Ta, Zr, Sc, Y).
    A_element : str
        A-group element (e.g., Al, Si, Ga, Ge, In, Sn).
    X_element : str
        X element in MAX phase (C or N).
    n_layer : str
        n in M(n+1)AX(n), as a string in {"1","2","3","4"}.

    Returns
    -------
    float
        Simulated electrical conductivity in S/m.
    """
    # Baseline conductivity scale for MAX phases (order ~10^6 S/m)
    base = 2.0e6

    # Contributions from M, A, X with heuristic magnitudes
    m_effect = {
        "Ti": 0.5e6,
        "V": 1.0e6,
        "Cr": 0.6e6,
        "Nb": 1.3e6,
        "Mo": 1.2e6,
        "Hf": 0.7e6,
        "Ta": 1.4e6,
        "Zr": 0.8e6,
        "Sc": 0.3e6,
        "Y": 0.4e6,
    }
    a_effect = {
        "Al": 0.30e6,
        "Si": 0.60e6,
        "Ga": 0.20e6,
        "Ge": 0.40e6,
        "In": 0.10e6,
        "Sn": 0.35e6,
    }
    x_effect = {
        "C": 0.40e6,
        "N": 0.20e6,
    }

    # Stacking effect: conductivity tends to increase with n due to more metallic layers
    try:
        n = int(n_layer)
    except Exception:
        n = 1
    n_contrib = 0.45e6 * max(0, n - 1)

    # Interactions and known favorable motifs (heuristic)
    synergy = 0.0
    if M_element in {"Nb", "Ta", "Mo"} and X_element == "C":
        synergy += 0.50e6
    if A_element in {"Si", "Ge", "Sn"} and X_element == "C":
        synergy += 0.30e6
    # Classic strong performer Ti3SiC2 (n=2)
    if M_element == "Ti" and A_element == "Si" and X_element == "C" and n == 2:
        synergy += 1.10e6
    # Slight penalty for Mo-N combinations (anecdotally lower conductivity than Mo-C)
    if M_element == "Mo" and X_element == "N":
        synergy -= 0.30e6
    # Favor TaC- and NbC-containing higher-n phases
    if M_element in {"Ta", "Nb"} and X_element == "C" and n >= 3:
        synergy += 0.40e6

    # Assemble contributions
    mu = (
        base
        + m_effect.get(M_element, 0.0)
        + a_effect.get(A_element, 0.0)
        + x_effect.get(X_element, 0.0)
        + n_contrib
        + synergy
    )

    # Additive noise to reflect measurement variability (set to 0.0 when using real values)
    noise = RNG.normal(loc=0.0, scale=0.10e6)  # ~1e5 S/m std dev
    y = max(0.0, mu + noise)
    return float(y)


# Initialize Ax client
ax_client = AxClient()

# Define search space according to the materials domain
ax_client.create_experiment(
    name="max_phase_conductivity_optimization",
    parameters=[
        {
            "name": "M_element",
            "type": "choice",
            "is_ordered": False,
            "values": ["Ti", "V", "Cr", "Nb", "Mo", "Hf", "Ta", "Zr", "Sc", "Y"],
        },
        {
            "name": "A_element",
            "type": "choice",
            "is_ordered": False,
            "values": ["Al", "Si", "Ga", "Ge", "In", "Sn"],
        },
        {
            "name": "X_element",
            "type": "choice",
            "is_ordered": False,
            "values": ["C", "N"],
        },
        {
            "name": "n_layer",
            "type": "choice",
            "is_ordered": False,
            "values": ["1", "2", "3", "4"],
        },
    ],
    objectives={
        "electrical_conductivity": ObjectiveProperties(minimize=False),
    },
)

# Optimization budget (number of synthesis runs)
N_TRIALS = 30

# Track observations for plotting
observed_conductivities = []

for i in range(N_TRIALS):
    parameters, trial_index = ax_client.get_next_trial()

    M = parameters["M_element"]
    A = parameters["A_element"]
    X = parameters["X_element"]
    n = parameters["n_layer"]

    # Replace the simulation call below with real lab measurement or high-fidelity simulation.
    conductivity = simulate_electrical_conductivity(M, A, X, n)

    # Report back a single mean; Ax will infer noise (since measurements are noisy in reality).
    ax_client.complete_trial(trial_index=trial_index, raw_data=conductivity)
    observed_conductivities.append(conductivity)

# Extract and print best suggestion
best_parameters, best_metrics = ax_client.get_best_parameters()
best_value = best_metrics.get("electrical_conductivity", {})
print("Best suggested MAX phase parameters:")
print(best_parameters)
print("Model-predicted electrical_conductivity (S/m):", best_value)

# Plot observed best-so-far conductivity over trials
x = np.arange(1, len(observed_conductivities) + 1)
y = np.array(observed_conductivities, dtype=float)
best_so_far = np.maximum.accumulate(y)

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(x, y, ec="k", fc="none", label="Observed")
ax.plot(x, best_so_far, color="#0033FF", lw=2, label="Best to Trial")
ax.set_xlabel("Trial Number")
ax.set_ylabel("Electrical Conductivity (S/m)")
ax.set_title("Bayesian Optimization of MAX Phase Conductivity")
ax.legend()
plt.tight_layout()
plt.show()