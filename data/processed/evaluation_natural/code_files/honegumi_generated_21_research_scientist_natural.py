# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"
obj2_name = "branin_swapped"


def branin_moo(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # second objective has x1 and x2 swapped
    y2 = float(
        (x1 - 5.1 / (4 * np.pi**2) * x2**2 + 5.0 / np.pi * x2 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x2)
        + 10
    )

    return {obj1_name: y, obj2_name: y2}


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
        obj2_name: ObjectiveProperties(minimize=True),
    },
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin_moo(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)
pareto_results = ax_client.get_pareto_optimal_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto[objectives[0]],
    pareto[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])

ax.legend()
plt.show()

# Multi-objective optimization for water treatment: tune three chemical dosages to trade off contaminant removal vs operational cost.
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt

# Random generator for reproducibility of the simulated evaluation noise
_rng = np.random.default_rng(42)

# Objective names (keys must match Ax objective definitions below)
removal_metric_name = "contaminant_removal"       # percentage, maximize
cost_metric_name = "operational_cost"             # USD per m3, minimize


def evaluate_water_treatment(coagulant_dose_mg_per_L: float,
                             oxidant_dose_mg_per_L: float,
                             polymer_dose_mg_per_L: float) -> dict:
    """
    Simulated evaluation for a water treatment step using coagulant, oxidant, and polymer dosages.

    Inputs (mg/L):
      - coagulant_dose_mg_per_L: 0.0 to 50.0
      - oxidant_dose_mg_per_L:   0.0 to 10.0
      - polymer_dose_mg_per_L:   0.0 to 5.0

    Outputs:
      - contaminant_removal: percentage (0-100), to maximize
      - operational_cost: USD per m3, to minimize

    Notes:
      - This function simulates realistic, noisy outcomes with saturating benefits, synergy, and overdosing penalties.
      - Replace the internals with actual lab measurements or a trusted process model when available.
    """
    # Saturating removal contributions (Hill/exponential-like)
    r_coag = 1.0 - np.exp(-0.08 * coagulant_dose_mg_per_L)   # Coagulant saturates around ~50 mg/L
    r_oxid = 1.0 - np.exp(-0.40 * oxidant_dose_mg_per_L)     # Oxidant saturates around ~10 mg/L
    r_poly = 1.0 - np.exp(-0.80 * polymer_dose_mg_per_L)     # Polymer saturates around ~5 mg/L

    # Synergy terms (coagulant-polymer improves floc formation; oxidant-coagulant can help upstream)
    synergy = 0.15 * r_coag * r_poly + 0.10 * r_oxid * r_coag

    # Base removal (fraction), with diminishing returns
    base_removal_fraction = 0.10 + 0.65 * r_coag + 0.20 * r_oxid + 0.15 * r_poly + synergy

    # Overdosing penalties
    penalty_coagulant = 0.0010 * max(0.0, coagulant_dose_mg_per_L - 35.0) ** 2
    penalty_oxidant = 0.0020 * max(0.0, oxidant_dose_mg_per_L - 8.0) ** 2

    removal_fraction = np.clip(base_removal_fraction - penalty_coagulant - penalty_oxidant, 0.0, 0.995)
    removal_pct = 100.0 * removal_fraction

    # Add measurement/process noise (about Â±1 percentage point std)
    removal_pct_measured = float(removal_pct + _rng.normal(0.0, 1.0))

    # Cost model (USD per m3)
    # Convert mg/L to g/m3 (= mg/L), multiply by price per g
    price_coagulant_per_kg = 0.60
    price_oxidant_per_kg = 1.20
    price_polymer_per_kg = 3.50

    price_coagulant_per_g = price_coagulant_per_kg / 1000.0
    price_oxidant_per_g = price_oxidant_per_kg / 1000.0
    price_polymer_per_g = price_polymer_per_kg / 1000.0

    chem_cost = (
        coagulant_dose_mg_per_L * price_coagulant_per_g
        + oxidant_dose_mg_per_L * price_oxidant_per_g
        + polymer_dose_mg_per_L * price_polymer_per_g
    )

    # Sludge/disposal/handling cost penalty grows superlinearly with coagulant dose
    sludge_cost = 0.00002 * (coagulant_dose_mg_per_L ** 2)  # e.g., up to ~$0.05 at 50 mg/L

    # Byproduct/disinfection control overhead if oxidant too high
    byproduct_cost = 0.00050 * max(0.0, oxidant_dose_mg_per_L - 5.0)

    # Fixed energy/operations overhead per m3
    fixed_ops_cost = 0.01

    total_cost = chem_cost + sludge_cost + byproduct_cost + fixed_ops_cost

    # Add measurement/accounting noise (~0.5 cents std)
    total_cost_measured = float(total_cost + _rng.normal(0.0, 0.005))

    return {
        removal_metric_name: removal_pct_measured,
        cost_metric_name: total_cost_measured,
    }


ax_client = AxClient()

# Define the experiment search space and multi-objective
ax_client.create_experiment(
    parameters=[
        {
            "name": "coagulant_dose_mg_per_L",
            "type": "range",
            "bounds": [0.0, 50.0],
        },
        {
            "name": "oxidant_dose_mg_per_L",
            "type": "range",
            "bounds": [0.0, 10.0],
        },
        {
            "name": "polymer_dose_mg_per_L",
            "type": "range",
            "bounds": [0.0, 5.0],
        },
    ],
    objectives={
        removal_metric_name: ObjectiveProperties(minimize=False),
        cost_metric_name: ObjectiveProperties(minimize=True),
    },
)

# Optimization budget: 32 experiments
for i in range(32):
    parameterization, trial_index = ax_client.get_next_trial()

    coagulant = float(parameterization["coagulant_dose_mg_per_L"])
    oxidant = float(parameterization["oxidant_dose_mg_per_L"])
    polymer = float(parameterization["polymer_dose_mg_per_L"])

    results = evaluate_water_treatment(coagulant, oxidant, polymer)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve Pareto-optimal parameterizations (based on observed data)
pareto_results = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

# Visualization: Observations and Pareto front
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)

# Pareto front points extracted from AxClient
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto_df = pd.DataFrame(pareto_data).sort_values(objectives[0])

# Scatter of observed data
ax.scatter(
    df[objectives[0]],
    df[objectives[1]],
    fc="None",
    ec="k",
    label="Observed",
)

# Line for Pareto front (connect along the first objective)
ax.plot(
    pareto_df[objectives[0]],
    pareto_df[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)

ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])
ax.set_title("Water Treatment: Contaminant Removal vs Operational Cost")
ax.legend()
plt.tight_layout()
plt.show()