# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    return y


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        "x1 + x2 <= 15.0",  # example of a sum constraint
    ],
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Generated for electrolyte formulation optimization using Ax Platform
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from typing import Dict, Tuple
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain: Formulate a multi-salt electrolyte to maximize ionic conductivity with a viscosity-imposed
# total concentration limit (sum of salts <= 2.0 M). Budget ~40 experiments, noisy measurements.

np.random.seed(123)

conductivity_metric_name = "conductivity_mS_per_cm"

# Synthetic evaluator to emulate experimental measurement of conductivity.
# Replace with actual measurement integration if available.
def evaluate_electrolyte_conductivity(
    salt_A_conc: float,
    salt_B_conc: float,
    salt_C_conc: float,
    salt_D_conc: float,
    noise_sem: float = 0.3,
) -> Dict[str, Tuple[float, float]]:
    """
    Returns a dict mapping the conductivity metric name to a (mean, sem) tuple.

    The synthetic model captures:
    - Baseline molar conductivity contributions weighted by ion mobility-like factors
    - Saturation and viscosity/ion-pairing penalty at high total molarity
    - Synergistic and antagonistic mixing effects between specific salts
    - Additive Gaussian measurement noise with specified SEM

    Parameters are in molarity (M). Output is in mS/cm.
    """
    cA = float(salt_A_conc)
    cB = float(salt_B_conc)
    cC = float(salt_C_conc)
    cD = float(salt_D_conc)

    total_c = cA + cB + cC + cD
    if total_c > 2.0 + 1e-8:
        # The optimizer should respect the constraint, but guard anyway.
        raise ValueError(f"Total concentration {total_c:.3f} M exceeds 2.0 M limit.")

    # Relative mobility weights (arbitrary but plausible differences)
    wA, wB, wC, wD = 1.00, 0.85, 1.20, 0.70

    # Base linear contribution from ions
    base = wA * cA + wB * cB + wC * cC + wD * cD

    # Saturation (increases with total conc) and viscosity/ion-pairing penalty (decreases at high conc)
    # Form chosen to have broad optimum ~1.2-1.6 M total.
    saturation = 1.0 - np.exp(-2.5 * total_c)          # rises quickly then saturates
    viscosity_penalty = np.exp(- (total_c / 2.2) ** 3) # decays as conc approaches upper bound
    mixing_factor = saturation * viscosity_penalty

    # Synergy: A with C (positive), antagonism: B with D (negative), diminishing returns via min()
    synergy = 0.12 * min(cA, cC) - 0.06 * min(cB, cD)

    # Scale to typical conductivity values (mS/cm)
    scale = 10.0
    mean_conductivity = scale * (base * mixing_factor + synergy)

    # Non-negativity floor
    mean_conductivity = max(mean_conductivity, 0.0)

    # Add measurement noise (zero-mean), and report SEM to Ax
    noisy_measurement = float(np.random.normal(loc=mean_conductivity, scale=noise_sem))

    return {conductivity_metric_name: (noisy_measurement, noise_sem)}


# Configure Ax optimization
ax_client = AxClient()
ax_client.create_experiment(
    name="electrolyte_conductivity_optimization",
    parameters=[
        {"name": "salt_A_conc", "type": "range", "bounds": [0.0, 2.0]},
        {"name": "salt_B_conc", "type": "range", "bounds": [0.0, 2.0]},
        {"name": "salt_C_conc", "type": "range", "bounds": [0.0, 2.0]},
        {"name": "salt_D_conc", "type": "range", "bounds": [0.0, 2.0]},
    ],
    objectives={
        conductivity_metric_name: ObjectiveProperties(minimize=False),
    },
    parameter_constraints=[
        "salt_A_conc + salt_B_conc + salt_C_conc + salt_D_conc <= 2.0",
    ],
    overwrite_existing_experiment=True,
)

# Run optimization for the available budget
budget_trials = 40
for _ in range(budget_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    cA = parameterization["salt_A_conc"]
    cB = parameterization["salt_B_conc"]
    cC = parameterization["salt_C_conc"]
    cD = parameterization["salt_D_conc"]

    results = evaluate_electrolyte_conductivity(cA, cB, cC, cD)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, best_metrics = ax_client.get_best_parameters()

print("Best formulation (estimated):")
for k, v in best_parameters.items():
    print(f"  {k}: {v:.4f} M")
best_mean = best_metrics[conductivity_metric_name]["mean"]
best_sem = best_metrics[conductivity_metric_name].get("sem", None)
if best_sem is not None:
    print(f"Estimated best {conductivity_metric_name}: {best_mean:.3f} Â± {best_sem:.3f}")
else:
    print(f"Estimated best {conductivity_metric_name}: {best_mean:.3f}")

# Plot results over trials
metric_name = conductivity_metric_name
df = ax_client.get_trials_data_frame()

# Ensure the metric column exists
if metric_name not in df.columns:
    raise RuntimeError(f"Metric column '{metric_name}' not found in trials DataFrame.")

y = df[metric_name].to_numpy()
x = np.arange(len(y))
best_so_far = np.maximum.accumulate(y)

fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
ax.scatter(x, y, ec="k", fc="none", label="Observed conductivity")
ax.plot(x, best_so_far, color="#0033FF", lw=2, label="Best to trial")
ax.set_xlabel("Trial number")
ax.set_ylabel("Conductivity (mS/cm)")
ax.set_title("Electrolyte conductivity optimization (Ax)")
ax.legend()
plt.tight_layout()
plt.show()