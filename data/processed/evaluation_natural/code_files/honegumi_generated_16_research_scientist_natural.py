# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain-specific objective names
TEXTURE_METRIC = "texture"
PALATABILITY_METRIC = "palatability"

# Total composition must sum to 1.0 (fractions)
TOTAL_FRACTION = 1.0

# Random number generator for simulating experimental noise
_rng = np.random.default_rng()


def _hill(x: float, k: float, n: float) -> float:
    """Hill-type saturation function for smooth, bounded effects."""
    x = np.clip(x, 0.0, 1.0)
    denom = (x**n + k**n)
    return float((x**n) / (denom + 1e-12))


def evaluate_food_formulation(
    protein_fraction: float,
    fat_fraction: float,
    carbohydrate_fraction: float,
    water_fraction: float,
) -> dict:
    """Evaluate a protein-enriched food formulation on texture and palatability.

    This function simulates two sensory metrics:
      - texture: favors sufficient protein and binding carbohydrate; penalizes excess water and fat
      - palatability: favors fat and carbohydrate; penalizes excessive protein and water

    Notes:
      - Replace this surrogate with actual measurement logic when integrating with lab/production:
        e.g., run experiment, measure texture (e.g., TPA hardness/springiness) and palatability
        (e.g., sensory panel or predictive model), then return measured values below.

    Returns:
      A dict with keys TEXTURE_METRIC and PALATABILITY_METRIC (both on 0-100 scale).
    """
    # Ensure valid composition
    fractions = np.array([protein_fraction, fat_fraction, carbohydrate_fraction, water_fraction], dtype=float)
    if np.any(fractions < -1e-9) or np.any(fractions > 1.0 + 1e-9):
        raise ValueError("All ingredient fractions must be within [0, 1].")
    if not np.isclose(float(fractions.sum()), TOTAL_FRACTION, atol=1e-6):
        raise ValueError("Ingredient fractions must sum to 1.0.")

    P = float(protein_fraction)
    F = float(fat_fraction)
    C = float(carbohydrate_fraction)
    W = float(water_fraction)

    # Smooth, bounded effect terms (all in [0,1])
    p_struct = _hill(P, k=0.25, n=2.0)   # protein contribution to structure/texture
    c_bind = _hill(C, k=0.20, n=2.0)     # carbohydrate binder contribution
    f_rich = _hill(F, k=0.25, n=2.0)     # fat contribution to palatability
    c_sweet = _hill(C, k=0.30, n=2.0)    # carbohydrate contribution to palatability

    # Interaction terms encourage balanced blends (bounded by product of fractions)
    pc_interaction = P * C
    fc_interaction = F * C

    # Texture model (dimensionless 0..1 before scaling)
    texture_term = (
        0.55 * p_struct       # protein builds structure up to saturation
        + 0.25 * c_bind       # binder improves cohesion/texture
        - 0.20 * W            # excess water weakens texture
        - 0.10 * F            # excess fat can soften texture
        + 0.05 * pc_interaction
    )

    # Palatability model (dimensionless 0..1 before scaling)
    pal_term = (
        0.60 * f_rich         # fat improves palatability up to saturation
        + 0.25 * c_sweet      # carbohydrates aid palatability
        - 0.35 * P            # excess protein can reduce palatability
        - 0.05 * W            # dilution from water
        + 0.05 * fc_interaction
    )

    # Add baseline and clip to [0, 1], then scale to [0, 100]
    texture_score = 100.0 * np.clip(texture_term + 0.20, 0.0, 1.0)
    palatability_score = 100.0 * np.clip(pal_term + 0.20, 0.0, 1.0)

    # Simulated measurement noise (adjust std as needed to reflect experimental noise)
    texture_noise = _rng.normal(loc=0.0, scale=2.0)
    palatability_noise = _rng.normal(loc=0.0, scale=2.0)

    texture_score = float(np.clip(texture_score + texture_noise, 0.0, 100.0))
    palatability_score = float(np.clip(palatability_score + palatability_noise, 0.0, 100.0))

    return {TEXTURE_METRIC: texture_score, PALATABILITY_METRIC: palatability_score}


# Set up Ax client and experiment
ax_client = AxClient()

ax_client.create_experiment(
    name="protein_enriched_food_formulation_moo",
    parameters=[
        # Reparameterization: we optimize 3 ingredients directly and compute water as 1 - sum(three).
        {"name": "protein_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "fat_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "carbohydrate_fraction", "type": "range", "bounds": [0.0, 1.0]},
    ],
    objectives={
        TEXTURE_METRIC: ObjectiveProperties(minimize=False),
        PALATABILITY_METRIC: ObjectiveProperties(minimize=False),
    },
    parameter_constraints=[
        # Composition constraint: protein + fat + carbohydrate <= 1.0 (water is the remainder)
        "protein_fraction + fat_fraction + carbohydrate_fraction <= 1.0"
    ],
    # We'll model observation noise implicitly by returning noisy measurements from evaluate_food_formulation.
)


# Run Bayesian optimization loop
num_trials = 40  # adjust based on budget
for i in range(num_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    protein = float(parameterization["protein_fraction"])
    fat = float(parameterization["fat_fraction"])
    carb = float(parameterization["carbohydrate_fraction"])
    water = float(TOTAL_FRACTION - (protein + fat + carb))

    # Numerical safety for minimal negative due to float precision
    if water < 0:
        water = 0.0

    results = evaluate_food_formulation(
        protein_fraction=protein,
        fat_fraction=fat,
        carbohydrate_fraction=carb,
        water_fraction=water,
    )
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)


# Retrieve results
df = ax_client.get_trials_data_frame()

# Compute empirical Pareto frontier from observed data for plotting
obj_names = [TEXTURE_METRIC, PALATABILITY_METRIC]
points = df[obj_names].to_numpy(dtype=float)

def compute_pareto_mask(values: np.ndarray) -> np.ndarray:
    """Return boolean mask of points on the Pareto frontier (maximization)."""
    n = values.shape[0]
    mask = np.ones(n, dtype=bool)
    for i in range(n):
        if not mask[i]:
            continue
        for j in range(n):
            if i == j:
                continue
            # j dominates i if all objectives >= and at least one >
            if np.all(values[j] >= values[i]) and np.any(values[j] > values[i]):
                mask[i] = False
                break
    return mask

pareto_mask = compute_pareto_mask(points)
pareto_df = df.loc[pareto_mask, obj_names].sort_values(by=obj_names[0])


# Plot observed outcomes and Pareto frontier
fig, ax = plt.subplots(figsize=(6, 4), dpi=150)

ax.scatter(
    df[obj_names[0]], df[obj_names[1]],
    fc="None", ec="k", label="Observed trials"
)

if len(pareto_df) > 1:
    ax.plot(
        pareto_df[obj_names[0]],
        pareto_df[obj_names[1]],
        color="#0033FF",
        lw=2,
        label="Pareto front (observed)"
    )
elif len(pareto_df) == 1:
    ax.scatter(
        pareto_df[obj_names[0]],
        pareto_df[obj_names[1]],
        color="#0033FF",
        label="Pareto point (observed)"
    )

ax.set_xlabel(f"{obj_names[0]} (higher is better)")
ax.set_ylabel(f"{obj_names[1]} (higher is better)")
ax.set_title("Protein-Enriched Food Formulation: Texture vs. Palatability")
ax.legend()
plt.tight_layout()
plt.show()