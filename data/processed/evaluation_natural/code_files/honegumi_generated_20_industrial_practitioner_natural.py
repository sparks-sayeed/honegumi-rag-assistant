# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain: LED package thermal optimization
# Goal: Minimize operating (junction) temperature by selecting a heat sink type and
#       optimizing thermal paste thickness (TIM) under a 28-trial prototype budget.

np.random.seed(42)


# Physical constants and surrogate model parameters (simplified but physics-inspired)
AMBIENT_TEMPERATURE_C = 25.0  # Ambient temperature in °C
HEAT_DISSIPATION_W = 9.0      # Heat to be dissipated by the LED in Watts (electrical-in minus light-out)
R_JUNCTION_TO_CASE_K_PER_W = 1.5  # Junction-to-case thermal resistance in K/W

# Effective thermal interface material (TIM) properties
TIM_THERMAL_CONDUCTIVITY_W_PER_MK = 3.0  # W/(m·K), typical mid-range thermal paste
CONTACT_AREA_M2 = (20e-3 * 20e-3)        # 20 mm x 20 mm footprint -> 400 mm^2

# Empirical contact resistance term that decreases with thickness (captures interface conformity)
def tim_contact_resistance_k_per_w(thickness_um: float) -> float:
    # As thickness increases, contact resistance reduces and asymptotes
    # Coefficients chosen to produce reasonable magnitudes (0.01–0.1 K/W)
    return 0.06 * np.exp(-thickness_um / 60.0) + 0.01

# Heat sink options (categorical), with approximate thermal resistances to ambient
HEAT_SINK_THERMAL_RESISTANCE_K_PER_W = {
    "aluminum_plate": 4.0,               # Very simple plate, minimal fins
    "finned_aluminum_compact": 2.5,      # Compact finned heatsink
    "finned_aluminum_large": 1.5,        # Larger finned heatsink
    "vapor_chamber_heat_pipe": 1.0,      # Advanced heat pipe/vapor chamber solution
}


def compute_tim_conduction_resistance_k_per_w(thickness_um: float) -> float:
    # R = t / (k * A). Convert micrometers to meters.
    thickness_m = thickness_um * 1e-6
    return thickness_m / (TIM_THERMAL_CONDUCTIVITY_W_PER_MK * CONTACT_AREA_M2)


def evaluate_led_operating_temperature_celsius(heat_sink_type: str, paste_thickness_um: float) -> float:
    """
    Simulate the LED junction operating temperature (°C) for a given heat sink and TIM thickness.

    This uses a simplified thermal network:
      T_j = T_amb + P * (R_jc + R_tim + R_hs) + noise
    where:
      - R_jc: LED junction-to-case
      - R_tim: TIM conduction + contact resistance (function of thickness)
      - R_hs: Heat sink thermal resistance to ambient (depends on heat sink type)

    Adds small Gaussian noise to mimic measurement variability.
    """
    if heat_sink_type not in HEAT_SINK_THERMAL_RESISTANCE_K_PER_W:
        raise ValueError(f"Unknown heat sink type: {heat_sink_type}")

    # Compute TIM resistance components
    r_tim_conduction = compute_tim_conduction_resistance_k_per_w(paste_thickness_um)
    r_tim_contact = tim_contact_resistance_k_per_w(paste_thickness_um)
    r_tim_total = r_tim_conduction + r_tim_contact

    # Heat sink resistance
    r_hs = HEAT_SINK_THERMAL_RESISTANCE_K_PER_W[heat_sink_type]

    # Total thermal resistance from junction to ambient
    r_total = R_JUNCTION_TO_CASE_K_PER_W + r_tim_total + r_hs

    # Junction temperature
    t_junction_c = AMBIENT_TEMPERATURE_C + HEAT_DISSIPATION_W * r_total

    # Add measurement noise (heteroscedastic: thinner layers often more variable)
    noise_sigma_c = 0.4 + 0.6 * np.exp(-paste_thickness_um / 80.0)  # 0.4–1.0 °C typical
    t_junction_c_noisy = float(np.random.normal(loc=t_junction_c, scale=noise_sigma_c))

    return t_junction_c_noisy


# Set up Ax optimization client
ax_client = AxClient()

ax_client.create_experiment(
    name="led_package_thermal_optimization",
    parameters=[
        {
            "name": "paste_thickness_um",
            "type": "range",
            "bounds": [20.0, 300.0],  # 20–300 µm
        },
        {
            "name": "heat_sink_type",
            "type": "choice",
            "is_ordered": False,
            "values": list(HEAT_SINK_THERMAL_RESISTANCE_K_PER_W.keys()),
        },
    ],
    objectives={
        "operating_temperature_celsius": ObjectiveProperties(minimize=True),
    },
    overwrite_existing_experiment=True,
)


# Optimization loop with a prototype budget of 28 trials
NUM_TRIALS = 28
for _ in range(NUM_TRIALS):
    parameterization, trial_index = ax_client.get_next_trial()

    heat_sink_type = parameterization["heat_sink_type"]
    paste_thickness_um = float(parameterization["paste_thickness_um"])

    result_celsius = evaluate_led_operating_temperature_celsius(
        heat_sink_type=heat_sink_type,
        paste_thickness_um=paste_thickness_um,
    )

    # Report measured objective to Ax
    ax_client.complete_trial(trial_index=trial_index, raw_data=result_celsius)


# Retrieve best found parameters
best_parameters, best_values = ax_client.get_best_parameters()
best_temp_mean = best_values["operating_temperature_celsius"]["mean"]
best_temp_sem = best_values["operating_temperature_celsius"]["sem"]

print("Best configuration found:")
print(f"  Heat sink type: {best_parameters['heat_sink_type']}")
print(f"  Paste thickness: {best_parameters['paste_thickness_um']:.1f} µm")
print(f"  Operating temperature (mean ± SEM): {best_temp_mean:.2f} ± {best_temp_sem:.2f} °C")


# Plot results across trials
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

y = df[objectives[0]].values
x = df.index.values
best_so_far = np.minimum.accumulate(y)

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(x, y, ec="k", fc="none", label="Observed")
ax.plot(x, best_so_far, color="#0033FF", lw=2, label="Best to Trial")
ax.set_xlabel("Trial Number")
ax.set_ylabel("Operating Temperature (°C)")
ax.set_title("LED Operating Temperature vs. Trial")
ax.legend()
plt.tight_layout()
plt.show()