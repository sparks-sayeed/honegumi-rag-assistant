# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin3(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    return y


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
    ],
)


for i in range(21):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]
    x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

    results = branin3(x1, x2, x3)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from typing import Dict, Tuple
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# ----------------------------
# Problem: Color matching via mixing red, yellow, blue liquids
# Objective: minimize spectral_error between mixed color and target across 8 sensor channels
# Constraint: red_fraction + yellow_fraction + blue_fraction == 1.0 (handled via blue = 1 - red - yellow)
# Trials budget: 30
# ----------------------------

np.random.seed(42)

# Metric name for Ax
metric_name = "spectral_error"

# Number of spectral channels (sensor reports 8 channels)
N_CHANNELS = 8
CHANNEL_INDICES = np.arange(1, N_CHANNELS + 1)

# Define reference spectra for pure primary liquids (values in [0, 1])
# These are illustrative and should be replaced with measured spectra for your liquids.
PURE_RED_SPECTRUM = np.array([0.05, 0.07, 0.10, 0.20, 0.40, 0.72, 0.92, 1.00], dtype=float)
PURE_YELLOW_SPECTRUM = np.array([0.10, 0.20, 0.52, 0.82, 0.90, 0.86, 0.62, 0.35], dtype=float)
PURE_BLUE_SPECTRUM = np.array([0.98, 0.90, 0.62, 0.30, 0.15, 0.10, 0.07, 0.05], dtype=float)

# Define target spectrum to match (values in [0, 1])
# Replace this with your actual target sensor reading across 8 channels.
TARGET_SPECTRUM = np.array([0.20, 0.30, 0.55, 0.78, 0.78, 0.70, 0.50, 0.30], dtype=float)

# Simulated sensor noise (standard deviation per channel). Set to 0 for deterministic evaluations.
SENSOR_NOISE_STD = 0.01


def simulate_sensor_spectrum(red_fraction: float, yellow_fraction: float, blue_fraction: float) -> np.ndarray:
    """
    Simulate the sensor's 8-channel spectrum for a given mixture of red, yellow, and blue.

    This uses a convex combination of the pure component spectra and adds Gaussian noise to
    emulate measurement noise.

    Replace this with your actual measurement function that:
    - Prepares the mixture,
    - Reads the 8-channel sensor, and
    - Returns the 8-channel array.
    """
    assert 0.0 <= red_fraction <= 1.0
    assert 0.0 <= yellow_fraction <= 1.0
    assert 0.0 <= blue_fraction <= 1.0
    assert abs((red_fraction + yellow_fraction + blue_fraction) - 1.0) < 1e-8

    mixed = (
        red_fraction * PURE_RED_SPECTRUM
        + yellow_fraction * PURE_YELLOW_SPECTRUM
        + blue_fraction * PURE_BLUE_SPECTRUM
    )

    if SENSOR_NOISE_STD > 0:
        noise = np.random.normal(loc=0.0, scale=SENSOR_NOISE_STD, size=N_CHANNELS)
        mixed = mixed + noise

    # Clip to physically meaningful range [0, 1]
    mixed = np.clip(mixed, 0.0, 1.0)
    return mixed


def evaluate_color_match(red_fraction: float, yellow_fraction: float) -> float:
    """
    Compute the spectral error between the mixed color and the target color.

    We enforce the composition constraint exactly by computing blue as the remainder.
    The error is RMSE across the 8 spectral channels. Lower is better.

    Returns:
        spectral_error_rmse (float): Root mean squared error across 8 channels.
    """
    blue_fraction = 1.0 - (red_fraction + yellow_fraction)

    # Safety: if numerical issues produce a slight negative due to rounding, clip.
    if blue_fraction < 0:
        # Penalize infeasible proposals heavily to guide optimizer away (shouldn't happen due to constraint).
        return 1e6

    measured_spectrum = simulate_sensor_spectrum(red_fraction, yellow_fraction, blue_fraction)
    rmse = float(np.sqrt(np.mean((measured_spectrum - TARGET_SPECTRUM) ** 2)))
    return rmse


# Composition total
TOTAL_FRACTION = 1.0

# Initialize Ax optimization client
ax_client = AxClient()

# Create experiment with two free parameters and an implicit third (blue = 1 - red - yellow)
ax_client.create_experiment(
    parameters=[
        {"name": "red_fraction", "type": "range", "bounds": [0.0, TOTAL_FRACTION]},
        {"name": "yellow_fraction", "type": "range", "bounds": [0.0, TOTAL_FRACTION]},
    ],
    objectives={
        metric_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"red_fraction + yellow_fraction <= {TOTAL_FRACTION}",
    ],
    name="color_matching_red_yellow_blue",
)

# Run optimization for 30 trials
N_TRIALS = 30
for i in range(N_TRIALS):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters
    red_fraction = float(parameterization["red_fraction"])
    yellow_fraction = float(parameterization["yellow_fraction"])
    blue_fraction = TOTAL_FRACTION - (red_fraction + yellow_fraction)

    # Evaluate objective
    spectral_error_value = evaluate_color_match(red_fraction, yellow_fraction)

    # Report result back to Ax (single-objective: scalar is acceptable)
    ax_client.complete_trial(trial_index=trial_index, raw_data=spectral_error_value)

# Retrieve best parameters
best_parameters, best_values = ax_client.get_best_parameters()
best_red = best_parameters["red_fraction"]
best_yellow = best_parameters["yellow_fraction"]
best_blue = TOTAL_FRACTION - (best_red + best_yellow)
best_error = best_values[metric_name]["value"]

print("Best mixture found:")
print(f"  red_fraction:    {best_red:.4f}")
print(f"  yellow_fraction: {best_yellow:.4f}")
print(f"  blue_fraction:   {best_blue:.4f}")
print(f"  spectral_error (RMSE): {best_error:.6f}")

# Plot trial-wise objective values and running best
objectives = ax_client.objective_names
df: pd.DataFrame = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(df.index, np.minimum.accumulate(df[objectives].values.squeeze()), color="#0033FF", lw=2, label="Best to Trial")
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])
ax.set_title("Spectral Error over Trials")
ax.legend()
plt.tight_layout()
plt.show()

# Plot target spectrum vs. best predicted spectrum
best_mixed_spectrum = simulate_sensor_spectrum(best_red, best_yellow, best_blue)
fig2, ax2 = plt.subplots(figsize=(6, 4), dpi=150)
ax2.plot(CHANNEL_INDICES, TARGET_SPECTRUM, "o-", label="Target", color="black")
ax2.plot(CHANNEL_INDICES, best_mixed_spectrum, "o-", label="Best Mix", color="#FF6F00")
ax2.set_xlabel("Spectral Channel")
ax2.set_ylabel("Normalized Intensity")
ax2.set_title("Target vs. Best Mixed Spectrum")
ax2.set_xticks(CHANNEL_INDICES)
ax2.set_ylim(0, 1.05)
ax2.grid(alpha=0.2)
ax2.legend()
plt.tight_layout()
plt.show()