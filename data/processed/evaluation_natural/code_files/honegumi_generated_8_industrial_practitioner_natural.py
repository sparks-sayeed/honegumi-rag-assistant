# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    return y


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Generated for optimizing fermentation protein production with Ax Platform
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from typing import Dict, Tuple
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain-specific objective name
OBJECTIVE_NAME = "protein_production"  # units: arbitrary productivity units (e.g., g/L)

# Reproducibility
RNG = np.random.default_rng(seed=42)


def evaluate_fermentation_run(temperature_c: float, pH: float, mixing_rpm: float) -> Tuple[float, float]:
    """
    Simulate evaluating a fermentation batch for protein production.

    This function provides a realistic surrogate for actual lab/plant evaluation. Replace this
    with real measurement logic (e.g., run a batch and measure titer/yield) when available.

    Inputs:
      - temperature_c: Fermentation temperature in °C
      - pH: Medium pH
      - mixing_rpm: Agitation speed in rpm

    Returns:
      - mean production value (float)
      - standard error of measurement (float)
    """
    # Biologically plausible response surface with a single broad optimum
    # around temperature ~34°C, pH ~7.0, mixing ~650 rpm.
    temp_effect = np.exp(-0.5 * ((temperature_c - 34.0) / 3.5) ** 2)
    ph_effect = np.exp(-0.5 * ((pH - 7.0) / 0.4) ** 2)
    mix_effect = np.exp(-0.5 * ((mixing_rpm - 650.0) / 200.0) ** 2)

    # Mild synergistic bump at slightly higher temp and mixing
    synergy = 0.10 * np.exp(-0.5 * ((temperature_c - 36.0) / 2.0) ** 2) * np.exp(
        -0.5 * ((mixing_rpm - 800.0) / 150.0) ** 2
    )

    # Base production scale (peak near ~100 units)
    true_signal = 100.0 * temp_effect * ph_effect * mix_effect * (1.0 + synergy)

    # Add small systematic penalty near boundaries (reflects operational stress)
    boundary_penalty = 0.0
    boundary_penalty += 3.0 * np.exp(-0.5 * ((temperature_c - 20.0) / 1.0) ** 2)
    boundary_penalty += 3.0 * np.exp(-0.5 * ((temperature_c - 40.0) / 1.0) ** 2)
    boundary_penalty += 3.0 * np.exp(-0.5 * ((pH - 5.5) / 0.2) ** 2)
    boundary_penalty += 3.0 * np.exp(-0.5 * ((pH - 8.5) / 0.2) ** 2)
    boundary_penalty += 3.0 * np.exp(-0.5 * ((mixing_rpm - 200.0) / 40.0) ** 2)
    boundary_penalty += 3.0 * np.exp(-0.5 * ((mixing_rpm - 1000.0) / 40.0) ** 2)

    mean_production = max(0.0, true_signal - boundary_penalty)

    # Add experimental noise (heteroscedastic: scales roughly with signal level)
    noise_sd = 2.0 + 0.05 * mean_production  # measurement/process noise
    observed_production = mean_production + RNG.normal(0.0, noise_sd)

    # Standard error estimate (if you have replicate batches, replace accordingly)
    sem_estimate = max(0.5, 0.5 * noise_sd)

    # Ensure non-negative production
    observed_production = float(max(0.0, observed_production))

    return observed_production, float(sem_estimate)


# Initialize Ax client
ax_client = AxClient()

# Define safe operating ranges (bounds)
TEMPERATURE_BOUNDS = [20.0, 40.0]  # °C
PH_BOUNDS = [5.5, 8.5]             # pH
MIXING_BOUNDS = [200.0, 1000.0]    # rpm

# Create experiment: single objective (maximize protein production), noisy measurements
ax_client.create_experiment(
    name="fermentation_protein_optimization",
    parameters=[
        {"name": "temperature_celsius", "type": "range", "bounds": TEMPERATURE_BOUNDS},
        {"name": "ph", "type": "range", "bounds": PH_BOUNDS},
        {"name": "mixing_speed_rpm", "type": "range", "bounds": MIXING_BOUNDS},
    ],
    objectives={
        OBJECTIVE_NAME: ObjectiveProperties(minimize=False),
    },
    # No explicit constraints besides bounds; batch size is 1 (sequential)
)

# Run optimization for the allocated budget
TOTAL_TRIALS = 30
for _ in range(TOTAL_TRIALS):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters for this trial
    temperature_celsius = float(parameterization["temperature_celsius"])
    ph = float(parameterization["ph"])
    mixing_speed_rpm = float(parameterization["mixing_speed_rpm"])

    # Evaluate the trial
    try:
        production_mean, production_sem = evaluate_fermentation_run(
            temperature_celsius, ph, mixing_speed_rpm
        )
        ax_client.complete_trial(
            trial_index=trial_index,
            raw_data={OBJECTIVE_NAME: (production_mean, production_sem)},
        )
    except Exception as e:
        # Mark trial as failed if something goes wrong
        ax_client.log_trial_failure(trial_index=trial_index, reason=str(e))

# Retrieve best found parameters
best_parameters, best_values = ax_client.get_best_parameters()
best_mean = best_values[OBJECTIVE_NAME]["mean"]
best_sem = best_values[OBJECTIVE_NAME].get("sem", None)

print("Best parameters found:")
for k, v in best_parameters.items():
    print(f"  {k}: {v:.4f}")
print(f"Best observed {OBJECTIVE_NAME}: {best_mean:.3f}" + (f" ± {best_sem:.3f}" if best_sem is not None else ""))

# Plot results
df = ax_client.get_trials_data_frame()
if OBJECTIVE_NAME in df.columns:
    y = df[OBJECTIVE_NAME].astype(float)
    x = df.index

    fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
    ax.scatter(x, y, ec="k", fc="none", label="Observed")
    ax.plot(x, np.maximum.accumulate(y), color="#0033FF", lw=2, label="Best to Trial")
    ax.set_xlabel("Trial Number")
    ax.set_ylabel(f"{OBJECTIVE_NAME} (higher is better)")
    ax.set_title("Fermentation Protein Production Optimization")
    ax.legend()
    plt.tight_layout()
    plt.show()
else:
    print("No data available to plot.")