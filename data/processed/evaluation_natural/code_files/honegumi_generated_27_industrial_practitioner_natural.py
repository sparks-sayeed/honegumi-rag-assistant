# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from ax.service.ax_client import AxClient
try:
    # Ax 0.4.3 and later
    from ax.service.utils.instantiation import ObjectiveProperties
except Exception:
    # Fallback for older versions
    from ax.service.ax_client import ObjectiveProperties


# Domain-specific objective names
REFRACTIVE_INDEX = "refractive_index"  # maximize
DISPERSION = "dispersion"              # minimize (lower chromatic dispersion is better)

# Domain-specific parameter names (glass composition fractions)
SILICA = "silica_fraction"             # SiO2
TITANIA = "titania_fraction"           # TiO2
BORON = "boron_oxide_fraction"         # B2O3

# Compositional total (fractions sum to 1.0)
COMPOSITION_TOTAL = 1.0

# Reproducible randomness for the synthetic evaluation (noise model enabled)
rng = np.random.default_rng(seed=42)


def simulate_optical_properties(silica_fraction: float,
                                titania_fraction: float,
                                boron_oxide_fraction: float) -> dict:
    """
    Simulate optical properties of a ternary glass from oxide fractions.

    This function provides a realistic, physics-inspired surrogate for:
      - refractive_index (to maximize)
      - dispersion (to minimize)

    Modeling assumptions:
      - Use Lorentz-Lorenz mixing of "molar refractivity" proxies to compute n:
          L = (n^2 - 1) / (n^2 + 2)
          L_mix = sum_i x_i * L_i, then n = sqrt((2*L_mix + 1) / (1 - L_mix))
        Approximated L_i derived from representative indices at ~589 nm:
          SiO2 (n≈1.458), TiO2-rich contribution (n≈2.3), B2O3 (n≈1.445)
      - Dispersion is modeled as a weighted sum of component dispersivities plus
        a correlation term that increases dispersion with higher index (trade-off).

    Returns a dict mapping objective names to (mean, sem) tuples with noise.
    """

    # Clamp for numerical safety
    s = float(np.clip(silica_fraction, 0.0, 1.0))
    t = float(np.clip(titania_fraction, 0.0, 1.0))
    b = float(np.clip(boron_oxide_fraction, 0.0, 1.0))

    # Renormalize tiny drift to ensure s + t + b == 1.0
    total = s + t + b
    if total <= 0:
        # Degenerate case shouldn't happen with constraints, but guard anyway
        s, t, b = 1.0, 0.0, 0.0
    else:
        s, t, b = s / total, t / total, b / total

    # Lorentz-Lorenz proxies per component (derived from representative indices)
    # L = (n^2 - 1) / (n^2 + 2)
    def L_from_n(n):
        n2 = n ** 2
        return (n2 - 1.0) / (n2 + 2.0)

    L_silica = L_from_n(1.458)   # ~0.273
    L_titania = L_from_n(2.30)   # ~0.588, TiO2 increases index strongly
    L_boron = L_from_n(1.445)    # ~0.266

    L_mix = s * L_silica + t * L_titania + b * L_boron
    # Invert Lorentz-Lorenz to get refractive index
    n2 = (2.0 * L_mix + 1.0) / max(1e-9, (1.0 - L_mix))
    refractive_index = float(np.sqrt(max(1.0, n2)))

    # Simple dispersion model (lower is better):
    # Component dispersion weights: B2O3 (low), SiO2 (moderate), TiO2 (high)
    disp_components = s * 0.50 + t * 1.20 + b * 0.30
    # Correlate dispersion with higher index to induce a realistic trade-off
    dispersion = float(disp_components + 0.20 * max(0.0, refractive_index - 1.50))

    # Add measurement/evaluation noise (noise model enabled)
    n_noise_sd = 0.0015
    d_noise_sd = 0.015
    n_meas = refractive_index + float(rng.normal(0.0, n_noise_sd))
    d_meas = dispersion + float(rng.normal(0.0, d_noise_sd))

    # Return mean and SEM for each metric
    return {
        REFRACTIVE_INDEX: (n_meas, n_noise_sd),
        DISPERSION: (d_meas, d_noise_sd),
    }


# Create Ax client and define the experiment
ax_client = AxClient()

ax_client.create_experiment(
    name="optical_glass_composition_optimization",
    parameters=[
        # We reparameterize the composition constraint by optimizing only two fractions;
        # the third is computed as BORON = 1 - (SILICA + TITANIA).
        { "name": SILICA,  "type": "range", "bounds": [0.0, COMPOSITION_TOTAL], "value_type": "float" },
        { "name": TITANIA, "type": "range", "bounds": [0.0, COMPOSITION_TOTAL], "value_type": "float" },
    ],
    objectives={
        REFRACTIVE_INDEX: ObjectiveProperties(minimize=False),  # maximize n
        DISPERSION: ObjectiveProperties(minimize=True),         # minimize dispersion
    },
    parameter_constraints=[
        # Compositional constraint (enforces BORON >= 0):
        f"{SILICA} + {TITANIA} <= {COMPOSITION_TOTAL}",
    ],
)

# Run sequential trials (budget: 38 melts)
NUM_TRIALS = 38
for i in range(NUM_TRIALS):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract free parameters and compute the third fraction to satisfy sum=1.0
    silica_val = float(parameterization[SILICA])
    titania_val = float(parameterization[TITANIA])
    boron_val = COMPOSITION_TOTAL - (silica_val + titania_val)

    # Evaluate the simulated glass properties
    results = simulate_optical_properties(silica_val, titania_val, boron_val)

    # Complete the trial with measured data
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve Pareto-optimal parameterizations and outcomes
pareto_results = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

# Plot observed outcomes and the empirical Pareto front
objective_names = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)

# Observed scatter
ax.scatter(df[objective_names[0]], df[objective_names[1]], fc="None", ec="k", label="Observed")

# Build Pareto frontier DataFrame from results
pareto_data = []
for v in pareto_results.values():
    # v is typically a tuple: (parameterization, (means_dict, covariances))
    # We want the means dict for plotting
    means_dict = v[1][0] if isinstance(v, tuple) and len(v) > 1 else v
    pareto_data.append(means_dict)

if len(pareto_data) > 0:
    pareto_df = pd.DataFrame(pareto_data).sort_values(objective_names[0])
    ax.plot(
        pareto_df[objective_names[0]],
        pareto_df[objective_names[1]],
        color="#0033FF",
        lw=2,
        label="Pareto Front",
    )

ax.set_xlabel(objective_names[0])
ax.set_ylabel(objective_names[1])
ax.set_title("Optical Glass Composition: Refractive Index vs. Dispersion")
ax.legend()
plt.tight_layout()
plt.show()