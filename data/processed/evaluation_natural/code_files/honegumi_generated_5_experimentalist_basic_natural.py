# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from typing import Dict, Tuple

from ax.service.ax_client import AxClient, ObjectiveProperties


# Problem-specific metric names
BIOAVAILABILITY = "bioavailability"       # %
SHELF_LIFE = "shelf_life"                 # months

# Storage temperature bounds (°C)
TEMP_MIN = 4.0
TEMP_MAX = 60.0

# Random seed for reproducibility of noisy observations
rng = np.random.default_rng(2025)


def evaluate_formulation(
    excipient_1: float,
    excipient_2: float,
    excipient_3: float,
    excipient_4: float,
    pH: float,
    storage_temperature_celsius: float,
) -> Dict[str, Tuple[float, float]]:
    """
    Simulated evaluation of a solid oral drug formulation.

    Parameters (all floats):
      - excipient_1: fraction of permeation enhancer (0..1)
      - excipient_2: fraction of solubilizer (0..1)
      - excipient_3: fraction of stabilizer/antioxidant (0..1)
      - excipient_4: fraction of disintegrant (0..1)
      - excipient_5 is computed as 1 - sum(excipients 1..4) (filler / bulking agent)
      - pH: formulation pH (1..14)
      - storage_temperature_celsius: storage temperature in °C (4..60)

    Returns:
      Dict mapping:
        - "bioavailability": (mean %, sem %)
        - "shelf_life": (mean months, sem months)

    Notes:
      - This function is a physically-inspired surrogate:
        • Bioavailability increases with solubilizer and permeation enhancer,
          is best near neutral pH for permeability, and slightly with disintegrant.
        • Shelf life decreases with temperature (Arrhenius Q10 rule),
          is best around mildly acidic pH (~4.5) for many small molecules,
          and improves with stabilizer. Surfactants may reduce stability slightly.
      - Gaussian noise is added to emulate experimental noise.
      - Replace this surrogate with real lab measurements or a validated simulator.
    """
    # Compute excipient_5 from the composition constraint
    excipient_5 = 1.0 - (excipient_1 + excipient_2 + excipient_3 + excipient_4)
    # Numerical guard
    excipient_5 = max(0.0, min(1.0, excipient_5))

    # Bioavailability model (0..100 %)
    # Roles:
    #  - excipient_1: permeation enhancer
    #  - excipient_2: solubilizer
    #  - excipient_3: stabilizer (not directly boosting BA)
    #  - excipient_4: disintegrant
    #  - excipient_5: filler (neutral to slightly negative for BA)
    enhancer_effect = 1.0 - np.exp(-3.0 * (0.6 * excipient_2 + 0.4 * excipient_1))
    disintegrant_boost = 0.12 * excipient_4  # up to +12%
    filler_penalty = -0.06 * excipient_5     # up to -6%

    # pH effect for BA: peak near physiological pH ~6.5
    ba_pH_peak = 6.5
    ba_pH_sigma = 2.0
    pH_factor_ba = np.exp(-0.5 * ((pH - ba_pH_peak) / ba_pH_sigma) ** 2)
    pH_scaler_ba = 0.6 + 0.4 * pH_factor_ba  # 0.6..1.0

    # Temperature has mild negative effect on BA relative to 25°C
    temp_ba_penalty = -0.05 * (storage_temperature_celsius - 25.0)

    ba_base = 10.0 + 75.0 * enhancer_effect  # baseline 10%, up to ~85%
    bioavailability_mean = ba_base * pH_scaler_ba + 100.0 * disintegrant_boost + 100.0 * filler_penalty + temp_ba_penalty
    bioavailability_mean = float(np.clip(bioavailability_mean, 0.0, 100.0))

    # Shelf-life model (months)
    # Base shelf-life at 25C, neutral pH, and no excipients: ~12 months
    # Improved with stabilizer, reduced by surfactants/enhancers.
    base_sl_25C = 12.0 * (1.0 + 1.6 * excipient_3)  # stabilizer boost up to +160%
    destabilizer_factor = max(0.4, 1.0 - 0.5 * excipient_1 - 0.35 * excipient_2 - 0.15 * excipient_4)
    base_sl_25C *= destabilizer_factor

    # pH effect for stability: peak ~4.5
    sl_pH_peak = 4.5
    sl_pH_sigma = 1.5
    pH_factor_sl = np.exp(-0.5 * ((pH - sl_pH_peak) / sl_pH_sigma) ** 2)
    pH_scaler_sl = 0.5 + 0.5 * pH_factor_sl  # 0.5..1.0

    # Temperature effect via Q10 rule (Q10 ~ 2)
    Q10 = 2.0
    shelf_life_temp = base_sl_25C * (Q10 ** ((25.0 - storage_temperature_celsius) / 10.0))

    shelf_life_mean = float(max(0.1, shelf_life_temp * pH_scaler_sl))

    # Add observational noise (SEM)
    ba_noise_sd = 2.5  # %
    sl_noise_sd = 1.2  # months

    ba_observed = float(bioavailability_mean + rng.normal(0.0, ba_noise_sd))
    sl_observed = float(shelf_life_mean + rng.normal(0.0, sl_noise_sd))

    # Clip to sensible ranges
    ba_observed = float(np.clip(ba_observed, 0.0, 100.0))
    sl_observed = float(max(0.0, sl_observed))

    return {
        BIOAVAILABILITY: (ba_observed, ba_noise_sd),
        SHELF_LIFE: (sl_observed, sl_noise_sd),
    }


def compute_observed_pareto(df_wide: pd.DataFrame, objectives: Tuple[str, str]) -> pd.DataFrame:
    """
    Compute the observed Pareto frontier (non-dominated set) for maximization
    given a wide DataFrame with metric columns and optionally parameter columns.

    Returns a DataFrame of the Pareto set sorted by the first objective.
    """
    m1, m2 = objectives
    points = df_wide[[m1, m2]].to_numpy()
    is_dominated = np.zeros(points.shape[0], dtype=bool)

    for i in range(points.shape[0]):
        if is_dominated[i]:
            continue
        pi = points[i]
        # dominated if exists j where pj >= pi in both and > in at least one
        dominated = (points[:, 0] >= pi[0]) & (points[:, 1] >= pi[1]) & (
            (points[:, 0] > pi[0]) | (points[:, 1] > pi[1])
        )
        dominated[i] = False
        is_dominated |= dominated

    pareto_df = df_wide.loc[~is_dominated].copy()
    pareto_df = pareto_df.sort_values(by=m1, ascending=True)
    return pareto_df


ax_client = AxClient()

# Create experiment with reparameterized compositional constraint:
# optimize excipient_1..4; compute excipient_5 = 1 - sum(excipients 1..4)
ax_client.create_experiment(
    name="drug_formulation_optimization",
    parameters=[
        {"name": "excipient_1", "type": "range", "bounds": [0.0, 1.0]},  # permeation enhancer
        {"name": "excipient_2", "type": "range", "bounds": [0.0, 1.0]},  # solubilizer
        {"name": "excipient_3", "type": "range", "bounds": [0.0, 1.0]},  # stabilizer/antioxidant
        {"name": "excipient_4", "type": "range", "bounds": [0.0, 1.0]},  # disintegrant
        {"name": "pH", "type": "range", "bounds": [1.0, 14.0]},
        {"name": "storage_temperature_celsius", "type": "range", "bounds": [TEMP_MIN, TEMP_MAX]},
    ],
    objectives={
        BIOAVAILABILITY: ObjectiveProperties(minimize=False),
        SHELF_LIFE: ObjectiveProperties(minimize=False),
    },
    parameter_constraints=[
        # compositional constraint: excipient_1 + excipient_2 + excipient_3 + excipient_4 <= 1.0
        "excipient_1 + excipient_2 + excipient_3 + excipient_4 <= 1.0",
    ],
)

# Optimization loop
N_TRIALS = 40
for _ in range(N_TRIALS):
    params, trial_index = ax_client.get_next_trial()

    e1 = params["excipient_1"]
    e2 = params["excipient_2"]
    e3 = params["excipient_3"]
    e4 = params["excipient_4"]
    ph = params["pH"]
    temp_c = params["storage_temperature_celsius"]

    results = evaluate_formulation(e1, e2, e3, e4, ph, temp_c)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve observed results
df_long = ax_client.get_trials_data_frame()

# Pivot to wide format: one row per arm, columns per metric
if "metric_name" in df_long.columns:
    df_wide = df_long.pivot_table(
        index="arm_name",
        columns="metric_name",
        values="mean",
        aggfunc="last",
    )
    # Bring parameter columns alongside metrics for inspection
    param_cols = [c for c in df_long.columns if c in {"excipient_1", "excipient_2", "excipient_3", "excipient_4", "pH", "storage_temperature_celsius"}]
    if param_cols:
        # Take last occurrence per arm for parameters
        params_per_arm = df_long.groupby("arm_name")[param_cols].last()
        df_wide = df_wide.join(params_per_arm, how="left")
else:
    # Fallback if API changes; proceed without plotting
    df_wide = pd.DataFrame()

# Compute excipient_5 for plotting/reference
if not df_wide.empty and all(col in df_wide.columns for col in ["excipient_1", "excipient_2", "excipient_3", "excipient_4"]):
    df_wide["excipient_5"] = 1.0 - (df_wide["excipient_1"] + df_wide["excipient_2"] + df_wide["excipient_3"] + df_wide["excipient_4"])

# Plot observed points and Pareto frontier (observed)
if not df_wide.empty and all(col in df_wide.columns for col in [BIOAVAILABILITY, SHELF_LIFE]):
    pareto_obs = compute_observed_pareto(df_wide[[BIOAVAILABILITY, SHELF_LIFE]], (BIOAVAILABILITY, SHELF_LIFE))

    fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
    ax.scatter(df_wide[BIOAVAILABILITY], df_wide[SHELF_LIFE], facecolors="None", edgecolors="k", label="Observed")
    if not pareto_obs.empty:
        ax.plot(
            pareto_obs[BIOAVAILABILITY],
            pareto_obs[SHELF_LIFE],
            color="#0033FF",
            lw=2,
            label="Observed Pareto Front",
        )
    ax.set_xlabel("Bioavailability (%)")
    ax.set_ylabel("Shelf life (months)")
    ax.set_title("Drug formulation trade-off: bioavailability vs shelf life")
    ax.legend()
    plt.tight_layout()
    plt.show()