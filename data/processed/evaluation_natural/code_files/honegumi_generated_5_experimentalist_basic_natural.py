# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"
obj2_name = "branin_swapped"


def branin3_moo(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    # second objective has x1 and x2 swapped
    y2 = float(
        (x1 - 5.1 / (4 * np.pi**2) * x2**2 + 5.0 / np.pi * x2 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x2)
        + 10
    )

    # Contrived way to incorporate x3 into the second objective
    y2 = y2 * (1 - 0.1 * x1 * x2 * x3)

    return {obj1_name: y, obj2_name: y2}


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
        obj2_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
    ],
)


for i in range(21):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]
    x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

    results = branin3_moo(x1, x2, x3)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)
pareto_results = ax_client.get_pareto_optimal_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto[objectives[0]],
    pareto[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])

ax.legend()
plt.show()

# Generated by adapting a Honegumi Ax skeleton for drug formulation optimization
# %pip install ax-platform==0.4.3 matplotlib numpy pandas
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from ax.service.ax_client import AxClient
from ax.service.utils.instantiation import ObjectiveProperties


# Domain-specific objective names
BIOAVAILABILITY_METRIC = "bioavailability_percent"
SHELF_LIFE_METRIC = "shelf_life_months"

# Compositional total for excipients (fractions sum to 1.0)
COMPOSITION_TOTAL = 1.0

# Random seed for reproducibility of synthetic noise
RNG = np.random.default_rng(seed=42)


def evaluate_formulation(parameterization: dict) -> dict:
    """
    Synthetic evaluation function for drug formulation.

    Parameters
    ----------
    parameterization : dict
        Keys (decision variables):
          - excipient_1_fraction (0..1)
          - excipient_2_fraction (0..1)
          - excipient_3_fraction (0..1)
          - excipient_4_fraction (0..1)
          - pH (2..9)
          - storage_temperature_celsius (4..40)
        Note: excipient_5_fraction is computed to satisfy the composition constraint.

    Returns
    -------
    dict
        {
            "bioavailability_percent": float in [0, 100],
            "shelf_life_months": float >= 0
        }

    Notes
    -----
    Replace this synthetic model with actual lab measurements or simulations:
      - Run experiment with provided parameters
      - Measure bioavailability (%) and shelf life (months)
      - Return as a dict where values are floats or (mean, SEM) tuples if SEM known
    """
    e1 = float(parameterization["excipient_1_fraction"])
    e2 = float(parameterization["excipient_2_fraction"])
    e3 = float(parameterization["excipient_3_fraction"])
    e4 = float(parameterization["excipient_4_fraction"])
    pH = float(parameterization["pH"])
    temp_c = float(parameterization["storage_temperature_celsius"])

    # Reconstruct the 5th excipient to enforce: e1 + e2 + e3 + e4 + e5 = 1.0
    e5 = COMPOSITION_TOTAL - (e1 + e2 + e3 + e4)
    # Numerical guard in case of floating errors
    if e5 < 0.0:
        e5 = 0.0
    if e5 > 1.0:
        e5 = 1.0

    # Synthetic bioavailability model:
    # - Positive contributions from e1 (surfactant-like), e3 (disintegrant-like), e5 (stabilizer-like)
    # - Negative contribution from e4 (lubricant-like) if too high
    # - pH optimal near ~6.5
    # - Weak bell-shaped temperature effect around room temp (storage-related)
    sol_score = 0.8 * e1 + 0.4 * e2 + 0.6 * e3 - 0.2 * e4 + 0.3 * e5
    sol_effect = 0.5 * (np.tanh(3.0 * sol_score) + 1.0)  # map to ~[0,1]

    pH_effect = np.exp(-((pH - 6.5) / 1.2) ** 2)  # peak near physiological pH
    temp_effect = np.exp(-((temp_c - 25.0) / 15.0) ** 2)  # near-neutral around 25C

    bioavailability = 100.0 * np.clip(0.65 * sol_effect + 0.3 * pH_effect + 0.05 * temp_effect, 0.0, 1.0)

    # Synthetic shelf-life model:
    # - Strongly dependent on storage temperature (Arrhenius-like decay with temperature)
    # - Stabilizer (e5) increases shelf life; surfactant (e1) may mildly reduce it
    # - pH stability best near neutral (~7.0)
    temp_scale = np.clip(36.0 * np.exp(-0.06 * (temp_c - 25.0)), 1.0, 60.0)  # months, capped to [1, 60]
    pH_stability = 0.6 + 0.4 * np.exp(-((pH - 7.0) / 1.3) ** 2)
    excipient_stability = 1.0 + 0.5 * e5 - 0.1 * e1 - 0.05 * e3
    shelf_life = np.clip(temp_scale * pH_stability * excipient_stability, 0.0, 72.0)

    # Add observational noise (unknown SEM; Ax will infer)
    bioavailability += RNG.normal(0.0, 2.0)  # +/- 2% noise
    shelf_life += RNG.normal(0.0, 1.0)       # +/- 1 month noise

    bioavailability = float(np.clip(bioavailability, 0.0, 100.0))
    shelf_life = float(max(0.0, shelf_life))

    return {
        BIOAVAILABILITY_METRIC: bioavailability,
        SHELF_LIFE_METRIC: shelf_life,
    }


def compute_pareto_front(df: pd.DataFrame, x_col: str, y_col: str) -> pd.DataFrame:
    """
    Compute non-dominated (Pareto) set for maximizing both x_col and y_col.

    Parameters
    ----------
    df : pd.DataFrame
        Must contain columns x_col and y_col, with no NaNs.
    x_col : str
    y_col : str

    Returns
    -------
    pd.DataFrame
        Subset of df containing only non-dominated rows. Sorted by x_col ascending.
    """
    vals = df[[x_col, y_col]].values
    n = vals.shape[0]
    dominated = np.zeros(n, dtype=bool)

    for i in range(n):
        if dominated[i]:
            continue
        for j in range(n):
            if i == j:
                continue
            # j dominates i if j is >= in both and strictly > in at least one
            if (vals[j, 0] >= vals[i, 0]) and (vals[j, 1] >= vals[i, 1]) and (
                (vals[j, 0] > vals[i, 0]) or (vals[j, 1] > vals[i, 1])
            ):
                dominated[i] = True
                break

    pareto_df = df.loc[~dominated].copy()
    pareto_df.sort_values(by=x_col, inplace=True)
    return pareto_df


def main():
    ax_client = AxClient()

    # Build experiment with reparameterized composition:
    # We optimize 4 excipient fractions directly and reconstruct the 5th so that all 5 sum to 1.0.
    ax_client.create_experiment(
        name="drug_formulation_moo",
        parameters=[
            {"name": "excipient_1_fraction", "type": "range", "bounds": [0.0, 1.0]},
            {"name": "excipient_2_fraction", "type": "range", "bounds": [0.0, 1.0]},
            {"name": "excipient_3_fraction", "type": "range", "bounds": [0.0, 1.0]},
            {"name": "excipient_4_fraction", "type": "range", "bounds": [0.0, 1.0]},
            {"name": "pH", "type": "range", "bounds": [2.0, 9.0]},
            {"name": "storage_temperature_celsius", "type": "range", "bounds": [4.0, 40.0]},
        ],
        objectives={
            BIOAVAILABILITY_METRIC: ObjectiveProperties(minimize=False),
            SHELF_LIFE_METRIC: ObjectiveProperties(minimize=False),
        },
        parameter_constraints=[
            "excipient_1_fraction + excipient_2_fraction + excipient_3_fraction + excipient_4_fraction <= 1.0"
        ],
        overwrite_existing_experiment=True,
        is_test=False,
    )

    # Run sequential optimization
    NUM_TRIALS = 60
    for _ in range(NUM_TRIALS):
        parameters, trial_index = ax_client.get_next_trial()
        # Evaluate locally (replace this call with actual experimental run)
        results = evaluate_formulation(parameters)
        ax_client.complete_trial(trial_index=trial_index, raw_data=results)

    # Retrieve results
    df = ax_client.get_trials_data_frame()
    # Keep only completed, non-null metrics
    metrics_df = df[[BIOAVAILABILITY_METRIC, SHELF_LIFE_METRIC]].dropna()

    # Compute observed Pareto front on measured data
    pareto_df = compute_pareto_front(
        metrics_df, x_col=BIOAVAILABILITY_METRIC, y_col=SHELF_LIFE_METRIC
    )

    # Plot observed data and Pareto front
    fig, ax = plt.subplots(figsize=(7, 5), dpi=150)
    ax.scatter(
        metrics_df[BIOAVAILABILITY_METRIC],
        metrics_df[SHELF_LIFE_METRIC],
        fc="None",
        ec="k",
        label="Observed",
        alpha=0.6,
    )
    if len(pareto_df) >= 2:
        ax.plot(
            pareto_df[BIOAVAILABILITY_METRIC],
            pareto_df[SHELF_LIFE_METRIC],
            color="#0033FF",
            lw=2,
            label="Pareto Front (observed)",
        )
    else:
        ax.scatter(
            pareto_df[BIOAVAILABILITY_METRIC],
            pareto_df[SHELF_LIFE_METRIC],
            color="#0033FF",
            label="Pareto Point (observed)",
        )
    ax.set_xlabel("Bioavailability (%)")
    ax.set_ylabel("Shelf life (months)")
    ax.set_title("Drug formulation optimization: Bioavailability vs. Shelf life")
    ax.legend()
    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    main()