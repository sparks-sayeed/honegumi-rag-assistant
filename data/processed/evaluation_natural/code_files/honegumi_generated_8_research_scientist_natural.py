# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
from typing import Dict, Tuple
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain-specific metric name (single objective; maximize)
metric_name = "volumetric_productivity_g_per_L_per_h"

# Reproducible randomness for the simulated evaluation
_rng = np.random.default_rng(2025)


def evaluate_fermentation(
    temperature_celsius: float, ph: float, agitation_rpm: float, rng: np.random.Generator
) -> Tuple[float, float]:
    """Simulate volumetric productivity for a recombinant protein fermentation.

    This is a realistic stub intended to be replaced by actual experimental measurement
    or a high-fidelity bioprocess simulation.

    Parameters
    - temperature_celsius: Fermentation temperature in degrees Celsius (e.g., 20–37 C for E. coli)
    - ph: Medium pH (e.g., 6.0–8.0)
    - agitation_rpm: Agitation rate in rpm (e.g., 200–1200 rpm in bench bioreactor)

    Returns
    - (mean, sem): Tuple of measured volumetric productivity (g/L/h) and its SEM to reflect noise.

    TODO: Replace with real data acquisition, e.g.:
      - Run a physical fermentation and measure volumetric productivity (titer / time)
      - Call a simulation or digital twin
      - Query a LIMS/ELN for recorded experiment outcomes
    """
    # Assumed "true" underlying optimal region (illustrative):
    # - Temperature ~30 C (reduced proteotoxic stress, adequate growth)
    # - pH ~7.0 (near-neutral)
    # - Agitation ~700 rpm (oxygen transfer without excessive shear)
    base_max = 1.2  # g/L/h, plausible peak for a lab-scale process (illustrative)

    # Gaussian preference around optima with different sensitivities (widths)
    temp_pref = np.exp(-0.5 * ((temperature_celsius - 30.0) / 5.0) ** 2)
    ph_pref = np.exp(-0.5 * ((ph - 7.0) / 0.35) ** 2)
    ag_pref = np.exp(-0.5 * ((agitation_rpm - 700.0) / 250.0) ** 2)

    # Interaction: At higher T, oxygen demand rises. If agitation is low at high T, penalize more.
    temp_excess = max(0.0, (temperature_celsius - 30.0) / 7.0)  # 0 if <= 30C, up to ~1 at 37C
    low_ot = max(0.0, (600.0 - agitation_rpm) / 400.0)  # 0 if >= 600 rpm, up to ~1 when very low
    o2_interaction_penalty = 1.0 - 0.18 * min(1.0, temp_excess * low_ot)

    # Shear penalty at very high agitation (e.g., > 1000 rpm)
    shear_penalty = 1.0 - 0.15 * (1.0 / (1.0 + np.exp(-(agitation_rpm - 1000.0) / 60.0)))

    # Aggregate the effects
    productivity_true = base_max * temp_pref * ph_pref * ag_pref * o2_interaction_penalty * shear_penalty

    # Add heteroscedastic measurement/process noise (relative + floor)
    noise_sigma = 0.05 * productivity_true + 0.02  # g/L/h
    observed = max(0.0, productivity_true + rng.normal(0.0, noise_sigma))

    # Provide an empirical SEM (e.g., 10% of prediction, with a minimum floor)
    sem = max(0.02, 0.1 * max(productivity_true, 0.1))

    return float(observed), float(sem)


# Configure Ax optimization
ax_client = AxClient()

ax_client.create_experiment(
    name="recombinant_protein_expression_optimization",
    parameters=[
        {
            "name": "temperature_celsius",
            "type": "range",
            "bounds": [20.0, 37.0],
        },
        {
            "name": "ph",
            "type": "range",
            "bounds": [6.0, 8.0],
        },
        {
            "name": "agitation_rpm",
            "type": "range",
            "bounds": [200.0, 1200.0],
        },
    ],
    objectives={
        metric_name: ObjectiveProperties(minimize=False),
    },
)

# Run 30 controlled experiments (suggested by BO)
num_trials = 30
y_observed = []

for _ in range(num_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    temperature_celsius = float(parameterization["temperature_celsius"])
    ph = float(parameterization["ph"])
    agitation_rpm = float(parameterization["agitation_rpm"])

    mean_val, sem_val = evaluate_fermentation(temperature_celsius, ph, agitation_rpm, _rng)

    # Report noisy observation back to Ax (mean, SEM)
    ax_client.complete_trial(
        trial_index=trial_index,
        raw_data={metric_name: (mean_val, sem_val)},
    )

    y_observed.append(mean_val)

# Retrieve best found parameters and their predicted metrics
best_parameters, metrics = ax_client.get_best_parameters()
print("Best parameters found:")
for k, v in best_parameters.items():
    print(f"  {k}: {v:.4f}")

best_mean = metrics[metric_name][0] if isinstance(metrics[metric_name], tuple) else metrics[metric_name]
best_sem = metrics[metric_name][1] if isinstance(metrics[metric_name], tuple) and len(metrics[metric_name]) > 1 else None
if best_sem is not None:
    print(f"Best predicted {metric_name}: {best_mean:.4f} ± {best_sem:.4f} g/L/h")
else:
    print(f"Best predicted {metric_name}: {best_mean:.4f} g/L/h")

# Visualization of observed results across trials
trial_indices = list(range(1, len(y_observed) + 1))
running_best = np.maximum.accumulate(y_observed)

plt.figure(figsize=(7, 4), dpi=150)
plt.scatter(trial_indices, y_observed, edgecolor="k", facecolor="none", label="Observed")
plt.plot(trial_indices, running_best, color="#0033FF", lw=2, label="Best to trial")
plt.xlabel("Trial number")
plt.ylabel("Volumetric productivity (g/L/h)")
plt.title("Bayesian optimization of fermentation conditions")
plt.legend()
plt.tight_layout()
plt.show()