# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    return y


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Generated for optimizing spray coating uniformity with Ax Platform
# %pip install ax-platform==0.4.3 matplotlib numpy pandas
import numpy as np
import pandas as pd
from typing import Dict, Any, Tuple
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


np.random.seed(42)


def evaluate_coating_uniformity(atomizing_air_pressure_bar: float, traverse_speed_mm_s: float) -> Dict[str, float]:
    """
    Evaluate coating uniformity for given spray parameters.

    This stub simulates a realistic response surface for coating uniformity.
    Higher is better (1.0 = perfectly uniform; 0.0 = very non-uniform).

    TODO: Replace with actual measurement integration, for example:
      - Run the physical spray process with the given parameters
      - Measure thickness across the coated surface (e.g., via profilometry or imaging)
      - Compute a uniformity score (e.g., 1 - coefficient of variation, normalized)
      - Return {'coating_uniformity': measured_uniformity_score}

    Parameters
    ----------
    atomizing_air_pressure_bar : float
        Atomizing air pressure at the spray gun (bar).
    traverse_speed_mm_s : float
        Gun traverse speed over the substrate (mm/s).

    Returns
    -------
    Dict[str, float]
        Dictionary with the measured/simulated objective.
    """
    p = atomizing_air_pressure_bar
    v = traverse_speed_mm_s

    # Simulated physically plausible landscape:
    # Primary optimum near (p ~ 1.8 bar, v ~ 180 mm/s)
    peak1 = np.exp(-(((p - 1.8) / 0.45) ** 2 + ((v - 180.0) / 60.0) ** 2))

    # Secondary local optimum to induce multi-modality
    peak2 = 0.6 * np.exp(-(((p - 1.2) / 0.25) ** 2 + ((v - 120.0) / 30.0) ** 2))

    # Penalty for overly high speed at low pressure (overspray/under-atomization)
    penalty = 0.2 * np.exp(-((p - 1.0) / 0.3) ** 2) * (1.0 / (1.0 + np.exp(-(v - 220.0) / 10.0)))

    # Combine components to create a score in [0, 1]
    signal = 0.75 * peak1 + 0.25 * peak2 - penalty

    # Add measurement noise to mimic experimental variability (e.g., 2% abs noise)
    noise = np.random.normal(loc=0.0, scale=0.02)
    uniformity_score = float(np.clip(signal + noise, 0.0, 1.0))

    return {"coating_uniformity": uniformity_score}


if __name__ == "__main__":
    # Define optimization budget and search space
    total_trials = 25

    # Initialize Ax client
    ax_client = AxClient()

    # Create experiment: maximize coating_uniformity over two continuous parameters
    ax_client.create_experiment(
        name="spray_coating_uniformity_optimization",
        parameters=[
            {
                "name": "atomizing_air_pressure_bar",
                "type": "range",
                "bounds": [0.8, 3.0],  # Adjust to your equipment limits
            },
            {
                "name": "traverse_speed_mm_s",
                "type": "range",
                "bounds": [100.0, 300.0],  # Adjust to your process window
            },
        ],
        objectives={
            "coating_uniformity": ObjectiveProperties(minimize=False),
        },
        # By default, Ax assumes noisy measurements if SEM not provided.
        # You may pass (mean, sem) tuples per metric to specify measurement error.
    )

    # Run optimization for the specified budget
    for _ in range(total_trials):
        parameterization, trial_index = ax_client.get_next_trial()

        # Extract parameters
        p_bar = float(parameterization["atomizing_air_pressure_bar"])
        v_mm_s = float(parameterization["traverse_speed_mm_s"])

        # Evaluate experiment (replace with real measurement call)
        results = evaluate_coating_uniformity(p_bar, v_mm_s)

        # Report result back to Ax
        ax_client.complete_trial(trial_index=trial_index, raw_data=results)

    # Retrieve best found parameters according to the model
    best_parameters, best_metrics = ax_client.get_best_parameters()

    # Print results summary
    print("Best parameters found:")
    for k, v in best_parameters.items():
        print(f"  {k}: {v:.4f}")

    print("\nBest observed metrics:")
    for metric_name, metric_props in best_metrics.items():
        # metric_props example keys: "mean", "sem", "objective", etc.
        mean = metric_props.get("mean", None)
        sem = metric_props.get("sem", None)
        if mean is not None:
            if sem is not None:
                print(f"  {metric_name}: mean={mean:.4f}, sem={sem:.4f}")
            else:
                print(f"  {metric_name}: mean={mean:.4f}")
        else:
            print(f"  {metric_name}: {metric_props}")

    # Visualization
    objectives = ax_client.objective_names
    df = ax_client.get_trials_data_frame()

    # Ensure consistent column access
    objective_name = objectives[0]
    if objective_name not in df.columns:
        raise RuntimeError(f"Objective '{objective_name}' not found in trials data frame columns: {df.columns.tolist()}")

    y = df[objective_name].values
    x_idx = np.arange(len(y))

    fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(12, 4), dpi=150)

    # Progress over trials
    axes[0].scatter(x_idx, y, ec="k", fc="none", label="Observed")
    axes[0].plot(x_idx, np.maximum.accumulate(y), color="#0033FF", lw=2, label="Best to Trial")
    axes[0].set_xlabel("Trial Number")
    axes[0].set_ylabel(objective_name)
    axes[0].set_title("Objective Progress")
    axes[0].legend()

    # Parameter scatter colored by objective value (if parameter cols are available)
    param_x = "atomizing_air_pressure_bar"
    param_y = "traverse_speed_mm_s"
    try:
        x_param = df[param_x].values.astype(float)
        y_param = df[param_y].values.astype(float)
        sc = axes[1].scatter(x_param, y_param, c=y, cmap="viridis", ec="k")
        axes[1].set_xlabel(param_x)
        axes[1].set_ylabel(param_y)
        axes[1].set_title("Trials in Parameter Space")
        cb = fig.colorbar(sc, ax=axes[1])
        cb.set_label(objective_name)
    except KeyError:
        axes[1].text(
            0.5,
            0.5,
            "Parameter columns not found in DataFrame.",
            ha="center",
            va="center",
            transform=axes[1].transAxes,
        )
        axes[1].set_axis_off()

    plt.tight_layout()
    plt.show()