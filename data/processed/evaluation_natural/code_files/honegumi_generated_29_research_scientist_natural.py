# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"
obj2_name = "branin_swapped"


def branin_moo(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # second objective has x1 and x2 swapped
    y2 = float(
        (x1 - 5.1 / (4 * np.pi**2) * x2**2 + 5.0 / np.pi * x2 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x2)
        + 10
    )

    return {obj1_name: y, obj2_name: y2}


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
        obj2_name: ObjectiveProperties(minimize=True),
    },
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin_moo(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)
pareto_results = ax_client.get_pareto_optimal_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto[objectives[0]],
    pareto[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])

ax.legend()
plt.show()

# Multi-objective optimization of a Li-ion CC–CV charging protocol using Ax
# %pip install ax-platform==0.4.3 matplotlib
import math
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from typing import Dict, Tuple

from ax.service.ax_client import AxClient, ObjectiveProperties


# Domain-specific objective names
SPEED_OBJ = "charging_speed"          # higher is better
DEG_OBJ = "degradation_score"         # lower is better


def evaluate_charging_protocol(parameters: Dict[str, float]) -> Dict[str, Tuple[float, float]]:
    """
    Evaluate a CC–CV charging protocol.

    Parameters:
      - cc_c_rate: Constant-current charging rate in C (0.5C–4.0C)
      - cv_voltage: Constant-voltage setpoint in V (4.05–4.25 V)
      - cutoff_current_fraction: Fraction of CC current at which CV terminates (0.03–0.20)

    Returns:
      Dict mapping:
        - "charging_speed": (dimensionless speed index, SEM or None)
        - "degradation_score": (dimensionless degradation index, SEM or None)

    Notes:
      - This function provides a physics-inspired surrogate. Replace with real
        lab measurement or high-fidelity simulation when available.
      - Speed proxy increases with higher CC rate and more relaxed CV termination,
        and decreases with higher CV voltage (which prolongs CV phase) and stricter cutoff.
      - Degradation proxy increases with higher C-rate, higher CV voltage, and stricter cutoff.
    """
    cc_c_rate = float(parameters["cc_c_rate"])
    cv_voltage = float(parameters["cv_voltage"])
    cutoff_current_fraction = float(parameters["cutoff_current_fraction"])

    # Bound safety (Ax respects bounds, this is just defensive)
    cc_c_rate = np.clip(cc_c_rate, 0.5, 4.0)
    cv_voltage = np.clip(cv_voltage, 4.05, 4.25)
    cutoff_current_fraction = np.clip(cutoff_current_fraction, 0.03, 0.20)

    # Time model (minutes). This is a simplified surrogate for demonstration.
    # CC time scales inversely with C-rate.
    alpha_cc = 0.65  # fraction of capacity charged during CC-ish
    time_cc_min = 60.0 * alpha_cc / cc_c_rate

    # CV time increases with higher CV voltage and stricter cutoff (lower cutoff fraction).
    # Also mildly increases with higher preceding CC current (more polarization).
    # Shape via exponential and logarithmic terms for realism.
    beta_cv = 0.35  # remaining fraction handled in CV-ish
    # Voltage sensitivity — small changes above ~4.15 V can extend CV time noticeably.
    cv_voltage_term = np.exp((cv_voltage - 4.15) / 0.025)
    # Stricter cutoff (smaller fraction) → longer tail
    cutoff_term = np.log(1.0 / cutoff_current_fraction + 1.0)
    # Mild dependence on C-rate due to elevated IR drop before CV
    c_rate_term = 1.0 + 0.15 * (cc_c_rate - 1.0)

    time_cv_min = 60.0 * beta_cv * cv_voltage_term * cutoff_term * c_rate_term

    total_time_min = time_cc_min + time_cv_min
    # Charging speed index: higher is better; normalized to ~0–1.5 range
    # A simple transform is inverse of time with a scale factor.
    speed_scale = 60.0  # charge-per-hour scaling into a dimensionless index
    charging_speed = speed_scale / (total_time_min + 1e-6)

    # Degradation surrogate (dimensionless):
    # - Superlinear dependence on C-rate
    # - Exponential penalty for high CV voltage (above ~4.15–4.2 V)
    # - Stricter cutoff (lower fraction) increases time spent at high V
    w_c = 0.8
    w_v = 1.0
    w_cut = 0.6

    c_component = w_c * (cc_c_rate ** 1.25)
    v_component = w_v * np.exp((cv_voltage - 4.20) / 0.015)
    cutoff_component = w_cut * (1.0 / cutoff_current_fraction - 1.0)

    degradation_score = c_component + v_component + cutoff_component

    # Add small measurement noise to simulate real experiments (unknown SEM → None)
    rng = np.random.default_rng()
    charging_speed += rng.normal(0.0, 0.02)  # small noise
    degradation_score += rng.normal(0.0, 0.05)

    # Return with unknown SEM (Ax will infer noise)
    return {
        SPEED_OBJ: (float(charging_speed), None),
        DEG_OBJ: (float(degradation_score), None),
    }


def compute_observed_metrics_df(ax_client: AxClient) -> pd.DataFrame:
    """
    Build a wide DataFrame with one row per completed trial and columns for both objectives.
    """
    df = ax_client.get_trials_data_frame()
    if df.empty:
        return df

    # Pivot to get mean values per metric; only keep fully observed trials for both metrics.
    wide = df.pivot_table(
        index="trial_index", columns="metric_name", values="mean", aggfunc="last"
    )
    # Ensure both objectives exist
    required = [SPEED_OBJ, DEG_OBJ]
    wide = wide[[c for c in required if c in wide.columns]]
    wide = wide.dropna(subset=required)
    wide = wide.reset_index()
    return wide


def pareto_mask(speed: np.ndarray, degr: np.ndarray) -> np.ndarray:
    """
    Compute non-dominated mask for two objectives:
      - speed: maximize
      - degr: minimize
    Returns a boolean mask where True indicates a Pareto-optimal point.
    """
    n = len(speed)
    is_pareto = np.ones(n, dtype=bool)
    for i in range(n):
        if not is_pareto[i]:
            continue
        # Any j that dominates i?
        dominates_i = (speed >= speed[i]) & (degr <= degr[i]) & (
            (speed > speed[i]) | (degr < degr[i])
        )
        # If any point dominates i, mark i as not Pareto
        if np.any(dominates_i):
            is_pareto[i] = False
    return is_pareto


def main():
    # Initialize Ax client
    ax_client = AxClient(random_seed=0)

    # Define search space for a CC–CV protocol
    ax_client.create_experiment(
        name="battery_cc_cv_moo",
        parameters=[
            {
                "name": "cc_c_rate",            # Constant-current rate (C)
                "type": "range",
                "bounds": [0.5, 4.0],
                "value_type": "float",
            },
            {
                "name": "cv_voltage",           # Constant-voltage setpoint (V)
                "type": "range",
                "bounds": [4.05, 4.25],
                "value_type": "float",
            },
            {
                "name": "cutoff_current_fraction",  # CV termination as fraction of CC current
                "type": "range",
                "bounds": [0.03, 0.20],
                "value_type": "float",
                "log_scale": False,
            },
        ],
        objectives={
            SPEED_OBJ: ObjectiveProperties(minimize=False),  # maximize charging speed
            DEG_OBJ: ObjectiveProperties(minimize=True),     # minimize degradation
        },
    )

    # Budget: 35 trials (cells)
    total_trials = 35
    for _ in range(total_trials):
        parameters, trial_index = ax_client.get_next_trial()
        results = evaluate_charging_protocol(parameters)
        ax_client.complete_trial(trial_index=trial_index, raw_data=results)

    # Build observed results table
    metrics_df = compute_observed_metrics_df(ax_client)
    if metrics_df.empty:
        print("No completed trials with both objectives observed.")
        return

    # Compute Pareto set on observed data
    speed = metrics_df[SPEED_OBJ].to_numpy()
    degr = metrics_df[DEG_OBJ].to_numpy()
    mask = pareto_mask(speed, degr)
    pareto_df = metrics_df.loc[mask].copy().sort_values([SPEED_OBJ, DEG_OBJ], ascending=[False, True])

    # Print Pareto-optimal trial parameterizations and metrics
    print("Pareto-optimal trials (observed):")
    for _, row in pareto_df.iterrows():
        t_idx = int(row["trial_index"])
        params = ax_client.get_trial_parameters(trial_index=t_idx)
        print(
            f"Trial {t_idx}: {SPEED_OBJ}={row[SPEED_OBJ]:.3f}, {DEG_OBJ}={row[DEG_OBJ]:.3f}, "
            f"params={params}"
        )

    # Plot observed data and Pareto frontier (observed)
    fig, ax = plt.subplots(figsize=(7, 5), dpi=130)
    ax.scatter(metrics_df[SPEED_OBJ], metrics_df[DEG_OBJ], ec="k", fc="None", label="Observed")

    # Sort Pareto front for plotting a monotone frontier
    pf = pareto_df.sort_values(SPEED_OBJ)
    ax.plot(pf[SPEED_OBJ], pf[DEG_OBJ], color="#0033FF", lw=2, label="Pareto Front (Observed)")

    ax.set_xlabel("Charging speed (higher is better)")
    ax.set_ylabel("Degradation score (lower is better)")
    ax.set_title("Battery CC–CV Charging: Observed Pareto Front")
    ax.legend()
    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    main()