# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"
obj2_name = "branin_swapped"


def branin3_moo(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    # second objective has x1 and x2 swapped
    y2 = float(
        (x1 - 5.1 / (4 * np.pi**2) * x2**2 + 5.0 / np.pi * x2 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x2)
        + 10
    )

    # Contrived way to incorporate x3 into the second objective
    y2 = y2 * (1 - 0.1 * x1 * x2 * x3)

    return {obj1_name: y, obj2_name: y2}


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
        obj2_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
    ],
)


for i in range(21):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]
    x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

    results = branin3_moo(x1, x2, x3)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)
pareto_results = ax_client.get_pareto_optimal_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto[objectives[0]],
    pareto[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])

ax.legend()
plt.show()

# Conductive ink formulation optimization with Ax (Multi-objective, compositional constraint)
# %pip install ax-platform==0.4.3 matplotlib

import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Objective metric names
conductivity_metric = "conductivity_s_per_m"
printability_metric = "printability_score"

# Total composition (fractions must sum to 1.0)
COMPOSITION_TOTAL = 1.0

# Random seed for reproducibility of the synthetic evaluation stub
np.random.seed(42)


def evaluate_conductive_ink_formulation(
    conductive_filler_fraction: float,
    polymer_binder_fraction: float,
    solvent_fraction: float,
    rheology_modifier_fraction: float,
):
    """
    Synthetic evaluation of a conductive ink formulation.

    This stub models two outcomes:
    - conductivity_s_per_m (maximize): electrical conductivity after curing.
    - printability_score (maximize): dimensionless score (~0-10) reflecting ease/quality of printing.

    Replace this function with real lab measurements or a physics-based model.
    """
    # Guard against floating point drift
    conductive_filler_fraction = max(0.0, min(1.0, conductive_filler_fraction))
    polymer_binder_fraction = max(0.0, min(1.0, polymer_binder_fraction))
    solvent_fraction = max(0.0, min(1.0, solvent_fraction))
    rheology_modifier_fraction = max(0.0, min(1.0, rheology_modifier_fraction))

    # 1) Conductivity model (percolation-inspired)
    # Effective solids fraction (post-evaporation); higher solvent -> lower solids
    solids_fraction = max(1e-6, 1.0 - solvent_fraction)
    # Effective filler in the solids phase
    eff_filler = min(0.999, conductive_filler_fraction / solids_fraction)

    # Percolation threshold and exponent (typical for conductive composites)
    phi_c = 0.16
    percolation_exponent = 2.0
    sigma0 = 1.0e6  # S/m, effective maximum conductivity scale

    if eff_filler > phi_c:
        base_sigma = sigma0 * (eff_filler - phi_c) ** percolation_exponent
    else:
        base_sigma = 0.0

    # Penalize conductivity by non-conductive components affecting contacts
    # Binder and rheology modifier increase contact resistance; more solvent risks voids/cure issues.
    contact_penalty = np.exp(
        -2.5 * polymer_binder_fraction - 2.0 * rheology_modifier_fraction
    )
    solvent_penalty = max(0.0, 1.0 - 0.6 * solvent_fraction)

    conductivity = base_sigma * contact_penalty * solvent_penalty

    # Add measurement noise to conductivity (relative)
    cond_rel_noise_sd = 0.10
    cond_noise = np.random.normal(0.0, cond_rel_noise_sd * max(1e-12, conductivity))
    conductivity_noisy = max(0.0, conductivity + cond_noise)

    # 2) Printability model (target viscosity/flow window)
    # Construct a simple "viscosity index"
    # Higher binder and rheology -> higher viscosity; filler increases viscosity but also aids transfer;
    # solvent reduces viscosity.
    viscosity_index = (
        0.9 * polymer_binder_fraction
        + 1.2 * rheology_modifier_fraction
        + 0.5 * conductive_filler_fraction
        - 1.5 * solvent_fraction
    )
    # Target viscosity index around 0.2 for good screen/inkjet balance (synthetic)
    target = 0.2
    width = 0.15
    viscosity_score = np.exp(-((viscosity_index - target) ** 2) / (2 * width**2))

    # Binder-dependent dispersion/wetting has an optimum around ~0.10
    binder_opt = 0.10
    binder_width = 0.08
    binder_score = np.exp(-((polymer_binder_fraction - binder_opt) ** 2) / (2 * binder_width**2))

    # Too much solvent can cause bleeding; downweight beyond ~0.5
    solvent_score = 1.0 - max(0.0, solvent_fraction - 0.5) * 0.8
    solvent_score = max(0.0, solvent_score)

    # Combine into a 0-10 scale
    printability = 10.0 * viscosity_score * binder_score * solvent_score

    # Add measurement noise to printability (absolute)
    print_noise_sd = 0.3
    printability_noisy = max(0.0, printability + np.random.normal(0.0, print_noise_sd))

    # Return dict of metric -> (mean, SEM); use SEM as our noise estimate
    return {
        conductivity_metric: (conductivity_noisy, cond_rel_noise_sd * max(1e-12, conductivity)),
        printability_metric: (printability_noisy, print_noise_sd),
    }


# Configure Ax multi-objective optimization with a compositional constraint via reparameterization.
ax_client = AxClient()

ax_client.create_experiment(
    name="conductive_ink_formulation_moo",
    parameters=[
        # We optimize over 3 free fractions in [0, 1] and enforce their sum <= 1.
        # The 4th fraction is computed as the remainder to satisfy total composition = 1.
        {"name": "conductive_filler_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "polymer_binder_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "solvent_fraction", "type": "range", "bounds": [0.0, 1.0]},
    ],
    objectives={
        conductivity_metric: ObjectiveProperties(minimize=False),
        printability_metric: ObjectiveProperties(minimize=False),
    },
    parameter_constraints=[
        # Compositional reparameterization: x_filler + x_binder + x_solvent <= 1.0
        # Then x_rheology_modifier = 1 - (x_filler + x_binder + x_solvent), ensuring all four sum to 1.0.
        "conductive_filler_fraction + polymer_binder_fraction + solvent_fraction <= 1.0",
    ],
    overwrite_existing_experiment=True,
    is_test=False,
)


# Run optimization for the budgeted number of trials
N_TRIALS = 45
for _ in range(N_TRIALS):
    parameters, trial_index = ax_client.get_next_trial()

    filler = parameters["conductive_filler_fraction"]
    binder = parameters["polymer_binder_fraction"]
    solvent = parameters["solvent_fraction"]
    rheology_modifier = COMPOSITION_TOTAL - (filler + binder + solvent)

    # If numerical drift causes a tiny negative, clamp to zero
    rheology_modifier = max(0.0, rheology_modifier)

    results = evaluate_conductive_ink_formulation(
        conductive_filler_fraction=filler,
        polymer_binder_fraction=binder,
        solvent_fraction=solvent,
        rheology_modifier_fraction=rheology_modifier,
    )
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)


# Retrieve Pareto-optimal set (based on observed data)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

# Prepare data for plotting
objective_names = [conductivity_metric, printability_metric]
df = ax_client.get_trials_data_frame()

# Build Pareto frontier dataframe from observed outcomes
pareto_records = []
for _, (_, metrics) in pareto.items():
    record = {}
    for m_name, value in metrics.items():
        # value may be a tuple (mean, sem) or a single mean
        if isinstance(value, tuple) or isinstance(value, list):
            record[m_name] = value[0]
        else:
            record[m_name] = value
    pareto_records.append(record)
pareto_df = pd.DataFrame(pareto_records)
if not pareto_df.empty:
    pareto_df = pareto_df.sort_values(by=objective_names[0])

# Plot observed points and Pareto frontier
fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(
    df[objective_names[0]],
    df[objective_names[1]],
    fc="None",
    ec="k",
    label="Observed",
)

if not pareto_df.empty:
    ax.plot(
        pareto_df[objective_names[0]],
        pareto_df[objective_names[1]],
        color="#0033FF",
        lw=2,
        label="Pareto Front",
    )

ax.set_xlabel(objective_names[0])
ax.set_ylabel(objective_names[1])
ax.legend()
plt.tight_layout()
plt.show()