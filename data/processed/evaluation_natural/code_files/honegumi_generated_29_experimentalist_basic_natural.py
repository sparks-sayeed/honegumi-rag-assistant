# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from ax.service.ax_client import AxClient
from ax.service.utils.instantiation import ObjectiveProperties


# Domain-specific objective names
OBJ_TIME = "charge_time"       # minutes, lower is better
OBJ_LIFE = "cycle_life"        # number of full cycles, higher is better


def evaluate_charging_protocol(charge_current_c: float, voltage_limit_v: float, cell_temperature_c: float):
    """
    Simulate a Li-ion CC-CV charging protocol with simple, physics-inspired surrogates.

    Inputs:
    - charge_current_c: C-rate (0.2C to 3.0C)
    - voltage_limit_v: CV voltage limit in Volts (4.05V to 4.35V)
    - cell_temperature_c: Ambient/cell temperature in Celsius (15C to 45C)

    Outputs:
    - Dict mapping objective names to (mean, SEM) tuples:
        - charge_time: minutes (minimize)
        - cycle_life: cycles (maximize)

    Notes:
    - This is a realistic stub for demonstration. Replace with actual lab or simulation measurements.
    """
    # Reproducible randomness per call can be controlled via np.random.seed(...) externally if desired.

    # Temperature effect on internal resistance and kinetics: optimal ~30C, quadratic penalty away from optimum
    temp_opt_c = 30.0
    temp_penalty = 1.0 + 0.002 * (cell_temperature_c - temp_opt_c) ** 2  # ~1.45x at 15C or 45C

    # CC phase approximation: ideal 1C -> ~60 minutes (ignoring taper). Penalize away from optimal temperature.
    time_cc_min = (60.0 / max(1e-6, charge_current_c)) * temp_penalty

    # Simple model for how early the voltage limit is reached (reduces CC time modestly at higher V)
    v_min, v_max = 4.05, 4.35
    v_norm = (voltage_limit_v - v_min) / (v_max - v_min)  # 0..1
    v_norm = float(np.clip(v_norm, 0.0, 1.0))
    cc_reduction_factor = 1.0 - 0.15 * v_norm  # at high V limit, CC ends a bit earlier

    # CV tail grows with higher voltage limit, higher current, and suboptimal temperature
    cv_tail_base = 5.0 + 25.0 * v_norm  # 5..30 minutes
    cv_tail_current_factor = 1.0 + 0.15 * max(0.0, charge_current_c - 1.0)
    cv_tail_temp_factor = 1.0 + 0.01 * (abs(cell_temperature_c - temp_opt_c))  # mild temp sensitivity for CV tail
    cv_tail_min = cv_tail_base * cv_tail_current_factor * cv_tail_temp_factor

    # Total charge time (ensure not unrealistically low)
    charge_time_min = max(10.0, time_cc_min * cc_reduction_factor + cv_tail_min)

    # Cycle life surrogate: Base 1000 cycles at ~1C, 4.2V, 30C; degrades with current, voltage, and hot/cold temps
    base_cycles = 1000.0

    # Current stress: superlinear degradation with C-rate
    stress_current = (charge_current_c / 1.0) ** 1.3

    # Voltage stress: exponential penalty with voltage above 4.2V
    stress_voltage = np.exp(8.0 * max(0.0, voltage_limit_v - 4.20))

    # Thermal stress: hotter temperatures accelerate side reactions; cold + high current risks plating
    hot_penalty = np.exp(0.04 * max(0.0, cell_temperature_c - 30.0))
    cold_plating_factor = 1.0 + 0.25 * max(0.0, 20.0 - cell_temperature_c) / 10.0 * max(0.0, charge_current_c - 1.0)
    stress_temp = hot_penalty * cold_plating_factor

    total_stress = stress_current * stress_voltage * stress_temp
    cycle_life_cycles = base_cycles / max(1e-6, total_stress)
    cycle_life_cycles = float(np.clip(cycle_life_cycles, 50.0, 3000.0))

    # Add observation noise and provide SEM (noise model = True)
    time_sem = 0.8  # minutes
    life_sem = 25.0  # cycles

    observed_time = float(np.random.normal(charge_time_min, time_sem))
    observed_life = float(np.random.normal(cycle_life_cycles, life_sem))

    # Ensure non-negative observations
    observed_time = max(1.0, observed_time)
    observed_life = max(1.0, observed_life)

    return {
        OBJ_TIME: (observed_time, time_sem),
        OBJ_LIFE: (observed_life, life_sem),
    }


# Initialize Ax client
ax_client = AxClient(random_seed=12345, verbose_logging=False)

# Create the experiment for multi-objective optimization
ax_client.create_experiment(
    name="battery_fast_charge_tradeoff",
    parameters=[
        {
            "name": "charge_current_c",
            "type": "range",
            "bounds": [0.2, 3.0],
            "value_type": "float",
            "log_scale": False,
        },
        {
            "name": "voltage_limit_v",
            "type": "range",
            "bounds": [4.05, 4.35],
            "value_type": "float",
            "log_scale": False,
        },
        {
            "name": "cell_temperature_c",
            "type": "range",
            "bounds": [15.0, 45.0],
            "value_type": "float",
            "log_scale": False,
        },
    ],
    objectives={
        OBJ_TIME: ObjectiveProperties(minimize=True),   # minimize charge time
        OBJ_LIFE: ObjectiveProperties(minimize=False),  # maximize cycle life
    },
)

# Run optimization for the given budget of 35 trials
for i in range(35):
    parameterization, trial_index = ax_client.get_next_trial()
    # Extract domain-specific parameters
    c_rate = parameterization["charge_current_c"]
    v_limit = parameterization["voltage_limit_v"]
    temp_c = parameterization["cell_temperature_c"]

    results = evaluate_charging_protocol(c_rate, v_limit, temp_c)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve Pareto-optimal points based on observed data (not model predictions)
pareto_results = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(7, 5), dpi=150)

# Observed points
ax.scatter(
    df[objectives[0]],  # charge_time
    df[objectives[1]],  # cycle_life
    fc="None",
    ec="k",
    label="Observed",
)

# Pareto frontier (connect Pareto-optimal observed points)
pareto_data = [p[1][0] for p in pareto_results.values()]  # extract means dict for each Pareto point
pareto_df = pd.DataFrame(pareto_data).sort_values(objectives[0])  # sort by charge_time ascending
ax.plot(
    pareto_df[objectives[0]],
    pareto_df[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front (observed)",
)

ax.set_xlabel(f"{OBJ_TIME} (min)")
ax.set_ylabel(f"{OBJ_LIFE} (cycles)")
ax.set_title("Fast-Charge vs Cycle-Life Trade-off (Ax MOO)")
ax.legend()
plt.tight_layout()
plt.show()