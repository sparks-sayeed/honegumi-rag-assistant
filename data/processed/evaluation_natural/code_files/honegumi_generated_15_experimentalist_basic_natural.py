# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


objective_name = "efficiency"  # (%) - maximize


def evaluate_solar_cell_fabrication(annealing_temperature_celsius: float, deposition_rate_nm_per_s: float) -> dict:
    """
    Evaluate a solar cell fabricated with the given process parameters.

    TODO: Replace this stub with actual experimental measurement logic.
    In production, this function should:
      - Fabricate a cell using the provided parameters (anneal temperature, deposition rate)
      - Measure the power conversion efficiency (PCE) in percent
      - Return a dict: {"efficiency": measured_efficiency_percent}

    The current implementation simulates a plausible response surface with measurement noise.
    """
    T = annealing_temperature_celsius
    R = deposition_rate_nm_per_s

    # "True" but unknown process landscape (2D peak + gentle interactions)
    # Peak around 175°C and 0.9 nm/s, with elliptical curvature and mild interaction.
    T_opt = 175.0
    R_opt = 0.9
    peak_eff = 22.5  # % maximum achievable in this synthetic landscape
    # Curvatures (the larger, the narrower the peak)
    a_T = 1.2e-3    # efficiency drop per (°C)^2
    a_R = 3.0       # efficiency drop per (nm/s)^2
    a_TR = 2.0e-2   # mild interaction term

    # Base landscape (quadratic bowl around the optimum)
    eff_mean = (
        peak_eff
        - a_T * (T - T_opt) ** 2
        - a_R * (R - R_opt) ** 2
        - a_TR * (T - T_opt) * (R - R_opt)
    )

    # Add gentle penalty if temperature or rate is far from practical ranges
    # (e.g., very low rate can cause poor film formation; very high temperature can damage layers)
    penalty = 0.0
    if T < 140:
        penalty += 0.02 * (140 - T)
    if T > 210:
        penalty += 0.03 * (T - 210)
    if R < 0.2:
        penalty += 1.2 * (0.2 - R)
    if R > 1.6:
        penalty += 1.0 * (R - 1.6)

    eff_mean -= penalty

    # Clip to a realistic range
    eff_mean = float(np.clip(eff_mean, 5.0, 24.0))

    # Heteroscedastic measurement noise (higher when far from optimum)
    distance = np.sqrt(((T - T_opt) / 25.0) ** 2 + ((R - R_opt) / 0.5) ** 2)
    noise_sd = 0.20 + 0.15 * distance  # % absolute
    measured_efficiency = float(np.random.normal(loc=eff_mean, scale=noise_sd))

    # Ensure a valid percentage
    measured_efficiency = float(np.clip(measured_efficiency, 0.0, 100.0))

    return {objective_name: measured_efficiency}


# Optional: set a seed for reproducibility of this demo. Remove for real experiments.
np.random.seed(42)

ax_client = AxClient()

# Define the experiment: optimize efficiency (%) by tuning annealing temperature and deposition rate.
ax_client.create_experiment(
    parameters=[
        {
            "name": "annealing_temperature_celsius",
            "type": "range",
            "bounds": [140.0, 210.0],  # °C - adjust to your process-safe window
        },
        {
            "name": "deposition_rate_nm_per_s",
            "type": "range",
            "bounds": [0.2, 1.6],  # nm/s - adjust to your tool's feasible range
        },
    ],
    objectives={
        objective_name: ObjectiveProperties(minimize=False),
    },
)

# Run up to 25 trials (budget)
total_trials = 25
for i in range(total_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters
    anneal_T = parameterization["annealing_temperature_celsius"]
    dep_rate = parameterization["deposition_rate_nm_per_s"]

    # Evaluate (replace with actual lab run & measurement)
    results = evaluate_solar_cell_fabrication(anneal_T, dep_rate)

    # Report results back to Ax
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve best found parameters and corresponding efficiency
best_parameters, best_metrics = ax_client.get_best_parameters()

print("Best parameters found:")
for k, v in best_parameters.items():
    print(f"  {k}: {v}")

print("\nBest observed metrics:")
for metric_name, summary in best_metrics.items():
    mean_val = summary.get("mean", summary)
    sem_val = summary.get("sem", None)
    if sem_val is not None:
        print(f"  {metric_name}: {mean_val:.3f} ± {sem_val:.3f}")
    else:
        print(f"  {metric_name}: {float(mean_val):.3f}")

# Plot results
df = ax_client.get_trials_data_frame()
y = df[objective_name]

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, y, ec="k", fc="none", label="Observed")
ax.plot(df.index, np.maximum.accumulate(y), color="#0033FF", lw=2, label="Best to Trial")
ax.set_xlabel("Trial Number")
ax.set_ylabel(f"{objective_name.title()} (%)")
ax.legend()
plt.tight_layout()
plt.show()