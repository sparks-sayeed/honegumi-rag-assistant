# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from typing import Dict, Tuple

from ax.service.ax_client import AxClient, ObjectiveProperties


# Problem: Optimize a 4-ingredient protein bar formulation under a composition constraint.
# Parameters (fractions) must sum to 1.0. We optimize two customer-centric objectives:
# - texture_score (maximize)
# - taste_score (maximize)
#
# Implementation note on composition constraint:
# Ax supports linear inequalities, not equalities. We therefore parameterize three fractions
# directly and compute the fourth as the remainder:
#   protein_base_fraction + fiber_fraction + binder_fraction <= 1.0
#   sweetener_fraction = 1.0 - (protein_base_fraction + fiber_fraction + binder_fraction)
#
# Replace the evaluation function with your actual lab/plant measurements when available.


def evaluate_protein_bar_formulation(
    protein_base_fraction: float,
    fiber_fraction: float,
    binder_fraction: float,
    sweetener_fraction: float,
    rng: np.random.Generator,
) -> Dict[str, Tuple[float, float]]:
    """Evaluate the formulation on texture and taste scores (both to maximize).

    This function simulates realistic preferences for a protein bar:
    - Texture benefits from adequate binder and not-too-high fiber and protein.
    - Taste benefits from balanced sweetness and binder; too much protein/fiber reduces taste.
    - Both metrics include small random noise to represent experimental variability.

    Replace this with actual measurement logic (e.g., panel scores, instrument texture analysis).
    Ensure the return dict maps each metric name to (mean, SEM).

    Args:
        protein_base_fraction: Fraction of protein base component (e.g., whey/pea blend).
        fiber_fraction: Fraction of fiber component (e.g., inulin, soluble fibers).
        binder_fraction: Fraction of binder (e.g., nut butter/syrup providing chew).
        sweetener_fraction: Fraction of sweetener system (e.g., syrups, low-cal sweeteners).
        rng: Numpy random generator for stochastic noise.

    Returns:
        {
            "texture_score": (mean_value, SEM),
            "taste_score": (mean_value, SEM),
        }
        Both scores are on a 0-10 scale.
    """

    # Safety: enforce valid range
    p = float(np.clip(protein_base_fraction, 0.0, 1.0))
    f = float(np.clip(fiber_fraction, 0.0, 1.0))
    b = float(np.clip(binder_fraction, 0.0, 1.0))
    s = float(np.clip(sweetener_fraction, 0.0, 1.0))

    # If rounding errors make them not sum to 1.0, renormalize minimally
    total = p + f + b + s
    if total > 0:
        p, f, b, s = p / total, f / total, b / total, s / total

    # Helper: smooth preference peak at target with width w
    def pref(x: float, target: float, width: float) -> float:
        z = (x - target) / width
        return float(np.exp(-0.5 * z * z))

    # Texture preference targets (heuristic)
    # - Moderate binder for chew (target ~0.30)
    # - Moderate protein for structure (target ~0.32)
    # - Moderate fiber for body without grittiness (target ~0.12)
    # - Moderate sweetener for softness (target ~0.23)
    tex_components = [
        0.35 * pref(b, 0.30, 0.12),
        0.20 * pref(p, 0.32, 0.15),
        0.20 * pref(f, 0.12, 0.08),
        0.25 * pref(s, 0.23, 0.10),
    ]
    # Penalize extremes that harm texture
    tex_penalty = 0.0
    tex_penalty += 0.25 * max(0.0, p - 0.45)  # too chalky above ~45% protein
    tex_penalty += 0.35 * max(0.0, f - 0.25)  # gritty above ~25% fiber

    # Interaction: binder helps mitigate high protein/fiber texture issues
    mitigation = 0.10 * b

    texture_base = 10.0 * (sum(tex_components) - tex_penalty + mitigation)

    # Taste preference targets (heuristic)
    # - Sweetness drives taste up to a point (target ~0.30)
    # - Binder supports flavor and mouthfeel (target ~0.28)
    # - Lower protein/fiber often improves perceived taste (targets slightly lower)
    taste_components = [
        0.45 * pref(s, 0.30, 0.12),
        0.30 * pref(b, 0.28, 0.15),
        0.15 * pref(p, 0.25, 0.15),
        0.10 * pref(f, 0.08, 0.08),
    ]
    taste_penalty = 0.0
    taste_penalty += 0.30 * max(0.0, p - 0.40)  # protein too high = off-notes
    taste_penalty += 0.20 * max(0.0, f - 0.18)  # fiber too high = off-notes

    # Interaction: excessive sweetener can be cloying; mild penalty above ~0.35
    taste_penalty += 0.20 * max(0.0, s - 0.35)

    taste_base = 10.0 * (sum(taste_components) - taste_penalty)

    # Add measurement noise (simulate panel/instrument variability)
    noise_sd = 0.25  # typical SEM scale for sensory panels; adjust if known
    texture_obs = texture_base + rng.normal(0.0, noise_sd)
    taste_obs = taste_base + rng.normal(0.0, noise_sd)

    # Clamp to sensible 0-10 bounds
    texture_obs = float(np.clip(texture_obs, 0.0, 10.0))
    taste_obs = float(np.clip(taste_obs, 0.0, 10.0))

    # If SEM is unknown, you may pass None. Here we provide a constant SEM to indicate noise.
    sem_texture = noise_sd
    sem_taste = noise_sd

    return {
        "texture_score": (texture_obs, sem_texture),
        "taste_score": (taste_obs, sem_taste),
    }


if __name__ == "__main__":
    rng = np.random.default_rng(42)

    # Create Ax client and experiment
    ax_client = AxClient()

    # Reparameterize 4-part composition as 3 direct parameters + computed remainder.
    # protein_base_fraction + fiber_fraction + binder_fraction <= 1.0
    # sweetener_fraction = 1.0 - (protein_base_fraction + fiber_fraction + binder_fraction)
    ax_client.create_experiment(
        name="protein_bar_formulation_moo",
        parameters=[
            {
                "name": "protein_base_fraction",
                "type": "range",
                "bounds": [0.0, 1.0],
            },
            {
                "name": "fiber_fraction",
                "type": "range",
                "bounds": [0.0, 1.0],
            },
            {
                "name": "binder_fraction",
                "type": "range",
                "bounds": [0.0, 1.0],
            },
        ],
        objectives={
            "texture_score": ObjectiveProperties(minimize=False),
            "taste_score": ObjectiveProperties(minimize=False),
        },
        parameter_constraints=[
            "protein_base_fraction + fiber_fraction + binder_fraction <= 1.0",
        ],
    )

    # Budget: 35 sequential trials
    N_TRIALS = 35
    for _ in range(N_TRIALS):
        parameterization, trial_index = ax_client.get_next_trial()

        protein = float(parameterization["protein_base_fraction"])
        fiber = float(parameterization["fiber_fraction"])
        binder = float(parameterization["binder_fraction"])
        # Enforce composition: compute sweetener as remainder
        sweetener = 1.0 - (protein + fiber + binder)
        # Numerical safety: clip to [0, 1]
        sweetener = float(np.clip(sweetener, 0.0, 1.0))

        results = evaluate_protein_bar_formulation(
            protein_base_fraction=protein,
            fiber_fraction=fiber,
            binder_fraction=binder,
            sweetener_fraction=sweetener,
            rng=rng,
        )

        ax_client.complete_trial(trial_index=trial_index, raw_data=results)

    # Retrieve Pareto-optimal formulations (based on observed data)
    pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

    # Prepare a dataframe of observed metrics
    # Fetch raw data and pivot to wide format: one row per arm, metrics as columns.
    observed_df = ax_client.experiment.fetch_data().df
    if not observed_df.empty:
        obs_pivot = (
            observed_df.pivot_table(
                index="arm_name", columns="metric_name", values="mean", aggfunc="mean"
            )
            .reset_index()
            .rename_axis(None, axis=1)
        )
    else:
        obs_pivot = pd.DataFrame(columns=["arm_name", "texture_score", "taste_score"])

    # Build Pareto frontier dataframe for plotting
    pareto_points = []
    for arm_name, (params, metrics) in pareto.items():
        # Metrics mapping: metric -> (mean, sem) or mean
        tex_val = metrics["texture_score"][0] if isinstance(metrics["texture_score"], tuple) else metrics["texture_score"]
        tas_val = metrics["taste_score"][0] if isinstance(metrics["taste_score"], tuple) else metrics["taste_score"]
        pareto_points.append({"arm_name": arm_name, "texture_score": tex_val, "taste_score": tas_val})
    pareto_df = pd.DataFrame(pareto_points)
    if not pareto_df.empty:
        pareto_df = pareto_df.sort_values(by="taste_score")

    # Plot observed points and Pareto frontier
    fig, ax = plt.subplots(figsize=(7, 5), dpi=150)
    if not obs_pivot.empty:
        ax.scatter(
            obs_pivot["taste_score"],
            obs_pivot["texture_score"],
            fc="None",
            ec="k",
            label="Observed",
        )

    if not pareto_df.empty:
        ax.plot(
            pareto_df["taste_score"],
            pareto_df["texture_score"],
            color="#0033FF",
            lw=2,
            label="Pareto Front (observed)",
        )

    ax.set_xlabel("taste_score (higher is better)")
    ax.set_ylabel("texture_score (higher is better)")
    ax.set_title("Protein Bar Formulation: Taste vs Texture")
    ax.legend(loc="best")
    plt.tight_layout()
    plt.show()

    # Print Pareto-optimal formulations with full 4-ingredient breakdown
    if pareto:
        rows = []
        for arm_name, (params, metrics) in pareto.items():
            p = float(params["protein_base_fraction"])
            f = float(params["fiber_fraction"])
            b = float(params["binder_fraction"])
            s = float(max(0.0, 1.0 - (p + f + b)))
            tex = metrics["texture_score"][0] if isinstance(metrics["texture_score"], tuple) else metrics["texture_score"]
            tas = metrics["taste_score"][0] if isinstance(metrics["taste_score"], tuple) else metrics["taste_score"]
            rows.append(
                {
                    "arm_name": arm_name,
                    "protein_base_fraction": round(p, 4),
                    "fiber_fraction": round(f, 4),
                    "binder_fraction": round(b, 4),
                    "sweetener_fraction": round(s, 4),
                    "texture_score": round(float(tex), 3),
                    "taste_score": round(float(tas), 3),
                }
            )
        pareto_table = pd.DataFrame(rows).sort_values(by=["taste_score", "texture_score"], ascending=False)
        print("\nPareto-optimal formulations (observed):")
        print(pareto_table.to_string(index=False))