# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain-specific objective names
STRENGTH_OBJ = "strength"      # Lap shear strength in MPa (maximize)
CURE_TIME_OBJ = "cure_time"    # Cure time in minutes (minimize)

# Experiment settings
BUDGET_TRIALS = 40
RANDOM_SEED = 42
np.random.seed(RANDOM_SEED)


def evaluate_adhesive_formulation(params: dict) -> dict:
    """
    Evaluate the adhesive formulation.
    Parameters expected:
      - resin_A_fraction, resin_B_fraction, resin_C_fraction in [0, 1], with sum <= 1.0
      - hardener_fraction is computed to satisfy composition sum to 1.0

    Returns:
      {
        "strength": (mean_MPa, sem_MPa),
        "cure_time": (mean_minutes, sem_minutes),
      }

    Notes:
      - This is a realistic synthetic model capturing plausible tradeoffs:
        * Strength peaks near an optimal hardener fraction (crosslink density),
          with resin A and C synergizing; too much B can reduce peak strength.
        * Cure time decreases as hardener increases, but is affected by resin choices.
      - Replace with actual lab measurement integration (instrument readouts, LIMS APIs) when available.
    """
    A = float(params.get("resin_A_fraction"))
    B = float(params.get("resin_B_fraction"))
    C = float(params.get("resin_C_fraction"))
    H = 1.0 - (A + B + C)  # Satisfy compositional constraint exactly

    # Guard against tiny negative due to numeric precision
    H = max(0.0, H)

    # Synthetic strength model (MPa)
    # Base mixture contribution from resins
    s_mix = 65.0 * A + 55.0 * B + 60.0 * C

    # Crosslinking effectiveness peaks around optimal hardener fraction (~0.22)
    crosslink_opt = 0.22
    crosslink_spread = 0.10
    f_cross = np.exp(-((H - crosslink_opt) / crosslink_spread) ** 2)  # 0..1

    # Synergy between A and C; too much B can reduce peak strength slightly
    synergy_factor = 1.0 + 0.15 * A * C
    b_penalty = 1.0 - 0.08 * max(B - 0.5, 0.0)

    strength_mean = s_mix * (0.6 + 0.4 * f_cross) * synergy_factor * b_penalty
    strength_mean = float(np.clip(strength_mean, 5.0, 120.0))  # clamp to plausible range

    # Synthetic cure time model (minutes)
    # Cure is fastest near optimal H; A and B slow curing; C slightly accelerates
    base_time = 180.0
    cure_shape = (0.60 + 2.20 * (crosslink_opt - H) ** 2)  # convex away from optimum
    resin_factor = (1.0 + 0.30 * A) * (1.0 + 0.20 * B) * (1.0 - 0.15 * C)
    cure_time_mean = base_time * cure_shape * resin_factor
    cure_time_mean = float(np.clip(cure_time_mean, 20.0, 600.0))

    # Add observational noise (assumed Gaussian) to simulate lab variability
    noise_strength_sd = 1.5  # MPa
    noise_cure_sd = 5.0      # minutes
    strength_observed = strength_mean + np.random.normal(0.0, noise_strength_sd)
    cure_time_observed = cure_time_mean + np.random.normal(0.0, noise_cure_sd)

    # Report mean observation and SEM; use noise SD as a proxy for SEM when unknown
    return {
        STRENGTH_OBJ: (float(strength_observed), float(noise_strength_sd)),
        CURE_TIME_OBJ: (float(cure_time_observed), float(noise_cure_sd)),
    }


def compute_pareto_mask(strength: np.ndarray, cure_time: np.ndarray) -> np.ndarray:
    """
    Compute Pareto-optimal mask for two objectives with directions:
      - strength: maximize
      - cure_time: minimize
    Returns a boolean mask where True indicates non-dominated (Pareto-optimal) points.
    """
    n = len(strength)
    mask = np.ones(n, dtype=bool)
    for i in range(n):
        if not mask[i]:
            continue
        for j in range(n):
            if i == j:
                continue
            dominates = (strength[j] >= strength[i] and cure_time[j] <= cure_time[i]) and (
                strength[j] > strength[i] or cure_time[j] < cure_time[i]
            )
            if dominates:
                mask[i] = False
                break
    return mask


# Initialize Ax client
ax_client = AxClient(random_seed=RANDOM_SEED)

# We represent the 4-part composition with 3 explicit parameters (A, B, C);
# hardener_fraction (H) is computed as H = 1 - (A + B + C) to enforce sum-to-one exactly.
ax_client.create_experiment(
    name="adhesive_formulation_tradeoff",
    parameters=[
        {"name": "resin_A_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "resin_B_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "resin_C_fraction", "type": "range", "bounds": [0.0, 1.0]},
    ],
    parameter_constraints=[
        "resin_A_fraction + resin_B_fraction + resin_C_fraction <= 1.0"
    ],
    objectives={
        STRENGTH_OBJ: ObjectiveProperties(minimize=False),
        CURE_TIME_OBJ: ObjectiveProperties(minimize=True),
    },
)

# Optimization loop
for _ in range(BUDGET_TRIALS):
    parameterization, trial_index = ax_client.get_next_trial()

    # Compute hardener_fraction to satisfy composition constraint
    A = parameterization["resin_A_fraction"]
    B = parameterization["resin_B_fraction"]
    C = parameterization["resin_C_fraction"]
    H = max(0.0, 1.0 - (A + B + C))
    parameterization["hardener_fraction"] = H  # for evaluation use

    results = evaluate_adhesive_formulation(parameterization)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve observed data
df = ax_client.get_trials_data_frame()

# Compute Pareto frontier from observed outcomes
# Drop NA rows if any (e.g., failed or abandoned trials)
df_plot = df[[STRENGTH_OBJ, CURE_TIME_OBJ]].dropna().reset_index(drop=True)
strength_vals = df_plot[STRENGTH_OBJ].to_numpy(dtype=float)
cure_vals = df_plot[CURE_TIME_OBJ].to_numpy(dtype=float)
pareto_mask = compute_pareto_mask(strength=strength_vals, cure_time=cure_vals)
pareto_df = df_plot[pareto_mask].sort_values(by=STRENGTH_OBJ)

# Plot Observations and Pareto Front
fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df_plot[STRENGTH_OBJ], df_plot[CURE_TIME_OBJ], fc="None", ec="k", label="Observed")
if len(pareto_df) > 1:
    ax.plot(
        pareto_df[STRENGTH_OBJ],
        pareto_df[CURE_TIME_OBJ],
        color="#0033FF",
        lw=2,
        label="Pareto Front",
    )
elif len(pareto_df) == 1:
    ax.scatter(
        pareto_df[STRENGTH_OBJ],
        pareto_df[CURE_TIME_OBJ],
        color="#0033FF",
        label="Pareto-optimal",
    )
ax.set_xlabel("Strength (MPa) – maximize")
ax.set_ylabel("Cure time (min) – minimize")
ax.legend()
plt.tight_layout()
plt.show()