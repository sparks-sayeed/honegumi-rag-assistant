# Generated by Honegumi (adapted to anti-corrosion coating optimization)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Objective name
corrosion_metric_name = "corrosion_damage"


def simulate_corrosion_damage(
    resin_fraction: float,
    inhibitor_fraction: float,
    insulator_fraction: float,
    stabilizer_fraction: float,
    coating_thickness_microns: float,
    rng: np.random.Generator,
) -> tuple[float, float]:
    """
    Synthetic evaluator for corrosion damage (lower is better).

    This function encodes plausible relationships:
    - Barrier improvement from resin/insulator/stabilizer (diminishing returns).
    - Inhibitor with saturating protection.
    - Thickness increases protection but too thick can crack (penalty).
    - Synergy between resin and inhibitor.
    - Penalties for very low stabilizer or resin (instability/adhesion issues).
    - Penalty for excessive insulator fraction (brittleness).

    Returns:
      (mean_damage, sem): A tuple containing the measured corrosion damage and an SEM.
    """
    t = coating_thickness_microns

    # Base damage without any protection (arbitrary units)
    base_damage = 10.0

    # Protective contributions (bounded via weights)
    barrier_improvement = 4.0 * (
        0.50 * resin_fraction + 0.35 * insulator_fraction + 0.15 * stabilizer_fraction
    )

    inhibitor_improvement = 4.0 * (
        inhibitor_fraction / (inhibitor_fraction + 0.08 + 1e-12)
    )  # saturating

    thickness_improvement = 3.0 * (1.0 - np.exp(-t / 60.0))  # saturating with thickness

    synergy_improvement = 1.5 * resin_fraction * inhibitor_fraction

    # Penalties
    penalty_thickness = 2.5 * max(0.0, (t - 120.0) / 80.0) ** 2  # too thick -> cracking risk
    penalty_insulator_high = 10.0 * max(0.0, insulator_fraction - 0.55) ** 2
    penalty_low_stabilizer = 5.0 * max(0.0, 0.05 - stabilizer_fraction)
    penalty_low_resin = 5.0 * max(0.0, 0.25 - resin_fraction)

    damage = (
        base_damage
        - (barrier_improvement + inhibitor_improvement + thickness_improvement + synergy_improvement)
        + (penalty_thickness + penalty_insulator_high + penalty_low_stabilizer + penalty_low_resin)
    )

    # Ensure non-negative damage in the synthetic model
    damage = float(max(0.05, damage))

    # Add measurement noise and report SEM to Ax
    meas_noise_sd = 0.2
    measured_damage = float(damage + rng.normal(0.0, meas_noise_sd))
    sem = meas_noise_sd

    return measured_damage, sem


# Reparameterized compositional total for resin + inhibitor + insulator + stabilizer = 1.0
# We choose resin, inhibitor, insulator as decision variables and compute stabilizer from the sum.
composition_total = 1.0

# Reproducible randomness for synthetic evaluation
rng = np.random.default_rng(2025)

ax_client = AxClient()

# Create experiment with domain-specific parameters and constraints
ax_client.create_experiment(
    name="anti_corrosion_coating_optimization",
    parameters=[
        # Composition fractions (three are explicit decision variables)
        {"name": "resin_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "inhibitor_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "insulator_fraction", "type": "range", "bounds": [0.0, 1.0]},
        # Coating thickness in micrometers (set a practical default range; adjust as needed)
        {"name": "coating_thickness_microns", "type": "range", "bounds": [10.0, 200.0]},
    ],
    objectives={
        corrosion_metric_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        # Reparameterized composition constraint: stabilizer_fraction = 1 - (resin + inhibitor + insulator) >= 0
        "resin_fraction + inhibitor_fraction + insulator_fraction <= 1.0",
        # Ordering constraints: resin >= inhibitor and resin >= insulator
        "inhibitor_fraction <= resin_fraction",
        "insulator_fraction <= resin_fraction",
    ],
)

# Batch size (parallelism)
batch_size = 6

# Number of batches (total evaluations = num_batches * batch_size)
num_batches = 25

for _ in range(num_batches):
    parameterizations, optimization_complete = ax_client.get_next_trials(batch_size)
    for trial_index, params in list(parameterizations.items()):
        resin = float(params["resin_fraction"])
        inhibitor = float(params["inhibitor_fraction"])
        insulator = float(params["insulator_fraction"])
        thickness = float(params["coating_thickness_microns"])

        # Derive stabilizer fraction from the composition equality constraint
        stabilizer = float(composition_total - (resin + inhibitor + insulator))
        # Numerical guard (should be >= 0 due to constraint)
        if stabilizer < -1e-8:
            # If numerical drift occurs, clip to 0 and slightly adjust resin downward to keep sum ~ 1
            stabilizer = 0.0

        damage_value, damage_sem = simulate_corrosion_damage(
            resin_fraction=resin,
            inhibitor_fraction=inhibitor,
            insulator_fraction=insulator,
            stabilizer_fraction=stabilizer,
            coating_thickness_microns=thickness,
            rng=rng,
        )

        ax_client.complete_trial(
            trial_index=trial_index,
            raw_data={corrosion_metric_name: (damage_value, damage_sem)},
        )

# Retrieve best-found parameters and summarize
best_parameters, best_metrics = ax_client.get_best_parameters()
best_resin = float(best_parameters["resin_fraction"])
best_inhibitor = float(best_parameters["inhibitor_fraction"])
best_insulator = float(best_parameters["insulator_fraction"])
best_stabilizer = float(composition_total - (best_resin + best_inhibitor + best_insulator))
best_thickness = float(best_parameters["coating_thickness_microns"])

print("Recommended formulation (fractions sum to 1):")
print(f"  resin_fraction      = {best_resin:.4f}")
print(f"  inhibitor_fraction  = {best_inhibitor:.4f}")
print(f"  insulator_fraction  = {best_insulator:.4f}")
print(f"  stabilizer_fraction = {best_stabilizer:.4f}")
print(f"  coating_thickness   = {best_thickness:.2f} microns")
print("Predicted corrosion damage (mean ± SEM):")
bm = best_metrics[corrosion_metric_name]
print(f"  {corrosion_metric_name}: {bm['mean']:.4f} ± {bm['sem']:.4f}")

# Plot results by batch: show observed and best-so-far
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

# Ensure we have a trial index for grouping by batch
if "trial_index" in df.columns:
    df = df.sort_values("trial_index").reset_index(drop=True)
    x_vals = (df["trial_index"].to_numpy() // batch_size).astype(int)
else:
    df = df.reset_index(drop=True)
    x_vals = (np.arange(len(df)) // batch_size).astype(int)

y_vals = df[corrosion_metric_name].to_numpy()
best_so_far = np.minimum.accumulate(y_vals)

fig, ax = plt.subplots(figsize=(7, 4.5), dpi=150)
ax.scatter(x_vals, y_vals, ec="k", fc="none", label="Observed")
ax.plot(x_vals, best_so_far, color="#0033FF", lw=2, label="Best to Batch")
ax.set_xlabel("Batch Number")
ax.set_ylabel(corrosion_metric_name)
ax.set_title("Anti-corrosion Coating Optimization Progress")
ax.legend()
plt.tight_layout()
plt.show()