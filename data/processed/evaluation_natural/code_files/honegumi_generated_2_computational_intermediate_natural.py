# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin3(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    return y


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
        "x1 <= x2",  # example of an order constraint
    ],
)


batch_size = 2


for i in range(21):

    parameterizations, optimization_complete = ax_client.get_next_trials(batch_size)
    for trial_index, parameterization in list(parameterizations.items()):
        # extract parameters
        x1 = parameterization["x1"]
        x2 = parameterization["x2"]
        x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

        results = branin3(x1, x2, x3)
        ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()
df.index = df.index // batch_size

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Anti-corrosion coating optimization with Ax Platform
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Global RNG for reproducibility of the synthetic evaluation (remove/replace in real experiments)
_rng = np.random.default_rng(seed=12345)


def evaluate_coating_formulation(
    resin_fraction: float,
    inhibitor_fraction: float,
    insulator_fraction: float,
    stabilizer_fraction: float,
    coating_thickness_microns: float,
) -> float:
    """Synthetic evaluation of corrosion damage for a coating formulation.
    Lower corrosion_damage is better.

    This function emulates plausible trends observed in anti-corrosion coatings:
    - Resin provides structural integrity and barrier formation (too little resin increases damage).
    - Inhibitor reduces corrosion up to an optimal loading; too much brings diminishing returns.
    - Insulator can help reduce ionic transport moderately, but high loadings can cause brittleness/cracking.
    - Stabilizer assists film formation; small optimal range is beneficial.
    - Thickness increases barrier effects with diminishing returns.
    - Observational noise is added to mimic experimental measurement noise.

    Replace this synthetic model with actual lab measurement or a physics-based simulation.
    """

    # Guard against minor numerical issues
    resin_fraction = max(0.0, min(1.0, resin_fraction))
    inhibitor_fraction = max(0.0, min(1.0, inhibitor_fraction))
    insulator_fraction = max(0.0, min(1.0, insulator_fraction))
    stabilizer_fraction = max(0.0, min(1.0, stabilizer_fraction))
    t = float(coating_thickness_microns)

    # Base scale of corrosion damage (arbitrary units)
    base_damage = 100.0

    # Resin effect: penalize if resin is too low; otherwise modest improvement with more resin
    # Below ~0.25 resin, damage increases sharply; otherwise moderate benefit
    resin_penalty = np.exp(5.0 * max(0.0, 0.25 - resin_fraction))
    resin_benefit = 1.0 / (1.0 + 1.5 * resin_fraction)
    resin_factor = resin_penalty * resin_benefit

    # Inhibitor effect: protective action peaks around ~0.08 mass fraction
    inhibitor_peak = 0.08
    inhibitor_width = 0.05
    inhibitor_protection = np.exp(-((inhibitor_fraction - inhibitor_peak) / inhibitor_width) ** 2)
    inhibitor_factor = 1.0 - 0.7 * inhibitor_protection  # up to 70% reduction in damage at optimum

    # Insulator effect: mild benefit initially, but beyond ~0.20 can increase damage due to brittleness/cracks
    insulator_knee = 0.20
    insulator_benefit = 1.0 / (1.0 + 0.8 * min(insulator_fraction, insulator_knee))
    insulator_brittle_penalty = 1.0 + 1.2 * max(0.0, insulator_fraction - insulator_knee) ** 2
    insulator_factor = insulator_benefit * insulator_brittle_penalty

    # Stabilizer effect: modest benefit, optimal near ~0.05
    stabilizer_peak = 0.05
    stabilizer_width = 0.03
    stabilizer_benefit = 0.15  # up to 15% reduction at optimum
    stabilizer_factor = 1.0 - stabilizer_benefit * np.exp(
        -((stabilizer_fraction - stabilizer_peak) / stabilizer_width) ** 2
    )

    # Thickness effect: diminishing returns; characteristic length scale ~80 microns
    thickness_scale = 80.0
    thickness_factor = np.exp(-t / thickness_scale)

    # Interaction: if resin is too low and insulator is high, cracks exacerbate corrosion
    crack_interaction = 1.0 + 2.0 * max(0.0, 0.22 - resin_fraction) * max(0.0, insulator_fraction - 0.18)

    # Combine all factors multiplicatively
    damage = base_damage
    damage *= resin_factor
    damage *= inhibitor_factor
    damage *= insulator_factor
    damage *= stabilizer_factor
    damage *= thickness_factor
    damage *= crack_interaction

    # Add observation noise to mimic measurement variability (heteroskedastic clipping)
    noise = _rng.normal(loc=0.0, scale=2.0)
    damage_noisy = max(0.0, damage + noise)

    return float(damage_noisy)


# Create Ax client and experiment
ax_client = AxClient()

# We optimize 4 explicit parameters and compute resin_fraction via composition:
# resin_fraction = 1.0 - (inhibitor_fraction + insulator_fraction + stabilizer_fraction)
# Constraints ensure resin_fraction >= inhibitor_fraction and resin_fraction >= insulator_fraction.
ax_client.create_experiment(
    name="anti_corrosion_coating_optimization",
    parameters=[
        {
            "name": "inhibitor_fraction",
            "type": "range",
            "bounds": [0.0, 1.0],
        },
        {
            "name": "insulator_fraction",
            "type": "range",
            "bounds": [0.0, 1.0],
        },
        {
            "name": "stabilizer_fraction",
            "type": "range",
            "bounds": [0.0, 1.0],
        },
        {
            "name": "coating_thickness_microns",
            "type": "range",
            "bounds": [10.0, 200.0],
        },
    ],
    objectives={
        "corrosion_damage": ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        # Composition constraint to ensure resin_fraction >= 0
        "inhibitor_fraction + insulator_fraction + stabilizer_fraction <= 1.0",
        # Order constraints encoded linearly with resin_fraction = 1 - (inhib + insul + stab)
        # resin >= inhibitor  ->  1 - (inh + ins + stab) >= inh  ->  2*inh + ins + stab <= 1
        "2.0*inhibitor_fraction + 1.0*insulator_fraction + 1.0*stabilizer_fraction <= 1.0",
        # resin >= insulator  ->  1 - (inh + ins + stab) >= ins  ->  inh + 2*ins + stab <= 1
        "1.0*inhibitor_fraction + 2.0*insulator_fraction + 1.0*stabilizer_fraction <= 1.0",
    ],
)

# Experimental setup
batch_size = 6
n_batches = 20  # total evaluations = batch_size * n_batches

for _ in range(n_batches):
    parameterizations, optimization_complete = ax_client.get_next_trials(batch_size)
    for trial_index, params in list(parameterizations.items()):
        inhibitor_fraction = float(params["inhibitor_fraction"])
        insulator_fraction = float(params["insulator_fraction"])
        stabilizer_fraction = float(params["stabilizer_fraction"])
        coating_thickness_microns = float(params["coating_thickness_microns"])

        # Compute resin via composition
        resin_fraction = 1.0 - (inhibitor_fraction + insulator_fraction + stabilizer_fraction)
        # Numerical guard (should be non-negative due to constraints)
        resin_fraction = max(0.0, resin_fraction)

        corrosion_damage = evaluate_coating_formulation(
            resin_fraction=resin_fraction,
            inhibitor_fraction=inhibitor_fraction,
            insulator_fraction=insulator_fraction,
            stabilizer_fraction=stabilizer_fraction,
            coating_thickness_microns=coating_thickness_microns,
        )
        ax_client.complete_trial(trial_index=trial_index, raw_data=corrosion_damage)

    if optimization_complete:
        break

best_parameters, best_values = ax_client.get_best_parameters()
# Compute and print derived resin_fraction for the best recommendation
best_resin_fraction = 1.0 - (
    best_parameters["inhibitor_fraction"]
    + best_parameters["insulator_fraction"]
    + best_parameters["stabilizer_fraction"]
)
print("Best settings found:")
print(
    {
        "resin_fraction": round(best_resin_fraction, 4),
        "inhibitor_fraction": round(best_parameters["inhibitor_fraction"], 4),
        "insulator_fraction": round(best_parameters["insulator_fraction"], 4),
        "stabilizer_fraction": round(best_parameters["stabilizer_fraction"], 4),
        "coating_thickness_microns": round(best_parameters["coating_thickness_microns"], 2),
    }
)
print("Estimated best corrosion_damage:", best_values)

# Plot progress of observed and best-so-far corrosion damage by batch
objective_name = ax_client.objective_names[0]
df = ax_client.get_trials_data_frame()
df.index = df.index // batch_size  # group by batch index
y = df[objective_name].values

fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
ax.scatter(df.index.values, y, ec="k", fc="none", label="Observed")
best_to_date = np.minimum.accumulate(y)
ax.plot(df.index.values, best_to_date, color="#0033FF", lw=2, label="Best to Batch")
ax.set_xlabel("Batch Index")
ax.set_ylabel("corrosion_damage")
ax.legend()
plt.tight_layout()
plt.show()