# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin3(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    return y


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
    ],
)


for i in range(21):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]
    x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

    results = branin3(x1, x2, x3)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Generated from Honegumi skeleton and adapted for MAX phase conductivity optimization
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from typing import Dict, Tuple
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Reproducibility for the synthetic, noisy evaluator
rng = np.random.default_rng(seed=42)


def evaluate_max_phase_conductivity(M_fraction: float, A_fraction: float, X_fraction: float) -> Dict[str, float]:
    """
    Synthetic, noisy evaluator for electrical conductivity (S/m) of a MAX phase composition.
    This function mimics data-driven composition-property relationships using simple
    compositional/structural proxy descriptors and interaction terms.

    Parameters
    ----------
    M_fraction : float
        Fraction of the transition metal sublattice (M).
    A_fraction : float
        Fraction of the A-group sublattice (A).
    X_fraction : float
        Fraction of the C/N sublattice (X).
    Returns
    -------
    Dict[str, float]
        Dictionary with the objective value for 'electrical_conductivity' (S/m).

    Notes
    -----
    - This stub is designed to be realistic and smooth for Bayesian optimization.
    - Replace with actual measurement, simulation, or model inference when available.
    """

    # Sanity normalization to protect against tiny numerical drift
    total = M_fraction + A_fraction + X_fraction
    if not np.isclose(total, 1.0, atol=1e-8):
        M_fraction /= total
        A_fraction /= total
        X_fraction /= total

    M, A, X = M_fraction, A_fraction, X_fraction

    # Proxy atomic/structural descriptors (representative values)
    # These are not material-specific but provide plausible nonlinearities.
    pauling_en = {"M": 1.65, "A": 1.80, "X": 2.60}  # electronegativity
    metallic_radius = {"M": 1.45, "A": 1.25, "X": 0.75}  # angstroms
    valence_electrons = {"M": 4.0, "A": 3.0, "X": 4.0}  # simplified VEC proxies

    # Compositional proxies
    VEC = M * valence_electrons["M"] + A * valence_electrons["A"] + X * valence_electrons["X"]  # in [3, 4]
    VEC_scaled = (VEC - 3.0) / (4.0 - 3.0)  # scale to [0, 1]

    # Weighted electronegativity mismatch driving localization/scattering
    en_M, en_A, en_X = pauling_en["M"], pauling_en["A"], pauling_en["X"]
    en_mismatch = (
        M * A * abs(en_M - en_A)
        + M * X * abs(en_M - en_X)
        + A * X * abs(en_A - en_X)
    )
    # Target moderate mismatch (hetero-bonding benefits) around ~0.5 of max
    max_en_mismatch = max(abs(en_M - en_A), abs(en_M - en_X), abs(en_A - en_X)) / 2.0
    en_alignment = np.exp(-((en_mismatch - max_en_mismatch) ** 2) / (0.25 * max_en_mismatch**2 + 1e-12))

    # Lattice distortion proxy due to radius differences (penalizes conductivity)
    r_M, r_A, r_X = metallic_radius["M"], metallic_radius["A"], metallic_radius["X"]
    distortion = (
        M * A * (r_M - r_A) ** 2
        + M * X * (r_M - r_X) ** 2
        + A * X * (r_A - r_X) ** 2
    )
    # Scale distortion (larger = worse conductivity)
    distortion_scaled = distortion / ( (max(r_M, r_A, r_X) - min(r_M, r_A, r_X)) ** 2 + 1e-12 )

    # Layered MAX structural "sweet spot" often near X ~ 1/3 for n~1 phases
    anisotropy_pref = np.exp(-((X - (1.0 / 3.0)) ** 2) / (2 * (0.18 ** 2)))

    # Simple interaction/synergy terms capturing M-A and M-X phase stability trends
    # Normalized to [0, 1] approximately
    synergy = 4.0 * (M * A) + 2.0 * (M * X)

    # Combine features into a signal for conductivity; tuned weights to give a multimodal surface
    signal = (
        0.8 * VEC_scaled
        + 1.1 * en_alignment
        - 0.7 * distortion_scaled
        + 1.0 * anisotropy_pref
        + 0.5 * synergy
    )

    # Map signal to conductivity scale (S/m), with mild nonlinear transformation and noise
    base = 1.0e6
    scale = 2.8e6
    conductivity = base + scale * np.tanh(signal)

    # Add measurement noise (heteroscedastic-type small noise)
    noise = rng.normal(loc=0.0, scale=5.0e4 * (1.0 + 0.2 * (M * A + M * X + A * X)))
    conductivity_noisy = float(np.clip(conductivity + noise, 1.0e5, 1.0e7))

    return {"electrical_conductivity": conductivity_noisy}


# Define total for compositional constraint: M + A + X == 1.0
composition_total = 1.0

# Configure Ax for single-objective, noisy optimization with a composition constraint
ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "M_fraction", "type": "range", "bounds": [0.0, composition_total]},
        {"name": "A_fraction", "type": "range", "bounds": [0.0, composition_total]},
    ],
    objectives={
        "electrical_conductivity": ObjectiveProperties(minimize=False),
    },
    parameter_constraints=[
        f"M_fraction + A_fraction <= {composition_total}",  # Reparameterize equality: X_fraction = 1 - (M + A)
    ],
)

# Optimization budget
n_trials = 30

for _ in range(n_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract M and A; derive X to satisfy composition constraint
    M_fraction = float(parameterization["M_fraction"])
    A_fraction = float(parameterization["A_fraction"])
    X_fraction = float(composition_total - (M_fraction + A_fraction))
    X_fraction = max(0.0, X_fraction)  # numeric protection, should be >= 0 by constraint

    # Evaluate the objective (noisy)
    results = evaluate_max_phase_conductivity(M_fraction, A_fraction, X_fraction)

    # Since this is a single objective, we can pass the float directly
    ax_client.complete_trial(trial_index=trial_index, raw_data=results["electrical_conductivity"])

# Retrieve best parameters and corresponding metric
best_parameters, best_values = ax_client.get_best_parameters()
best_conductivity = best_values[ax_client.objective_names[0]]["mean"]

# Build a tidy DataFrame of trials for convenience
df = ax_client.get_trials_data_frame()
objective_name = ax_client.objective_names[0]
y_series = df[objective_name].astype(float)

# Plot observed conductivity and running best
fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, y_series, ec="k", fc="none", label="Observed")
ax.plot(df.index, np.maximum.accumulate(y_series.values), color="#0033FF", lw=2, label="Best to Trial")
ax.set_xlabel("Trial Number")
ax.set_ylabel("Electrical Conductivity (S/m)")
ax.set_title("MAX Phase Conductivity Optimization")
ax.legend()
plt.tight_layout()
plt.show()

print("Best composition found:")
# Reconstruct X from M and A for display completeness
M_best = best_parameters["M_fraction"]
A_best = best_parameters["A_fraction"]
X_best = composition_total - (M_best + A_best)
print(f"  M_fraction = {M_best:.4f}")
print(f"  A_fraction = {A_best:.4f}")
print(f"  X_fraction = {X_best:.4f}")
print(f"Best predicted electrical_conductivity = {best_conductivity:.0f} S/m")